# Aligning sequence data

## What is an alignment ?

We want to compare individuals, species, whatever. To do this we need to compare what is comparable. Alignment to the rescue.

-   We want to find similarities in 2 sequences and put these similarities together, so we can compare sequences.

-   When we align 2 sequences together we talk about **pairwise** alignment as opposed to **multiple** alignment where we align more than 2 sequences all together. We will first focus on pairwise alignment.

2 ways of going about for pairwise alignment [@sungAlgorithmsBioinformaticsPractical2011]:

-   **Global alignment**: we look at the entirety of the 2 sequences and take all that information into account when aligning

-   **Local alignment**: we look at the sequences portion by portion, trying to find the best place where they match up.

### Why align ?

-   hamming distance is an easy method [@hammingCodingInformationTheory1980]

    -   Although it is easy to compute -\> sequences must have same length

    -   When dealing with DNA/proteins we have to be able to deal with insertions/deletions and hamming cannot do that...

-   This is very similar to other well known problems in computer science: the string-edit problem [@gusfieldAlgorithmsStringsTrees1997] and the Levenshtein distance [@levenshteinBinaryCodesCapable1966]

-   Alignments are used in many cases so that:

    -   we can examine similarities/differences between them (i.e. comparative genomics ) [@hardisonComparativeGenomics2003]

    -   we can infer (usually with multiple alignment):

        -   evolutionary relationships (phylogenetics), and most methods to reconstruct phylogenetic trees take as input a multiple alignment: [@felsensteinEvolutionaryTreesDNA1981; @kumarMEGAMolecularEvolutionary1994; @kozlovRAxMLNGFastScalable2019; @guindonNewAlgorithmsMethods2010; @priceFastTreeApproximatelyMaximumLikelihood2010]

        -   protein:

            -   structure [@jumperHighlyAccurateProtein2021; @karplusPredictingProteinStructure1999 ]

            -   function [@watsonPredictingProteinFunction2005; @leePredictingProteinFunction2007]

    -   we can correct sequencing errors [@hacklProovreadLargescaleHighaccuracy2014; @korenHybridErrorCorrection2012; @salmelaCorrectingErrorsShort2011].

    -   Structural variant detection [@medvedevComputationalMethodsDiscovering2009; @mahmoudStructuralVariantCalling2019]

### How to align two sequences ?

The seminal method for pairwise alignment was the Needleman-WÃ¼nsch algorithm [@needlemanGeneralMethodApplicable1970] based on a dynamic programming method. A decade later, the Smith-Waterman algorithm [@smithIdentificationCommonMolecular1981] was developed with similar ideas to perform local alignment. Both are still used today for pairwise alignment.

Dynamic programming is a method to solve complex problems by breaking it into smaller sub-problems and solving each one optimally and separately [@bradleyAppliedMathematicalProgramming1977; @bellmanTheoryDynamicProgramming1954], it is widely used when we wish to have a precise alignment between 2 sequences.

#### Global alignment

-   We do global alignment when we expect two sequences to be related and of similar genes/proteins, etc...
-   short presentation of NW algo:
    -   The score of an alignment can be defined recursively -\> dynamic programming

    -   Fill out DP matrix

    -   Traceback to find optimal alignment
-   Example... (can be at the same time as the algo presentation)
-   This algorithm although very precise, has a time complexity of $O(nm)$ where $n$ and $m$ are the lengths of the sequences to align [@sungAlgorithmsBioinformaticsPractical2011]. Some methods have been proposed to speed up [@masekFasterAlgorithmComputing1980], however the complexity is still $O(nm/\log(n))$. Lower bounds have been studied and there is not much optimization we can do if we want to keep an optimal exact alignment [@vinhInformationTheoreticMeasures2010; @ullmanBoundsComplexityLongest1976]. If we want to do better we have to rely on heuristics.
-   Another issue is space complexity since we need to store the matrix, we get $O(nm)$ as well for space, so if we wish to align 2 human genomes we would need to store $\approx 10^{19}$ matrix cells, which would amount to 10 Exabytes of storage if we use 8bit integers (meaning it would take an entire data center to store that).
    -   However in practice we can do much better than that, and construct an optimal alignment in linear space complexity $O(n+m)$ [@hirschbergLinearSpaceAlgorithm1975] meaning we would only need a couple gigabytes to store the matrix for 2 human genomes.

    -   Above idea resulting in Myers-miller algorithm [@myersOptimalAlignmentsLinear1988], implemented in the EMBOSS stretcher tool [@riceEMBOSSEuropeanMolecular2000]

#### Local alignment

-   Similar ideas to NW

-   Basic example of NW

-   In terms of complexity is the same as NW in quadratic in time and space [@sungAlgorithmsBioinformaticsPractical2011] but can be taken down to linear space with the same approach as NW.

-   Optimizations were made and resulted in the Huang and Miller algorithm [@huangTimeefficientLinearspaceLocal1991] which is implemented in the EMBOSS Lalign tool [@riceEMBOSSEuropeanMolecular2000], and the Waterman Eggert algorithm [@watermanNewAlgorithmBest1987].

Both methods are implemented in many different software tools and are used when performing pairwise alignments of short sequences [@stajichBioperlToolkitPerl2002; @gentlemanBioconductorOpenSoftware2004; @riceEMBOSSEuropeanMolecular2000] with version implemented for specific CPU instruction sets [@dailyParasailSIMDLibrary2016] or GPUs [@frohmbergGPASImprovedVersion2012] to speed up alignment.

### Substitution models / scoring

When scoring an alignment we can use different scoring models/substitution matrices [@altschulSubstitutionMatrices2013]:

-   A lot of work has been done on protein scoring matrices

    -   Log-Odds models, based on the fact that mutations are not equiprobable, and some mutations will be much more common (I $\leftrightarrow$ L in proteins)

    -   PAM (Point Accepted Mutations) [@dayhoffModelEvolutionaryChange1978], gotten from studying closely related protein sequences, estimate the probability of one amino acid changing to another one over time. With more data refinements have been made for PAM-like matrices [@mullerModelingAminoAcid2000].

    -   BLOSUM [@henikoffAminoAcidSubstitution1992], similar idea to PAM except they were constructed on several "blocks". A block is a segment of a protein that is very well conserved within a family and computed the probabilities on these blocks.

    -   Some matrices estimated with ML instad of log-odds methods [@whelanGeneralEmpiricalModel2001; @leImprovedGeneralAmino2008]

    -   Model specific matrices:

        -   Transmembrane matrices [@mullerNonsymmetricScoreMatrices2001; @ngPHATTransmembranespecificSubstitution2000]

        -   Disordered regions in proteins: [@trivediAminoAcidSubstitution2019]

        -   context-specific matrices [@goonesekereContextspecificAminoAcid2008]

        -   Specific organisms like *P. falciparum* with pfSSM [@pailaGenomeBiasInfluences2008] or HIV [@nickleHIVSpecificProbabilisticModels2007]

        -   specific to global alignment [@sardiuScoreStatisticsGlobal2005]

-   Some on DNA alignment

    -   You can derive a matrix with methods similar to PAM [@chiaromonteScoringPairwiseGenomic2001]
    -   You can do codon substitution matrices [@schneiderEmpiricalCodonSubstitution2005], or combine codon matrices with AA matrices [@doron-faigenboimCombinedEmpiricalMechanistic2007]

### Dealing with gaps

-   biologically longer deletions are more likely than plenty of shorter ones

    -   Here a short example of 2 alignments with different gap strategies

-   Semi global alignment (i.e. gaps on the ends of the sequence are free...)

-   Affine gap penalties, proposed by Gotoh [@gotohImprovedAlgorithmMatching1982]

-   Non affine gap penalties [@bennerEmpiricalStructuralModels1993; @guSizeDistributionInsertions1995; @watermanEfficientSequenceAlignment1984]

## How do we speed up pairwise alignment ?

review [@chaoDevelopmentsAlgorithmsSequence2022], we need heuristics.

-   Bounded DP [@spougeSpeedingDynamicProgramming1989a; @fickettFastOptimalAlignment1984], we can make an assumption about the relationship between the sequences, there will probably not be many gaps, therefore the scores we will used will be concentrated around the diagonal of the DP matrix c.f. \@ref(fig:optimMethods)

-   HMMs:

    -   PairHMMs can be used to align 2 sequences, in some cases it is mathematically equivalent to NW [@durbinBiologicalSequenceAnalysis1998].

    -   Software: HHsearch [@sodingProteinHomologyDetection2005], HMMer [@finnHMMERWebServer2011], MCALIGN2 [@wangMCALIGN2FasterAccurate2006],

-   General idea:

    -   Seed + extend for local alignment

    -   Find anchors for global alignment

    -   In both cases: divide and conquer approach: as you can restrict the DP matrix by blocks defined by the anchors/seeds c.f. \@ref(fig:optimMethods)

    -   Many ways of finding seeds

```{r}
optimCaption <- "**2 heuristic methods to speed up alignment:**\
divide and conquer and bounded dynamic programming. Adapted from [@chaoDevelopmentsAlgorithmsSequence2022] **(Original figure here as a placeholder, I will adapt it)**"
```

```{r, optimMethods, label="optimMethods", fig.cap=optimCaption, out.width="80%", eval=knitr::is_html_output()}
knitr::include_graphics("./figures/Align-Intro/optim-to-adapt.png")
```

```{=tex}
\begin{figure}[h]
\centering
\includegraphics[width=\linewidth]{./figures/Align-Intro/optim-to-adapt.png}
\extcaption{2 heuristic methods to speed up alignment:}{divide and conquer and bounded dynamic programming. Adapted from \autocite{chaoDevelopmentsAlgorithmsSequence2022} \textbf{(Original figure here as a placeholder, I will adapt it)}
}
\label{fig:optimMethods}
\end{figure}
```
-   Building indices/databases (useful when you want to try aligning a query sequence to a bunch of possible targets, i.e. in order to search for homology, this does approximate local alignment):

    -   BLAST [@altschulBasicLocalAlignment1990]

        -   We break up our sequences into overlapping "words" i.e. all possible short sub-sequences.

        -   Construct a database of words with positions in the reference sequence(s)

        -   Get list of words for your query sequence and generate possible "hits", i.e. words that align with your query words with a score higher than a threshold.

        -   Scan the database for these generated words, if you find one it is a hit and these 2 words are a candidate position for a local alignment.

        -   extend the local alignment with SW in both directions from the hit to get a local alignment, stop extending if the alignment score gets too low.

        -   Plenty of variants: BLASTP for proteins, BLASTN or MEGABLAST for DNA, BLASTX for comparing DNA query to a protein database, PSI-BLAST that iteratively refines the alignment by building multiple alignments from the statistically significant alignments, learns a specific scoring matrix from this and starts over, other people have refined the heuristic for even faster seed prediction as in UBLAST [@edgarSearchClusteringOrders2010].

        -   It is important to note that it is a heuristic method, it has a decreased sensitivity to the SW algorithm which is optimal [@shpaerSensitivitySelectivityProtein1996], it is however much faster and can allow users to search for similarities among millions of sequences at once

        -   Particularly useful, one of the most cited papers in the world: quickly search for homologs of unknown sequences, ... available as a web service hosted by NCBI (<https://blast.ncbi.nlm.nih.gov/Blast.cgi>).

    -   FASTA [@pearsonImprovedToolsBiological1988], derived from FASTP [@lipmanRapidSensitiveProtein1985] which could not deal with gaps, preceded BLAST.

        -   Similarly to BLAST, break query up into overlapping words

        -   Scan the library for exact-matching words to build up regions with high similarity (save 10 best regions)

        -   Score regions with a substitution matrix

        -   High scoring regions are combined to build an approximate alignment

        -   Highest scoring ungapped alignment is realigned with banded SW.

    -   Both methods are very Fast, taking only a couple seconds to find approximate local alignments for 100 sequences [@saripellaBenchmarkingNextGeneration2016] in a database of over 80 million sequences [@finnPfamProteinFamilies2016], with HMMs being quite slow. It is much faster to use these than to try to do the same task with SW or NW [@essoussiComparisonFourPairwise2007].

    -   Both BLAST and FASTA compute a statistical p-value for a pairwise alignment and an expected number of random hits when scanning the database (E-value) [@karlinMethodsAssessingStatistical1990a; @mottAlignmentStatisticalSignificance2005]

    -   Specific data structures Particularly used when aligning NGS data [@liSurveySequenceAlignment2010]:

        -   Suffix Trees/suffix arrays:

            -   Used in many pattern matching problems [@gusfieldAlgorithmsStringsTrees1997].

            -   Software: AVID uses suffix trees to find anchors [@brayAVIDGlobalAlignment2003], MUMmer finds largest identical subsequences between 2 sequences to anchor alignments using suffix trees [@delcherFastAlgorithmsLargescale2002]

        -   FM index [@ferraginaOpportunisticDataStructures2000]:

            -   In some cases when using suffix trees take too much memory we can use an FM indiex which is based on the burrows wheeler transform [@burrowsBlockSortingLosslessData1994].

            -   used for in exact and approximate string matching [@sungAlgorithmsBioinformaticsPractical2011]

            -   Software: BWT-SW uses an FM-index to speed up local alignment [@lamCompressedIndexingLocal2008], Bowtie 2 uses an FM index to find seeds [@langmeadFastGappedreadAlignment2012], BWA and BWA-SW use a similar idea [@liFastAccurateShort2009; @liFastAccurateLongread2010], BWA-MEM [@liAligningSequenceReads2013] and CUSHAW [@liuLongReadAlignment2012] also uses FM indices to find exact matches to seed a local alignment .

-   You can also find seeds with Fast Fourier Transforms (FFT) as in MAFFT [@katohMAFFTNovelMethod2002] by quickly computing correlations with FFT to find homologous regions.

## MSA (short)

When we need to compare a lot of individuals together we can do MSA.

NP-hard problem so we need heuristics or tricks

Even if we align all sequences pairwise we need to then combine all gaps and stuff -\> complicated.

#### Progressive

guide tree, clustering of sequences then refine alignment. Good heuristic but with larger datasets, becomes harder. [@fengProgressiveSequenceAlignment1987]

#### HMMs / profile alignments / pairwise

Example of COVID where homology is high so we can get away with using HMMS / pairwise to root sequence. *(point to appendix with covid align ?)*

#### Other optimization methods (short)

-   Simulated annealing

-   Genetic algorithm

## The case of Mapping

Huge review of mapping in [@alserTechnologyDictatesAlgorithms2021]

-   Mapping is effectively the task of finding a bunch of independent local alignments between query sequences and a target reference sequence.
-   context of short read (query) on large reference sequence (even with long reads they are usually much smaller than the reference genome)
-   Problems:
    -   Repetitive regions (centromeres, telomeres) make it hard [@alserTechnologyDictatesAlgorithms2021]

    -   low homology / sequencing errors... make mapping and other tasks hard [@gusfieldAlgorithmsStringsTrees1997]
-   short-reads mapping
    -   benchmarks/review [@schbathMappingReadsGenomic2012; @hatemBenchmarkingShortSequence2013]

    -   Algorithms in short read mapping [@canzarShortReadMapping2017] (basically same thing as speeding up section)

    -   Hardware accelerated [@olsonHardwareAccelerationShort2012]
-   Long read mapping:
    -   software: winnowmap [@jainWeightedMinimizerSampling2020], winnowmap2 [@jainLongreadMappingRepetitive2022] and tandemtools [@mikheenkoTandemToolsMappingLong2020] for repetitive regions.

\printbibliography[segment=\therefsegment,heading=subbibintoc,title={References for chapter \thechapter}]
