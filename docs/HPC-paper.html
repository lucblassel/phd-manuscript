<!DOCTYPE html>
<html lang="" xml:lang="">
<head>

  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <title>Chapter 3 Contribution 1: Improving read alignment by exploring a sequence transformation space | From sequences to knowledge, improving and learning from sequence alignments.</title>
  <meta name="description" content="Chapter 3 Contribution 1: Improving read alignment by exploring a sequence transformation space | From sequences to knowledge, improving and learning from sequence alignments." />
  <meta name="generator" content="bookdown 0.26 and GitBook 2.6.7" />

  <meta property="og:title" content="Chapter 3 Contribution 1: Improving read alignment by exploring a sequence transformation space | From sequences to knowledge, improving and learning from sequence alignments." />
  <meta property="og:type" content="book" />
  
  
  <meta name="github-repo" content="lucblassel/phd-manuscript" />

  <meta name="twitter:card" content="summary" />
  <meta name="twitter:title" content="Chapter 3 Contribution 1: Improving read alignment by exploring a sequence transformation space | From sequences to knowledge, improving and learning from sequence alignments." />
  
  
  

<meta name="author" content="Luc Blassel" />


<meta name="date" content="2022-06-24" />

  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black" />
  
  
<link rel="prev" href="aligning-sequence-data.html"/>
<link rel="next" href="learning-from-alignments.html"/>
<script src="libs/jquery-3.6.0/jquery-3.6.0.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/fuse.js@6.4.6/dist/fuse.min.js"></script>
<link href="libs/gitbook-2.6.7/css/style.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-table.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-bookdown.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-highlight.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-search.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-fontsettings.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-clipboard.css" rel="stylesheet" />








<link href="libs/anchor-sections-1.1.0/anchor-sections.css" rel="stylesheet" />
<link href="libs/anchor-sections-1.1.0/anchor-sections-hash.css" rel="stylesheet" />
<script src="libs/anchor-sections-1.1.0/anchor-sections.js"></script>
<link href="libs/tabwid-1.0.0/tabwid.css" rel="stylesheet" />
<link href="libs/tabwid-1.0.0/scrool.css" rel="stylesheet" />



<style type="text/css">
/* Used with Pandoc 2.11+ new --citeproc when CSL is used */
div.csl-bib-body { }
div.csl-entry {
  clear: both;
}
.hanging div.csl-entry {
  margin-left:2em;
  text-indent:-2em;
}
div.csl-left-margin {
  min-width:2em;
  float:left;
}
div.csl-right-inline {
  margin-left:2em;
  padding-left:1em;
}
div.csl-indent {
  margin-left: 2em;
}
</style>

<link rel="stylesheet" href="style.css" type="text/css" />
</head>

<body>



  <div class="book without-animation with-summary font-size-2 font-family-1" data-basepath=".">

    <div class="book-summary">
      <nav role="navigation">

<ul class="summary">
<li><a href="./">My PhD thesis.</a></li>

<li class="divider"></li>
<li><a href="index.html#section"></a>
<ul>
<li class="chapter" data-level="" data-path="index.html"><a href="index.html"><i class="fa fa-check"></i>Abstract</a></li>
<li class="chapter" data-level="" data-path="index.html"><a href="index.html#résumé"><i class="fa fa-check"></i>Résumé</a></li>
<li class="chapter" data-level="" data-path="index.html"><a href="index.html#acknowledgments"><i class="fa fa-check"></i>Acknowledgments</a></li>
<li class="chapter" data-level="" data-path="index.html"><a href="index.html#glossary"><i class="fa fa-check"></i>Glossary</a></li>
</ul></li>
<li class="chapter" data-level="" data-path="general-introduction.html"><a href="general-introduction.html"><i class="fa fa-check"></i>General Introduction</a>
<ul>
<li class="chapter" data-level="" data-path="general-introduction.html"><a href="general-introduction.html#organization-of-this-manuscript"><i class="fa fa-check"></i>Organization of this manuscript</a></li>
<li class="chapter" data-level="" data-path="general-introduction.html"><a href="general-introduction.html#research-output"><i class="fa fa-check"></i>Research output</a>
<ul>
<li class="chapter" data-level="" data-path="general-introduction.html"><a href="general-introduction.html#journal-publications"><i class="fa fa-check"></i>Journal publications</a></li>
<li class="chapter" data-level="" data-path="general-introduction.html"><a href="general-introduction.html#presentations-and-posters"><i class="fa fa-check"></i>Presentations and posters</a></li>
</ul></li>
</ul></li>
<li class="chapter" data-level="1" data-path="what-is-sequence-data.html"><a href="what-is-sequence-data.html"><i class="fa fa-check"></i><b>1</b> What is Sequence data ?</a>
<ul>
<li class="chapter" data-level="1.1" data-path="what-is-sequence-data.html"><a href="what-is-sequence-data.html#biological-sequences-a-primer"><i class="fa fa-check"></i><b>1.1</b> Biological sequences, a primer</a>
<ul>
<li class="chapter" data-level="1.1.1" data-path="what-is-sequence-data.html"><a href="what-is-sequence-data.html#what-is-dna"><i class="fa fa-check"></i><b>1.1.1</b> What is DNA ?</a></li>
<li class="chapter" data-level="1.1.2" data-path="what-is-sequence-data.html"><a href="what-is-sequence-data.html#from-information-to-action"><i class="fa fa-check"></i><b>1.1.2</b> From Information to action</a></li>
</ul></li>
<li class="chapter" data-level="1.2" data-path="what-is-sequence-data.html"><a href="what-is-sequence-data.html#obtaining-sequence-data"><i class="fa fa-check"></i><b>1.2</b> Obtaining sequence data</a>
<ul>
<li class="chapter" data-level="1.2.1" data-path="what-is-sequence-data.html"><a href="what-is-sequence-data.html#sanger-sequencing-a-breakthrough"><i class="fa fa-check"></i><b>1.2.1</b> Sanger sequencing, a breakthrough</a></li>
<li class="chapter" data-level="1.2.2" data-path="what-is-sequence-data.html"><a href="what-is-sequence-data.html#next-generation-sequencing"><i class="fa fa-check"></i><b>1.2.2</b> Next-generation sequencing</a></li>
</ul></li>
<li class="chapter" data-level="1.3" data-path="what-is-sequence-data.html"><a href="what-is-sequence-data.html#sequencing-errors-how-to-account-for-them"><i class="fa fa-check"></i><b>1.3</b> Sequencing errors, how to account for them ?</a>
<ul>
<li class="chapter" data-level="1.3.1" data-path="what-is-sequence-data.html"><a href="what-is-sequence-data.html#error-correction-methods"><i class="fa fa-check"></i><b>1.3.1</b> Error correction methods</a></li>
<li class="chapter" data-level="1.3.2" data-path="what-is-sequence-data.html"><a href="what-is-sequence-data.html#more-accurate-sequencing-methods"><i class="fa fa-check"></i><b>1.3.2</b> More accurate sequencing methods</a></li>
</ul></li>
<li class="chapter" data-level="1.4" data-path="what-is-sequence-data.html"><a href="what-is-sequence-data.html#the-special-case-of-homopolymers"><i class="fa fa-check"></i><b>1.4</b> The special case of homopolymers</a>
<ul>
<li class="chapter" data-level="1.4.1" data-path="what-is-sequence-data.html"><a href="what-is-sequence-data.html#homopolymers-and-the-genome"><i class="fa fa-check"></i><b>1.4.1</b> Homopolymers and the genome</a></li>
<li class="chapter" data-level="1.4.2" data-path="what-is-sequence-data.html"><a href="what-is-sequence-data.html#homopolymers-and-long-reads"><i class="fa fa-check"></i><b>1.4.2</b> Homopolymers and long reads</a></li>
<li class="chapter" data-level="1.4.3" data-path="what-is-sequence-data.html"><a href="what-is-sequence-data.html#accounting-for-homopolymers"><i class="fa fa-check"></i><b>1.4.3</b> Accounting for homopolymers</a></li>
</ul></li>
<li class="chapter" data-level="1.5" data-path="what-is-sequence-data.html"><a href="what-is-sequence-data.html#conclusion"><i class="fa fa-check"></i><b>1.5</b> Conclusion</a></li>
</ul></li>
<li class="chapter" data-level="2" data-path="aligning-sequence-data.html"><a href="aligning-sequence-data.html"><i class="fa fa-check"></i><b>2</b> Aligning sequence data</a>
<ul>
<li class="chapter" data-level="2.1" data-path="aligning-sequence-data.html"><a href="aligning-sequence-data.html#what-is-an-alignment"><i class="fa fa-check"></i><b>2.1</b> What is an alignment ?</a>
<ul>
<li class="chapter" data-level="2.1.1" data-path="aligning-sequence-data.html"><a href="aligning-sequence-data.html#why-align"><i class="fa fa-check"></i><b>2.1.1</b> Why align ?</a></li>
<li class="chapter" data-level="2.1.2" data-path="aligning-sequence-data.html"><a href="aligning-sequence-data.html#how-to-align-two-sequences"><i class="fa fa-check"></i><b>2.1.2</b> How to align two sequences ?</a></li>
<li class="chapter" data-level="2.1.3" data-path="aligning-sequence-data.html"><a href="aligning-sequence-data.html#substitution-models-scoring"><i class="fa fa-check"></i><b>2.1.3</b> Substitution models / scoring</a></li>
<li class="chapter" data-level="2.1.4" data-path="aligning-sequence-data.html"><a href="aligning-sequence-data.html#dealing-with-gaps"><i class="fa fa-check"></i><b>2.1.4</b> Dealing with gaps</a></li>
</ul></li>
<li class="chapter" data-level="2.2" data-path="aligning-sequence-data.html"><a href="aligning-sequence-data.html#how-do-we-speed-up-pairwise-alignment"><i class="fa fa-check"></i><b>2.2</b> How do we speed up pairwise alignment ?</a>
<ul>
<li class="chapter" data-level="2.2.1" data-path="aligning-sequence-data.html"><a href="aligning-sequence-data.html#change-the-method"><i class="fa fa-check"></i><b>2.2.1</b> Change the method</a></li>
<li class="chapter" data-level="2.2.2" data-path="aligning-sequence-data.html"><a href="aligning-sequence-data.html#seed-and-extend-with-data-structures"><i class="fa fa-check"></i><b>2.2.2</b> Seed and extend with data structures</a></li>
</ul></li>
<li class="chapter" data-level="2.3" data-path="aligning-sequence-data.html"><a href="aligning-sequence-data.html#multiple-sequence-alignment"><i class="fa fa-check"></i><b>2.3</b> Multiple sequence alignment</a>
<ul>
<li class="chapter" data-level="2.3.1" data-path="aligning-sequence-data.html"><a href="aligning-sequence-data.html#progressive-alignment"><i class="fa fa-check"></i><b>2.3.1</b> Progressive alignment</a></li>
<li class="chapter" data-level="2.3.2" data-path="aligning-sequence-data.html"><a href="aligning-sequence-data.html#hmms-in-profile-profile-or-seq-profile-alignments"><i class="fa fa-check"></i><b>2.3.2</b> HMMs in profile-profile or seq-profile alignments</a></li>
<li class="chapter" data-level="2.3.3" data-path="aligning-sequence-data.html"><a href="aligning-sequence-data.html#other-methods-short"><i class="fa fa-check"></i><b>2.3.3</b> Other methods (short)</a></li>
</ul></li>
<li class="chapter" data-level="2.4" data-path="aligning-sequence-data.html"><a href="aligning-sequence-data.html#the-specificities-of-read-mapping"><i class="fa fa-check"></i><b>2.4</b> The specificities of read-mapping</a>
<ul>
<li class="chapter" data-level="2.4.1" data-path="aligning-sequence-data.html"><a href="aligning-sequence-data.html#what-is-read-mapping"><i class="fa fa-check"></i><b>2.4.1</b> What is read-mapping ?</a></li>
<li class="chapter" data-level="2.4.2" data-path="aligning-sequence-data.html"><a href="aligning-sequence-data.html#challenges-of-read-mapping"><i class="fa fa-check"></i><b>2.4.2</b> Challenges of read-mapping</a></li>
</ul></li>
</ul></li>
<li class="chapter" data-level="3" data-path="HPC-paper.html"><a href="HPC-paper.html"><i class="fa fa-check"></i><b>3</b> Contribution 1: Improving read alignment by exploring a sequence transformation space</a>
<ul>
<li class="chapter" data-level="" data-path="HPC-paper.html"><a href="HPC-paper.html#hpc-abstract"><i class="fa fa-check"></i>Abstract</a></li>
<li class="chapter" data-level="3.1" data-path="HPC-paper.html"><a href="HPC-paper.html#hpc-introduction"><i class="fa fa-check"></i><b>3.1</b> Introduction</a></li>
<li class="chapter" data-level="3.2" data-path="HPC-paper.html"><a href="HPC-paper.html#hpc-methods"><i class="fa fa-check"></i><b>3.2</b> Methods</a>
<ul>
<li class="chapter" data-level="3.2.1" data-path="HPC-paper.html"><a href="HPC-paper.html#sec:msr-def"><i class="fa fa-check"></i><b>3.2.1</b> Streaming sequence reductions</a></li>
<li class="chapter" data-level="3.2.2" data-path="HPC-paper.html"><a href="HPC-paper.html#sec:enum"><i class="fa fa-check"></i><b>3.2.2</b> Restricting the space of Streaming sequence reductions</a></li>
</ul></li>
<li class="chapter" data-level="3.3" data-path="HPC-paper.html"><a href="HPC-paper.html#datasets-and-pipelines"><i class="fa fa-check"></i><b>3.3</b> Datasets and Pipelines</a>
<ul>
<li class="chapter" data-level="3.3.1" data-path="HPC-paper.html"><a href="HPC-paper.html#datasets"><i class="fa fa-check"></i><b>3.3.1</b> Datasets</a></li>
<li class="chapter" data-level="3.3.2" data-path="HPC-paper.html"><a href="HPC-paper.html#simulation-pipeline"><i class="fa fa-check"></i><b>3.3.2</b> Simulation pipeline</a></li>
<li class="chapter" data-level="3.3.3" data-path="HPC-paper.html"><a href="HPC-paper.html#sec:evalpipeline"><i class="fa fa-check"></i><b>3.3.3</b> Evaluation pipeline</a></li>
</ul></li>
<li class="chapter" data-level="3.4" data-path="HPC-paper.html"><a href="HPC-paper.html#hpc-results"><i class="fa fa-check"></i><b>3.4</b> Results</a>
<ul>
<li class="chapter" data-level="3.4.1" data-path="HPC-paper.html"><a href="HPC-paper.html#selection-of-mapping-friendly-sequence-reductions"><i class="fa fa-check"></i><b>3.4.1</b> Selection of mapping-friendly sequence reductions</a></li>
<li class="chapter" data-level="3.4.2" data-path="HPC-paper.html"><a href="HPC-paper.html#mapping-friendly-sequence-reductions-lead-to-lower-mapping-errors-on-whole-genomes"><i class="fa fa-check"></i><b>3.4.2</b> Mapping-friendly sequence reductions lead to lower mapping errors on whole genomes</a></li>
<li class="chapter" data-level="3.4.3" data-path="HPC-paper.html"><a href="HPC-paper.html#mapping-friendly-sequence-reductions-increase-mapping-quality-on-repeated-regions-of-the-human-genome"><i class="fa fa-check"></i><b>3.4.3</b> Mapping-friendly sequence reductions increase mapping quality on repeated regions of the human genome</a></li>
<li class="chapter" data-level="3.4.4" data-path="HPC-paper.html"><a href="HPC-paper.html#raw-mapping-improves-upon-hpc-on-centromeric-regions"><i class="fa fa-check"></i><b>3.4.4</b> Raw mapping improves upon HPC on centromeric regions</a></li>
<li class="chapter" data-level="3.4.5" data-path="HPC-paper.html"><a href="HPC-paper.html#positions-of-incorrectly-mapped-reads-across-the-entire-human-genome"><i class="fa fa-check"></i><b>3.4.5</b> Positions of incorrectly mapped reads across the entire human genome</a></li>
</ul></li>
<li class="chapter" data-level="3.5" data-path="HPC-paper.html"><a href="HPC-paper.html#hpc-discussion"><i class="fa fa-check"></i><b>3.5</b> Discussion</a></li>
<li class="chapter" data-level="3.6" data-path="HPC-paper.html"><a href="HPC-paper.html#limitations-of-this-study"><i class="fa fa-check"></i><b>3.6</b> Limitations of this study</a></li>
<li class="chapter" data-level="3.7" data-path="HPC-paper.html"><a href="HPC-paper.html#code-availability"><i class="fa fa-check"></i><b>3.7</b> Code availability</a></li>
<li class="chapter" data-level="" data-path="HPC-paper.html"><a href="HPC-paper.html#supplementary-information"><i class="fa fa-check"></i>Supplementary information</a></li>
</ul></li>
<li class="chapter" data-level="4" data-path="learning-from-alignments.html"><a href="learning-from-alignments.html"><i class="fa fa-check"></i><b>4</b> Learning from alignments</a>
<ul>
<li class="chapter" data-level="4.1" data-path="learning-from-alignments.html"><a href="learning-from-alignments.html#alignments-are-a-rich-source-of-information"><i class="fa fa-check"></i><b>4.1</b> Alignments are a rich source of information</a>
<ul>
<li class="chapter" data-level="4.1.1" data-path="learning-from-alignments.html"><a href="learning-from-alignments.html#pairwise-alns"><i class="fa fa-check"></i><b>4.1.1</b> Pairwise alns</a></li>
<li class="chapter" data-level="4.1.2" data-path="learning-from-alignments.html"><a href="learning-from-alignments.html#msa"><i class="fa fa-check"></i><b>4.1.2</b> MSA</a></li>
</ul></li>
<li class="chapter" data-level="4.2" data-path="learning-from-alignments.html"><a href="learning-from-alignments.html#preprocessing-the-alignment-for-machine-learning"><i class="fa fa-check"></i><b>4.2</b> Preprocessing the alignment for machine learning</a>
<ul>
<li class="chapter" data-level="4.2.1" data-path="learning-from-alignments.html"><a href="learning-from-alignments.html#embedding-the-alignment"><i class="fa fa-check"></i><b>4.2.1</b> Embedding the alignment</a></li>
<li class="chapter" data-level="4.2.2" data-path="learning-from-alignments.html"><a href="learning-from-alignments.html#choosing-a-learning-target"><i class="fa fa-check"></i><b>4.2.2</b> Choosing a learning target</a></li>
</ul></li>
<li class="chapter" data-level="4.3" data-path="learning-from-alignments.html"><a href="learning-from-alignments.html#how-to-learn-from-alns"><i class="fa fa-check"></i><b>4.3</b> How to learn from ALNs</a>
<ul>
<li class="chapter" data-level="4.3.1" data-path="learning-from-alignments.html"><a href="learning-from-alignments.html#tests-and-statistical-learning"><i class="fa fa-check"></i><b>4.3.1</b> Tests and statistical learning</a></li>
<li class="chapter" data-level="4.3.2" data-path="learning-from-alignments.html"><a href="learning-from-alignments.html#taking-interactions-into-account"><i class="fa fa-check"></i><b>4.3.2</b> Taking interactions into account</a></li>
<li class="chapter" data-level="4.3.3" data-path="learning-from-alignments.html"><a href="learning-from-alignments.html#deep-learning"><i class="fa fa-check"></i><b>4.3.3</b> Deep Learning</a></li>
</ul></li>
</ul></li>
<li class="chapter" data-level="5" data-path="hiv-and-drms.html"><a href="hiv-and-drms.html"><i class="fa fa-check"></i><b>5</b> HIV and DRMs</a>
<ul>
<li class="chapter" data-level="5.1" data-path="hiv-and-drms.html"><a href="hiv-and-drms.html#what-are-viruses"><i class="fa fa-check"></i><b>5.1</b> What are viruses ?</a></li>
<li class="chapter" data-level="5.2" data-path="hiv-and-drms.html"><a href="hiv-and-drms.html#what-is-hiv"><i class="fa fa-check"></i><b>5.2</b> What is HIV ?</a>
<ul>
<li class="chapter" data-level="5.2.1" data-path="hiv-and-drms.html"><a href="hiv-and-drms.html#quick-presentation-of-hiv"><i class="fa fa-check"></i><b>5.2.1</b> Quick Presentation of HIV</a></li>
<li class="chapter" data-level="5.2.2" data-path="hiv-and-drms.html"><a href="hiv-and-drms.html#life-cycle-of-hiv"><i class="fa fa-check"></i><b>5.2.2</b> Life cycle of HIV</a></li>
<li class="chapter" data-level="5.2.3" data-path="hiv-and-drms.html"><a href="hiv-and-drms.html#genetics-of-hiv"><i class="fa fa-check"></i><b>5.2.3</b> Genetics of HIV</a></li>
<li class="chapter" data-level="5.2.4" data-path="hiv-and-drms.html"><a href="hiv-and-drms.html#main-protein-mechanisms-in-replication"><i class="fa fa-check"></i><b>5.2.4</b> Main protein mechanisms in replication</a></li>
</ul></li>
<li class="chapter" data-level="5.3" data-path="hiv-and-drms.html"><a href="hiv-and-drms.html#drug-resistance-in-hiv"><i class="fa fa-check"></i><b>5.3</b> Drug resistance in HIV</a>
<ul>
<li class="chapter" data-level="5.3.1" data-path="hiv-and-drms.html"><a href="hiv-and-drms.html#what-is-art"><i class="fa fa-check"></i><b>5.3.1</b> What is ART ?</a></li>
<li class="chapter" data-level="5.3.2" data-path="hiv-and-drms.html"><a href="hiv-and-drms.html#how-can-hiv-evade-art"><i class="fa fa-check"></i><b>5.3.2</b> How can HIV evade ART ?</a></li>
<li class="chapter" data-level="5.3.3" data-path="hiv-and-drms.html"><a href="hiv-and-drms.html#consequences-on-global-health"><i class="fa fa-check"></i><b>5.3.3</b> Consequences on global health</a></li>
<li class="chapter" data-level="5.3.4" data-path="hiv-and-drms.html"><a href="hiv-and-drms.html#finding-drms"><i class="fa fa-check"></i><b>5.3.4</b> Finding DRMS</a></li>
</ul></li>
</ul></li>
<li class="chapter" data-level="6" data-path="HIV-paper.html"><a href="HIV-paper.html"><i class="fa fa-check"></i><b>6</b> Contribution 2: Inferring mutation roles from sequence alignments using machine learning</a>
<ul>
<li class="chapter" data-level="" data-path="HIV-paper.html"><a href="HIV-paper.html#abstract-paper"><i class="fa fa-check"></i>Abstract</a></li>
<li class="chapter" data-level="" data-path="HIV-paper.html"><a href="HIV-paper.html#author-summary"><i class="fa fa-check"></i>Author summary</a></li>
<li class="chapter" data-level="6.1" data-path="HIV-paper.html"><a href="HIV-paper.html#hiv-introduction"><i class="fa fa-check"></i><b>6.1</b> Introduction</a></li>
<li class="chapter" data-level="6.2" data-path="HIV-paper.html"><a href="HIV-paper.html#materials-and-methods"><i class="fa fa-check"></i><b>6.2</b> Materials and methods</a>
<ul>
<li class="chapter" data-level="6.2.1" data-path="HIV-paper.html"><a href="HIV-paper.html#data"><i class="fa fa-check"></i><b>6.2.1</b> Data</a></li>
<li class="chapter" data-level="6.2.2" data-path="HIV-paper.html"><a href="HIV-paper.html#classifier-training"><i class="fa fa-check"></i><b>6.2.2</b> Classifier training</a></li>
<li class="chapter" data-level="6.2.3" data-path="HIV-paper.html"><a href="HIV-paper.html#measuring-classifier-performance"><i class="fa fa-check"></i><b>6.2.3</b> Measuring classifier performance</a></li>
</ul></li>
<li class="chapter" data-level="6.3" data-path="HIV-paper.html"><a href="HIV-paper.html#hiv-results"><i class="fa fa-check"></i><b>6.3</b> Results</a>
<ul>
<li class="chapter" data-level="6.3.1" data-path="HIV-paper.html"><a href="HIV-paper.html#classifier-performance-interpretation"><i class="fa fa-check"></i><b>6.3.1</b> Classifier performance &amp; interpretation</a></li>
<li class="chapter" data-level="6.3.2" data-path="HIV-paper.html"><a href="HIV-paper.html#additional-classification-results"><i class="fa fa-check"></i><b>6.3.2</b> Additional classification results</a></li>
<li class="chapter" data-level="6.3.3" data-path="HIV-paper.html"><a href="HIV-paper.html#identifying-new-mutations-from-classifiers"><i class="fa fa-check"></i><b>6.3.3</b> Identifying new mutations from classifiers</a></li>
<li class="chapter" data-level="6.3.4" data-path="HIV-paper.html"><a href="HIV-paper.html#detailed-analysis-of-potentially-resistance-associated-mutations"><i class="fa fa-check"></i><b>6.3.4</b> Detailed analysis of potentially resistance-associated mutations</a></li>
</ul></li>
<li class="chapter" data-level="6.4" data-path="HIV-paper.html"><a href="HIV-paper.html#discussion-and-perspectives"><i class="fa fa-check"></i><b>6.4</b> Discussion and perspectives</a></li>
<li class="chapter" data-level="" data-path="HIV-paper.html"><a href="HIV-paper.html#hiv-acknowledgments"><i class="fa fa-check"></i>Acknowledgments</a></li>
<li class="chapter" data-level="" data-path="HIV-paper.html"><a href="HIV-paper.html#supporting-information"><i class="fa fa-check"></i>Supporting Information</a></li>
</ul></li>
<li class="chapter" data-level="7" data-path="learning-alignments-an-interesting-perspective.html"><a href="learning-alignments-an-interesting-perspective.html"><i class="fa fa-check"></i><b>7</b> Learning alignments, an interesting perspective</a>
<ul>
<li class="chapter" data-level="7.1" data-path="learning-alignments-an-interesting-perspective.html"><a href="learning-alignments-an-interesting-perspective.html#learning-pairwise-alignment"><i class="fa fa-check"></i><b>7.1</b> Learning pairwise alignment</a>
<ul>
<li class="chapter" data-level="7.1.1" data-path="learning-alignments-an-interesting-perspective.html"><a href="learning-alignments-an-interesting-perspective.html#dedal"><i class="fa fa-check"></i><b>7.1.1</b> DEDAL</a></li>
<li class="chapter" data-level="7.1.2" data-path="learning-alignments-an-interesting-perspective.html"><a href="learning-alignments-an-interesting-perspective.html#predicting-an-alignment"><i class="fa fa-check"></i><b>7.1.2</b> predicting an alignment</a></li>
</ul></li>
<li class="chapter" data-level="7.2" data-path="learning-alignments-an-interesting-perspective.html"><a href="learning-alignments-an-interesting-perspective.html#what-else-could-we-learn"><i class="fa fa-check"></i><b>7.2</b> What else could we learn ?</a>
<ul>
<li class="chapter" data-level="7.2.1" data-path="learning-alignments-an-interesting-perspective.html"><a href="learning-alignments-an-interesting-perspective.html#learn-to-predict-seeds-or-starting-positions"><i class="fa fa-check"></i><b>7.2.1</b> Learn to predict seeds or starting positions</a></li>
<li class="chapter" data-level="7.2.2" data-path="learning-alignments-an-interesting-perspective.html"><a href="learning-alignments-an-interesting-perspective.html#learn-pre-processing-functions"><i class="fa fa-check"></i><b>7.2.2</b> Learn pre-processing functions</a></li>
</ul></li>
</ul></li>
<li class="chapter" data-level="" data-path="global-conclusion.html"><a href="global-conclusion.html"><i class="fa fa-check"></i>Global conclusion</a>
<ul>
<li class="chapter" data-level="" data-path="global-conclusion.html"><a href="global-conclusion.html#hpc-part"><i class="fa fa-check"></i>HPC part</a></li>
<li class="chapter" data-level="" data-path="global-conclusion.html"><a href="global-conclusion.html#hiv-part"><i class="fa fa-check"></i>HIV part</a></li>
<li class="chapter" data-level="" data-path="global-conclusion.html"><a href="global-conclusion.html#final-words"><i class="fa fa-check"></i>Final words</a></li>
</ul></li>
<li class="chapter" data-level="" data-path="global-references.html"><a href="global-references.html"><i class="fa fa-check"></i>Global References</a></li>
<li class="appendix"><span><b>Appendix</b></span></li>
<li class="chapter" data-level="A" data-path="HPC-appendix.html"><a href="HPC-appendix.html"><i class="fa fa-check"></i><b>A</b> Supporting Information for “Mapping-friendly sequence reductions: going beyond homopolymer compression”</a>
<ul>
<li class="chapter" data-level="A.1" data-path="HPC-appendix.html"><a href="HPC-appendix.html#appendix:tandemtools"><i class="fa fa-check"></i><b>A.1</b> “TandemTools” dataset generation</a></li>
<li class="chapter" data-level="A.2" data-path="HPC-appendix.html"><a href="HPC-appendix.html#msr-performance-comparison"><i class="fa fa-check"></i><b>A.2</b> MSR performance comparison</a></li>
<li class="chapter" data-level="A.3" data-path="HPC-appendix.html"><a href="HPC-appendix.html#origin-of-incorrectly-mapped-reads-of-high-mapping-quality-on-whole-human-genome."><i class="fa fa-check"></i><b>A.3</b> Origin of incorrectly mapped reads of high mapping quality on whole human genome.</a></li>
<li class="chapter" data-level="A.4" data-path="HPC-appendix.html"><a href="HPC-appendix.html#analyzing-read-origin-on-whole-human-genome"><i class="fa fa-check"></i><b>A.4</b> Analyzing read origin on whole human genome</a></li>
<li class="chapter" data-level="A.5" data-path="HPC-appendix.html"><a href="HPC-appendix.html#performance-of-msrs-on-the-drosophila-genome"><i class="fa fa-check"></i><b>A.5</b> Performance of MSRs on the Drosophila genome</a></li>
</ul></li>
<li class="chapter" data-level="B" data-path="HIV-intro-appendix.html"><a href="HIV-intro-appendix.html"><i class="fa fa-check"></i><b>B</b> Supporting Information for “HIV and DRMs”</a>
<ul>
<li class="chapter" data-level="B.1" data-path="HIV-intro-appendix.html"><a href="HIV-intro-appendix.html#detailed-list-of-hiv-1-protein-structures-used-for-figure-generation."><i class="fa fa-check"></i><b>B.1</b> Detailed list of HIV-1 protein structures used for figure generation.</a></li>
</ul></li>
<li class="chapter" data-level="C" data-path="HIV-appendix.html"><a href="HIV-appendix.html"><i class="fa fa-check"></i><b>C</b> Supporting Information for “Using Machine Learning and Big Data to Explore the Drug Resistance Landscape in HIV”</a>
<ul>
<li class="chapter" data-level="C.1" data-path="HIV-appendix.html"><a href="HIV-appendix.html#S1-Appendix"><i class="fa fa-check"></i><b>C.1</b> S1 Appendix (Technical appendix).</a>
<ul>
<li class="chapter" data-level="C.1.1" data-path="HIV-appendix.html"><a href="HIV-appendix.html#data-appendix"><i class="fa fa-check"></i><b>C.1.1</b> Data</a></li>
<li class="chapter" data-level="C.1.2" data-path="HIV-appendix.html"><a href="HIV-appendix.html#classifiers"><i class="fa fa-check"></i><b>C.1.2</b> Classifiers</a></li>
<li class="chapter" data-level="C.1.3" data-path="HIV-appendix.html"><a href="HIV-appendix.html#scoring"><i class="fa fa-check"></i><b>C.1.3</b> Scoring</a></li>
</ul></li>
<li class="chapter" data-level="C.2" data-path="HIV-appendix.html"><a href="HIV-appendix.html#s1-fig."><i class="fa fa-check"></i><b>C.2</b> S1 Fig.</a></li>
<li class="chapter" data-level="C.3" data-path="HIV-appendix.html"><a href="HIV-appendix.html#s2-fig."><i class="fa fa-check"></i><b>C.3</b> S2 Fig.</a></li>
<li class="chapter" data-level="C.4" data-path="HIV-appendix.html"><a href="HIV-appendix.html#s3-fig."><i class="fa fa-check"></i><b>C.4</b> S3 Fig.</a></li>
<li class="chapter" data-level="C.5" data-path="HIV-appendix.html"><a href="HIV-appendix.html#S1-Table"><i class="fa fa-check"></i><b>C.5</b> S1 Table.</a></li>
<li class="chapter" data-level="C.6" data-path="HIV-appendix.html"><a href="HIV-appendix.html#S2-Appendix"><i class="fa fa-check"></i><b>C.6</b> S2 Appendix. (Fisher exact tests)</a></li>
<li class="chapter" data-level="C.7" data-path="HIV-appendix.html"><a href="HIV-appendix.html#s1-data."><i class="fa fa-check"></i><b>C.7</b> S1 Data.</a></li>
<li class="chapter" data-level="C.8" data-path="HIV-appendix.html"><a href="HIV-appendix.html#s2-data."><i class="fa fa-check"></i><b>C.8</b> S2 Data.</a></li>
</ul></li>
<li class="divider"></li>
<li><a href="https://lucblassel.com" target="blank">Back to main website</a></li>
<li><a href="https://github.com/rstudio/bookdown" target="blank">Published with bookdown</a></li>

</ul>

      </nav>
    </div>

    <div class="book-body">
      <div class="body-inner">
        <div class="book-header" role="navigation">
          <h1>
            <i class="fa fa-circle-o-notch fa-spin"></i><a href="./">From sequences to knowledge, improving and learning from sequence alignments.</a>
          </h1>
        </div>

        <div class="page-wrapper" tabindex="-1" role="main">
          <div class="page-inner">

            <section class="normal" id="section-">
<div id="HPC-paper" class="section level1 hasAnchor" number="3">
<h1><span class="header-section-number">Chapter 3</span> Contribution 1: Improving read alignment by exploring a sequence transformation space<a href="HPC-paper.html#HPC-paper" class="anchor-section" aria-label="Anchor link to header"></a></h1>
<p><strong><em>Intro to this chapter within the context of the thesis to go here!</em></strong></p>
<p>Recall that:</p>
<ul>
<li><p>Homopolymers are a problem (c.f. <a href="what-is-sequence-data.html#homopolymers-and-long-reads">1.4.2</a>)</p></li>
<li><p>Mapping is hard (c.f. <a href="aligning-sequence-data.html#the-specificities-of-read-mapping">2.4</a>)</p></li>
<li><p>HPC has been used successfully used to improve mapping (c.f. <a href="what-is-sequence-data.html#hpc-trick">1.4.3.2</a>)</p></li>
</ul>
<p>This chapter was written as an article titled:<br />
<strong>“Mapping-friendly sequence reductions: going beyond homopolymer compression”</strong><br />
it was published in <strong><em>DATE HERE</em></strong>, in the iScience proceedings of the RECOMB-SEQ 2022
conference (<a href="https://doi.org/10.1371/journal.pcbi.1008873"><em>doi:10.1371/journal.pcbi.1008873</em></a>).<br />
The author list, complete with affiliations is given below:<br />
<br />
</p>
<p>Luc Blassel<sup><strong>1</strong>,<strong>2</strong>*</sup>, Paul Medvedev<sup><strong>3</strong>,<strong>4</strong>,<strong>5</strong></sup>, Rayan
Chikhi<sup><strong>1</strong></sup></p>
<p><strong>1</strong> Sequence Bioinformatics, Department of Computational Biology, Institut
Pasteur, Paris, France<br />
<strong>2</strong> Sorbonne Université, Collège doctoral, Paris, France<br />
<strong>3</strong> Department of Computer Science and Engineering, Pennsylvania State
University, University Park, Pennsylvania, United States of America<br />
<strong>4</strong> Department of Biochemistry and Molecular Biology, Pennsylvania State
University, University Park, Pennsylvania, United States of America<br />
<strong>5</strong> Center for Computational Biology and Bioinformatics, Pennsylvania State
University, University Park, Pennsylvania, United States of America<br />
<br />
</p>
<div id="hpc-abstract" class="section level2 unnumbered hasAnchor">
<h2>Abstract<a href="HPC-paper.html#hpc-abstract" class="anchor-section" aria-label="Anchor link to header"></a></h2>
<p>Sequencing errors continue to pose algorithmic challenges to methods working
with sequencing data. One of the simplest and most prevalent techniques for
ameliorating the detrimental effects of homopolymer expansion/contraction errors
present in long read data is homopolymer compression. It collapses runs of
repeated nucleotides, with the intuitive goal of removing some of the sequencing
errors and often improving mapping sensitivity. Though our intuitive
understanding justifies why homopolymer compression works, it in no way implies
that it is the best transformation that can be done. In this paper, we explore
if there are transformations that can be applied in the same pre-processing
manner as homopolymer compression that would achieve better alignment
sensitivity. We introduce a more general framework than homopolymer compression,
called mapping-friendly sequence reductions. We transform the reference and the
reads using these reductions and then apply an alignment algorithm. We
demonstrate that some mapping-friendly sequence reductions lead to improved
mapping accuracy, outperforming homopolymer compression.</p>
</div>
<div id="hpc-introduction" class="section level2 hasAnchor" number="3.1">
<h2><span class="header-section-number">3.1</span> Introduction<a href="HPC-paper.html#hpc-introduction" class="anchor-section" aria-label="Anchor link to header"></a></h2>
<p>Sequencing errors continue to pose algorithmic challenges to methods working
with read data. In short-read technologies, these tend to be substitution
errors, but in long reads, these tend to be short insertions and deletions; most
common are expansions or contractions of homopolymers (i.e. reporting 3 As
instead of 4) <span class="citation"><sup><a href="#ref-dohmBenchmarkingLongreadCorrection2020" role="doc-biblioref">81</a></sup></span>. Many algorithmic
problems, such as alignment, become trivial if not for sequencing
errors <span class="citation"><sup><a href="#ref-gusfieldAlgorithmsStringsTrees1997" role="doc-biblioref">108</a></sup></span>. Error correction can often decrease the error rate but
does not eliminate all errors. Most tools therefore incorporate the uncertainty
caused by errors into their underlying algorithms. The higher the error rate,
the more detrimental its effect on algorithm speed, memory, and accuracy. While
the sequencing error rate of any given technology tends to decrease over time,
new technologies entering the market typically have high error rates (e.g.
Oxford Nanopore Technologies). Finding better ways to cope with sequencing error
therefore remains a top priority in bioinformatics.</p>
<p>One of the simplest and most prevalent techniques for ameliorating the
detrimental effects of homopolymer expansion/contraction errors is <em>homopolymer
compression</em> (abbreviated HPC). HPC simply transforms runs of the same
nucleotide within a sequence into a single occurrence of that nucleotide. For
example, HPC applied to the sequence AAAGGTTA yields the sequence AGTA. To use
HPC in an alignment algorithm, one first compresses the reads and the reference,
then aligns each compressed read to the compressed reference, and finally
reports all alignment locations, converted into the coordinate system of the
uncompressed reference. HPC effectively removes homopolymer
expansion/contraction errors from the downstream algorithm. Though there is a
trade-off with specificity of the alignment (e.g. some of the compressed
alignments may not correspond to true alignments) the improvement in mapping
sensitivity usually outweighs it <span class="citation"><sup><a href="#ref-liMinimap2PairwiseAlignment2018" role="doc-biblioref">100</a></sup></span>.</p>
<p>The first use of HPC that we are aware of was in 2008 as a pre-processing step
for 454 pyrosequencing data in the Celera
assembler <span class="citation"><sup><a href="#ref-millerAggressiveAssemblyPyrosequencing2008" role="doc-biblioref">95</a></sup></span>. It is used by a wide
range of error-correction algorithms, e.g. for 454
data <span class="citation"><sup><a href="#ref-braggFastAccurateErrorcorrection2012" role="doc-biblioref">246</a></sup></span>, PacBio
data <span class="citation"><sup><a href="#ref-auImprovingPacBioLong2012" role="doc-biblioref">98</a></sup></span>, and Oxford Nanopore
data <span class="citation"><sup><a href="#ref-sahlinErrorCorrectionEnables2021" role="doc-biblioref">247</a></sup></span>. HPC is used in alignment, e.g. by the
widely used minimap2 aligner <span class="citation"><sup><a href="#ref-liMinimap2PairwiseAlignment2018" role="doc-biblioref">100</a></sup></span>. HPC is also
used in long-read assembly, e.g. HiCanu <span class="citation"><sup><a href="#ref-nurkHiCanuAccurateAssembly2020" role="doc-biblioref">93</a></sup></span>,
SMARTdenovo <span class="citation"><sup><a href="#ref-liuSMARTdenovoNovoAssembler2021" role="doc-biblioref">248</a></sup></span>, or
mdBG <span class="citation"><sup><a href="#ref-ekimMinimizerspaceBruijnGraphs2021" role="doc-biblioref">94</a></sup></span>. HPC is also used for clustering
transcriptome reads according to gene family of
origin <span class="citation"><sup><a href="#ref-sahlinNovoClusteringLongRead2020" role="doc-biblioref">97</a></sup></span>. Overall, HPC has been widely used,
with demonstrated benefits.</p>
<p>Though our intuitive understanding justifies why HPC works, it in no way implies
that it is the best transformation that can be done. Are there transformations
that can be applied in the same pre-processing way as HPC that would achieve
better alignment sensitivity? In this work, we define a more general notion
which we call <em>mapping-friendly sequence reductions</em>. In order to efficiently
explore the performance of all reductions, we identify two heuristics to reduce
the search space of reductions. We then identify a number of mapping-friendly
sequence reductions which are likely to yield better mapping performance than
HPC. We evaluate them using two mappers (<code>minimap2</code> and <code>winnowmap2</code>) on three
simulated datasets (whole human genome, human centromere, and whole <em>Drosophila</em>
genome). We show that some of these functions provide vastly superior
performance in terms of correctly placing high mapping quality reads, compared
to either HPC or using raw reads. For example, one function increased the
mapping accuracy of <code>minimap2</code> by an order of magnitude over the entire human
genome, keeping an identical fraction of reads mapped.</p>
<p>We also evaluate whether HPC sensitivity gains continue to outweigh the
specificity cost with the advent of telomere-to-telomere
assemblies <span class="citation"><sup><a href="#ref-nurk2022" role="doc-biblioref">4</a></sup></span>. These contain many more
low-complexity and/or repeated regions such as centromeres and telomeres. HPC
may increase mapping ambiguity in these regions by removing small,
distinguishing, differences between repeat instances. Indeed, we find that
neither HPC nor our mapping-friendly sequence reductions perform better than
mapping raw reads on centromeres, hinting at the importance of preserving all
sequence information in repeated regions.</p>
</div>
<div id="hpc-methods" class="section level2 hasAnchor" number="3.2">
<h2><span class="header-section-number">3.2</span> Methods<a href="HPC-paper.html#hpc-methods" class="anchor-section" aria-label="Anchor link to header"></a></h2>
<div id="sec:msr-def" class="section level3 hasAnchor" number="3.2.1">
<h3><span class="header-section-number">3.2.1</span> Streaming sequence reductions<a href="HPC-paper.html#sec:msr-def" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<p>We wish to extend the notion of homopolymer compression to a more general
function while maintaining its simplicity. What makes HPC simple is that it can
be done in a streaming fashion over the sequence while maintaining only a local
context. The algorithm can be viewed simply as scanning a string from left to
right and, at each new character, outputting that character if and only if it is
different from the previous character. In order to prepare for generalizing this
algorithm, let us define a function
<span class="math inline">\(g^\text{HPC} : \Sigma^2\rightarrow\Sigma\cup\{\varepsilon\}\)</span> where <span class="math inline">\(\Sigma\)</span> is
the DNA alphabet, <span class="math inline">\(\varepsilon\)</span> is the empty character, and</p>
<p><span class="math display">\[\begin{align*}
    &amp; g^\text{HPC}(x_1\cdot x_2) =
    \begin{cases}
        x_2 &amp; \text{if } x_1 \neq x_2 \\
        \varepsilon &amp; \text{if } x_1 = x_2
    \end{cases}
\end{align*}\]</span></p>
<p>Now, we can view HPC as sliding a window of size 2 over the sequence and at each
new window, applying <span class="math inline">\(g^\text{HPC}\)</span> to the window and concatenating the output
to the growing compressed string. Formally, let <span class="math inline">\(x\)</span> be a string, which we index
starting from 1. Then, the HPC transformation is defined as</p>
<p><span class="math display" id="eq:MSR">\[\begin{equation}
  f(x) = x[1,\ell-1]\cdot g(x[1,\ell]) \cdot g(x[2, \ell+1])\cdots g(x[|x|-\ell+1,|x|])
  \tag{3.1}
\end{equation}\]</span></p>
<p>where <span class="math inline">\(\ell = 2\)</span> and <span class="math inline">\(g=g^\text{HPC}\)</span>. In other words, <span class="math inline">\(f\)</span> is the concatenation
of the first <span class="math inline">\(\ell-1\)</span> characters of <span class="math inline">\(x\)</span> and the sequence of outputs of <span class="math inline">\(g\)</span>
applied to a sliding window of length <span class="math inline">\(\ell\)</span> over <span class="math inline">\(x\)</span>. The core of the
transformation is given by <span class="math inline">\(g\)</span> and the size of the context <span class="math inline">\(\ell\)</span>, and <span class="math inline">\(f\)</span> is
simply the wrapper for <span class="math inline">\(g\)</span> so that the transformation can be applied to
arbitrary length strings.</p>
<p>With this view in mind, we can generalize HPC while keeping its simplicity by 1)
considering different functions <span class="math inline">\(g\)</span> that can be plugged into Equation
<a href="HPC-paper.html#eq:MSR">(3.1)</a> increasing the context that <span class="math inline">\(g\)</span> uses (i.e. setting <span class="math inline">\(\ell&gt;2\)</span>).
Formally, for a given alphabet <span class="math inline">\(\Sigma\)</span> and a context size <span class="math inline">\(\ell\)</span>, a function
<span class="math inline">\(T\)</span> mapping strings to strings is said to be an <em>order-</em><span class="math inline">\(\ell\)</span> Streaming
sequence reduction (abbreviated <em>SSR</em>) if there exists some
<span class="math inline">\(g : \Sigma^\ell\rightarrow\Sigma\cup\{\varepsilon\}\)</span> such that <span class="math inline">\(T=f\)</span>.</p>
<p>Figure <a href="HPC-paper.html#fig:countingMSRs">3.1</a>A shows how an SSR can be visualized as a directed
graph. Observe that an order-<span class="math inline">\(\ell\)</span> SSR is defined by a mapping between
<span class="math inline">\(|\Sigma|^\ell\)</span> inputs and <span class="math inline">\(|\Sigma| + 1\)</span> outputs. For example, for <span class="math inline">\(\ell=2\)</span>,
there are <span class="math inline">\(n=16\)</span> inputs and <span class="math inline">\(k=5\)</span> outputs. Figure <a href="HPC-paper.html#fig:countingMSRs">3.1</a>B
visualizes HPC in this way.</p>
<div class="figure" style="text-align: center"><span style="display:block;" id="fig:countingMSRs"></span>
<img src="figures/HPC-MSRs/panels_inline.png" alt="**Representing and counting mapping-friendly sequence reductions.**
**A**: General representation of an order-2 mapping-friendly sequence
reduction as a mapping of 16 input dinucleotides, to the 4 nucleotide
outputs and the empty character $\varepsilon$. **B**: Homopolymer
compression is an order-2 MSR. All dinucleotides except those that
contain the same nucleotide twice map to the second nucleotide of the
pair. The 4 dinucleotides that are the two same nucleotides map to the
empty character $\varepsilon$. **C**: Our RC-core-insensitive order-2
MSRs are mappings of the 6 representative dinucleotide inputs to the 4
nucleotide outputs and the empty character $\varepsilon$. The 4
dinucleotides that are their own reverse complement are always mapped to
$\varepsilon$. The remaining 6 dinucleotides are mapped to the
complement of the mapped output of the reverse complement dinucleotide
input. For example, if AA is mapped to C, then TT (the reverse
complement of AA) will be mapped to G (the complement of C). **D**:
Number of possible MSR mappings under the different restrictions
presented in the main text. All mappings from 16 dinucleotide inputs to
5 outputs (as in panel A) are represented by the outermost circle. All
RC-core-insensitive mappings (as in panel C) are represented by the
medium circle. All RC-core-insensitive mappings with only one
representative of each equivalence class are represented by the
innermost circle." width="90%" />
<p class="caption">
Figure 3.1: <strong>Representing and counting mapping-friendly sequence reductions.</strong>
<strong>A</strong>: General representation of an order-2 mapping-friendly sequence
reduction as a mapping of 16 input dinucleotides, to the 4 nucleotide
outputs and the empty character <span class="math inline">\(\varepsilon\)</span>. <strong>B</strong>: Homopolymer
compression is an order-2 MSR. All dinucleotides except those that
contain the same nucleotide twice map to the second nucleotide of the
pair. The 4 dinucleotides that are the two same nucleotides map to the
empty character <span class="math inline">\(\varepsilon\)</span>. <strong>C</strong>: Our RC-core-insensitive order-2
MSRs are mappings of the 6 representative dinucleotide inputs to the 4
nucleotide outputs and the empty character <span class="math inline">\(\varepsilon\)</span>. The 4
dinucleotides that are their own reverse complement are always mapped to
<span class="math inline">\(\varepsilon\)</span>. The remaining 6 dinucleotides are mapped to the
complement of the mapped output of the reverse complement dinucleotide
input. For example, if AA is mapped to C, then TT (the reverse
complement of AA) will be mapped to G (the complement of C). <strong>D</strong>:
Number of possible MSR mappings under the different restrictions
presented in the main text. All mappings from 16 dinucleotide inputs to
5 outputs (as in panel A) are represented by the outermost circle. All
RC-core-insensitive mappings (as in panel C) are represented by the
medium circle. All RC-core-insensitive mappings with only one
representative of each equivalence class are represented by the
innermost circle.
</p>
</div>
<p>Since we aim to use SSRs in the context of sequencing data, we need to place
additional restrictions on how they handle reverse complements. For example,
given two strings <span class="math inline">\(x\)</span> (e.g. a read) and <span class="math inline">\(y\)</span> (e.g. a substring of the reference),
a mapper might check if <span class="math inline">\(x = RC(y)\)</span>. When strings are pre-processed using an SSR
<span class="math inline">\(f\)</span>, it will end up checking if <span class="math inline">\(f(x) = RC(f(y))\)</span>. However, <span class="math inline">\(x = RC(y)\)</span> only
implies that <span class="math inline">\(f(x) = f(RC(y))\)</span>. In order to have it also imply that
<span class="math inline">\(f(x) = RC(f(y))\)</span>, we need <span class="math inline">\(f\)</span> to be commutative with RC, i.e. applying SSR then
RC needs to be equivalent to applying RC then SSR. We say that <span class="math inline">\(f\)</span> is
<em>RC-insensitive</em> if for all <span class="math inline">\(x\)</span>, <span class="math inline">\(f(RC(x))= RC(f(x))\)</span>. Observe that HPC is
RC-insensitive.</p>
</div>
<div id="sec:enum" class="section level3 hasAnchor" number="3.2.2">
<h3><span class="header-section-number">3.2.2</span> Restricting the space of Streaming sequence reductions<a href="HPC-paper.html#sec:enum" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<p>To discover SSRs that improve mapping performance, our strategy is to put them
all to the test by evaluating the results of an actual mapping software over a
simulated test dataset reduced by each SSR. However, even with only <span class="math inline">\(16\)</span> inputs
and <span class="math inline">\(5\)</span> outputs, the number of possible <span class="math inline">\(g\)</span> mappings for order-2 SSRs is
<span class="math inline">\(5^{16}\approx 1.5\cdot10^{11}\)</span>, which is prohibitive to enumerate. In this
section, we describe two ideas for reducing the space of SSRs that we will test.
In subsection <a href="HPC-paper.html#sec:rc-insensitive">3.2.2.1</a>, we show how the restriction to
RC-insensitive mappings can be used to reduce the search space. In
subsection <a href="HPC-paper.html#sec:equiv">3.2.2.2</a>, we exploit the natural symmetry that arises due to
Watson-Crick complements to further restrict the search space.</p>
<p>These restrictions reduce the number of order-2 SSRs to only , making it
feasible to test all of them. Figure <a href="HPC-paper.html#fig:countingMSRs">3.1</a>D shows an overview
of our restriction process.</p>
<div id="sec:rc-insensitive" class="section level4 hasAnchor" number="3.2.2.1">
<h4><span class="header-section-number">3.2.2.1</span> Reverse complement-core-insensitive Streaming sequence reductions<a href="HPC-paper.html#sec:rc-insensitive" class="anchor-section" aria-label="Anchor link to header"></a></h4>
<p>Consider an SSR defined by a function <span class="math inline">\(g\)</span>, as in Equation <a href="HPC-paper.html#eq:MSR">(3.1)</a>.
Throughout this paper we will consider SSRs that have a related but weaker
property than RC-insensitive. We say that an SSR is <em>RC-core-insensitive</em> if the
function <span class="math inline">\(g\)</span> that defines it has the property that for every <span class="math inline">\(\ell\)</span>-mer<span class="math inline">\(x\)</span> and
its reverse complement <span class="math inline">\(y\)</span>, we have that either <span class="math inline">\(g(x)\)</span> is the reverse complement
of <span class="math inline">\(g(y)\)</span> or <span class="math inline">\(g(x) = g(y) = \varepsilon\)</span>. We will restrict our SSR search space
to RC-core-insensitive reductions in order to reduce the number of SSRs we will
need to test.</p>
<p>Let us consider what this means for the case of <span class="math inline">\(\ell=2\)</span>, which will be the
focal point of our experimental analysis. There are 16 <span class="math inline">\(\ell\)</span>-mers(i.e.
dinucleotides) in total. Four of them are their own reverse complement: AT, TA,
GC, CG. The RC-core-insensitive restriction forces <span class="math inline">\(g\)</span> to map each of these to
<span class="math inline">\(\varepsilon\)</span>, since a single nucleotide output cannot be its own reverse
complement. This leaves 12 <span class="math inline">\(\ell\)</span>-mers, which can be broken down into 6 pairs of
reverse complements. For each pair, we can order them in lexicographical order
and write them as <span class="math inline">\((AA,TT), (AC,GT), (AG,CT), (CA,TG), (CC,GG),\)</span> and <span class="math inline">\((GA,TC)\)</span>.
Defining <span class="math inline">\(g\)</span> can then be done by assigning an output nucleotide to the first
<span class="math inline">\(\ell\)</span>-mer in each of these pairs (Figure <a href="HPC-paper.html#fig:countingMSRs">3.1</a>C). For
example, we can define an SSR by assigning <span class="math inline">\(g(AA) = C\)</span>, <span class="math inline">\(g(AC) = C\)</span>,
<span class="math inline">\(g(AG) = A\)</span>, <span class="math inline">\(g(CA) = A\)</span>, <span class="math inline">\(g(CC) = T\)</span>, and <span class="math inline">\(g(GA) = G\)</span>. As an example, let us
apply the corresponding SSR to an example read <span class="math inline">\(r\)</span>:</p>
<p><span class="math display">\[\begin{align*}
    r &amp; = \text{TAAGTTGA}    &amp; f(RC(r)) &amp;=\color{red}{\text{T}}\color{green}{\text{CACCTG}} \\
    f(r) &amp; =\text{TCAGGTG}   &amp; RC(f(r)) &amp;=\;\;\;\color{green}{\text{CACCTG}}\color{red}{\text{A}} \\
    RC(r) &amp; =\text{TCAACTTA} &amp; &amp;
\end{align*}\]</span></p>
<p>Observe that the first <span class="math inline">\(\ell-1\)</span> nucleotides of <span class="math inline">\(r\)</span> (shown in red) are copied
as-is, since we do not apply <span class="math inline">\(g\)</span> on them (as per Equation <a href="HPC-paper.html#eq:MSR">(3.1)</a>). As we
see in this example, this implies that <span class="math inline">\(f(RC(r))\)</span> is not necessarily equal to
<span class="math inline">\(RC(f(r))\)</span>; thus an RC-core-insensitive SSR is not necessarily an RC-insensitive
SSR. However, an RC-core-insensitive SSR has the property that for all strings
<span class="math inline">\(r\)</span>, we have <span class="math inline">\(f(RC(r))[\ell, |r|]) = RC(f(r))[1, |r| - \ell + 1]\)</span>. In other
words, if we drop the <span class="math inline">\(\ell - 1\)</span> prefix of <span class="math inline">\(f(RC(r))\)</span> and the <span class="math inline">\(\ell - 1\)</span> suffix
of <span class="math inline">\(RC(f(r))\)</span>, then the two strings are equal. Though we no longer have the
strict RC-insensitive property, this new property suffices for the purpose of
mapping long reads. Since the length of the read sequences will be much greater
than <span class="math inline">\(\ell\)</span> (in our results we will only use <span class="math inline">\(\ell=2\)</span>), having a mismatch in the
first or last nucleotide will be practically inconsequential.</p>
<p>It is important to note though that there may be other RC-insensitive functions
not generated by this construction. For instance, HPC cannot be derived using
this method (as it does not map the di-nucleotides AT,TA,GC and CG to
<span class="math inline">\(\varepsilon\)</span>), and yet it is RC-insensitive.</p>
<p>We can count the number of RC-core-insensitive SSRs. Let us define <span class="math inline">\(i(\ell)\)</span> the
number of input assignments necessary to fully determine the RC-core-insensitive
SSR; one can think of this as the degrees-of-freedom in choosing <span class="math inline">\(g\)</span>. As we
showed, for <span class="math inline">\(\ell=2\)</span>, we have <span class="math inline">\(i(\ell)=6\)</span>. The number of RC-core-insensitive
SSRs is then <span class="math inline">\(5^{i(\ell)}\)</span>. Therefore, for <span class="math inline">\(\ell=2\)</span>, instead of <span class="math inline">\(5^{16}\)</span>
possible mappings we have at most <span class="math inline">\(5^{6}\approx1.5\cdot10^{4}\)</span>
RC-core-insensitive mappings (Figure <a href="HPC-paper.html#fig:countingMSRs">3.1</a>D). For an odd
<span class="math inline">\(\ell&gt;2\)</span>, there are no <span class="math inline">\(\ell\)</span>-mers that are their own reverse complements, hence
<span class="math inline">\(i(\ell)=4^\ell/2\)</span>. If <span class="math inline">\(\ell\)</span> is even then there are <span class="math inline">\(4^{\ell/2}\)</span> inputs that
are their own reverse complements (i.e. we take all possible sequences of length
<span class="math inline">\(\ell/2\)</span> and reconstruct the other half with reverse complements). Thus,
<span class="math inline">\(i(\ell)=(4^\ell- 4^{\ell/2})/2\)</span>.</p>
</div>
<div id="sec:equiv" class="section level4 hasAnchor" number="3.2.2.2">
<h4><span class="header-section-number">3.2.2.2</span> Equivalence classes of SSRs<a href="HPC-paper.html#sec:equiv" class="anchor-section" aria-label="Anchor link to header"></a></h4>
<p>When performing preliminary tests, we noticed that swapping <span class="math inline">\(A\leftrightarrow T\)</span>
and/or <span class="math inline">\(C\leftrightarrow G\)</span>, as well as swapping the whole <span class="math inline">\(A/T\)</span> pair with the
<span class="math inline">\(C/G\)</span> pair in the SSR outputs did not affect the performance. In other words, we
could exchange the letters of the output in a way that preserves the
Watson-Crick complementary relation. Intuitively, this can be due to the
symmetry induced by reverse complements in nucleic acid strands, though we do
not have a more rigorous explanation for this effect. In this section, we will
formalize this observation by defining the notion of SSR equivalence. This will
reduce the space of SSRs that we will need to consider by allowing us to
evaluate only one SSR from each equivalence class.</p>
<p>Consider an RC-core-insensitive SSR defined by a function <span class="math inline">\(g\)</span>, as in Equation
<a href="HPC-paper.html#eq:MSR">(3.1)</a>. An <span class="math inline">\(\ell\)</span>-mer is canonical if it is the not lexicographically
larger than its reverse complement. Let <span class="math inline">\(I\)</span> be the set of all <span class="math inline">\(\ell\)</span>-mers that
are canonical and are not reverse complements of each other. Such an SSR’s
<em>dimension</em> <span class="math inline">\(k\)</span> is the number of distinct nucleotides that can be output by <span class="math inline">\(g\)</span>
on inputs from <span class="math inline">\(I\)</span> (not counting <span class="math inline">\(\varepsilon\)</span>). The dimension can range from
<span class="math inline">\(1\)</span> to <span class="math inline">\(4\)</span>. Next, observe that <span class="math inline">\(g\)</span> maps all elements of <span class="math inline">\(I\)</span> to one of <span class="math inline">\(k+ 1\)</span>
values (i.e. <span class="math inline">\(\Sigma \cup \varepsilon\)</span>). The output of <span class="math inline">\(g\)</span> on <span class="math inline">\(\ell\)</span>-mers not in
<span class="math inline">\(I\)</span> is determined by its output on <span class="math inline">\(\ell\)</span>-mers in <span class="math inline">\(I\)</span>, since we assume the SSR
is RC-core-insensitive. We can therefore view it as a partition of <span class="math inline">\(I\)</span> into
<span class="math inline">\(k+1\)</span> sets <span class="math inline">\(S_0\)</span>, …, <span class="math inline">\(S_k\)</span>, and then having a function <span class="math inline">\(t\)</span> that is an
injection from <span class="math inline">\(\{1, \ldots, k\}\)</span> to <span class="math inline">\(\Sigma\)</span> that assigns an output letter to
each partition. Further, we permanently assign the output letter for <span class="math inline">\(S_0\)</span> to be
<span class="math inline">\(\varepsilon\)</span>. Note that while <span class="math inline">\(S_0\)</span> could be empty, <span class="math inline">\(S_1, \ldots, S_k\)</span> cannot
be empty by definition of dimension. For example, the SSR used in Section
<a href="HPC-paper.html#sec:rc-insensitive">3.2.2.1</a> has dimension four and corresponds to the partition
<span class="math inline">\(S_0 = \{\},S_1=\{AG,CA\}\)</span>, <span class="math inline">\(S_2=\{CC\}\)</span>, <span class="math inline">\(S_3=\{AA,AC\}\)</span>, <span class="math inline">\(S_4=\{GA\}\)</span>, and to
the injection <span class="math inline">\(t(1) = A\)</span>, <span class="math inline">\(t(2) =T\)</span>, <span class="math inline">\(t(3) = C\)</span>, and <span class="math inline">\(t(4) = G\)</span>.</p>
<p>Let <span class="math inline">\(IsComp(x,y)\)</span> be a function that returns true if two nucleotides
<span class="math inline">\(x, y \in \Sigma \cup \{\varepsilon\}\)</span> are Watson-Crick complements, and false
otherwise. Consider two SSRs of dimension <span class="math inline">\(k\)</span> defined by <span class="math inline">\(S_0, \ldots, S_k, t\)</span>
and <span class="math inline">\(S&#39;_0, , S&#39;_k, t&#39;\)</span>, respectively. We say that they are equivalent iff all
the following conditions are met:</p>
<ul>
<li><p><span class="math inline">\(S_0 = S&#39;_0\)</span>,</p></li>
<li><p>there exists a permutation <span class="math inline">\(\pi\)</span> of <span class="math inline">\(\{1,\ldots, k\}\)</span> such that for all
<span class="math inline">\(1 \leq i \leq k\)</span>, we have <span class="math inline">\(S_i = S&#39;_{\pi(i)}\)</span>,</p></li>
<li><p>for all <span class="math inline">\(1 \leq i &lt; j \leq k\)</span>, we have
<span class="math inline">\(IsComp(t(i), t(j)) = IsComp(t&#39;(\pi(i)), t&#39;(\pi(j)))\)</span>.</p></li>
</ul>
<p>One can verify that this definition is indeed an equivalence relation, i.e. it
is reflexive, symmetric, and transitive. Therefore, we can partition the set of
all SSRs into equivalence classes based on this equivalence relation. One caveat
is that a single SSR defined by a function <span class="math inline">\(g\)</span> may correspond to multiple SSRs
of the form <span class="math inline">\(S_0,\ldots,S_k,t\)</span>. However, these multiple SSRs are equivalent,
hence the resulting equivalence classes are not affected. Furthermore, we can
assume that there is some rule to pick one representative SSR for its
equivalence class; the rule itself does not matter in our case.</p>
<p>Figure <a href="HPC-paper.html#fig:countingMSRs">3.1</a> shows the equivalence classes for <span class="math inline">\(\ell=2\)</span>, for a
fixed partition. An equivalence class can be defined by which pair of classes
<span class="math inline">\(S_i\)</span> and <span class="math inline">\(S_j\)</span> have complementary outputs under <span class="math inline">\(t\)</span> and <span class="math inline">\(t&#39;\)</span>. Let us define
<span class="math inline">\(o(k)\)</span> as the number of equivalence classes for a given partition and a given
<span class="math inline">\(k\)</span>. Then Figure <a href="HPC-paper.html#fig:countingMSRs">3.1</a> shows that <span class="math inline">\(o(1)=1\)</span>, <span class="math inline">\(o(2)=2\)</span> and
<span class="math inline">\(o(3) = o(4) = 3\)</span>. There are thus only 9 equivalence classes for a given
partition.</p>
<div class="figure" style="text-align: center"><span style="display:block;" id="fig:MSR-configs"></span>
<img src="figures/HPC-MSRs/equivalence_classes_simpler.png" alt="**MSR equivalence classes for a fixed partition of the inputs.**
$S_0$ is always assigned $\varepsilon$, so it is represented by a gray
node. A blue link between $S_i$ and an $S_j$ denotes that
$\textsc{IsComp}(t(i), t(j))=\text{true}$. The equivalence classes are
determined by the Watson-Crick complementary relationships between the
rest of the parts, i.e. by all the possible ways to draw the blue links." width="90%" />
<p class="caption">
Figure 3.2: <strong>MSR equivalence classes for a fixed partition of the inputs.</strong>
<span class="math inline">\(S_0\)</span> is always assigned <span class="math inline">\(\varepsilon\)</span>, so it is represented by a gray
node. A blue link between <span class="math inline">\(S_i\)</span> and an <span class="math inline">\(S_j\)</span> denotes that
<span class="math inline">\(IsComp(t(i), t(j))=\text{true}\)</span>. The equivalence classes are
determined by the Watson-Crick complementary relationships between the
rest of the parts, i.e. by all the possible ways to draw the blue links.
</p>
</div>
</div>
<div id="counting-the-number-of-restricted-ssrs" class="section level4 hasAnchor" number="3.2.2.3">
<h4><span class="header-section-number">3.2.2.3</span> Counting the number of restricted SSRs<a href="HPC-paper.html#counting-the-number-of-restricted-ssrs" class="anchor-section" aria-label="Anchor link to header"></a></h4>
<p>In this section, we derive a formula for the number of restricted MSRs,
i.e. MSRs that are RC-core-insensitive and that are representative for
their equivalence class. Consider the class of RC-core-insensitive MSRs
with dimension <span class="math inline">\(k\)</span>. In
subsection <a href="HPC-paper.html#sec:rc-insensitive">3.2.2.1</a>, we derived that the degrees-of-freedom
in assigning <span class="math inline">\(\ell\)</span>-mers to an output is <span class="math inline">\(i(\ell) = 4^\ell/2\)</span> if <span class="math inline">\(\ell\)</span>
is odd and <span class="math inline">\(i(\ell) = (4^\ell - 4^{\ell / 2})/2\)</span> if <span class="math inline">\(\ell\)</span> is even. Let
<span class="math inline">\(C(\ell,k)\)</span> be the number of ways that <span class="math inline">\(i(\ell)\)</span> <span class="math inline">\(\ell\)</span>-mers can be
partitioned into <span class="math inline">\(k+1\)</span> sets <span class="math inline">\(S_0, \ldots, S_k\)</span>, with <span class="math inline">\(S_1, \ldots, S_k\)</span>
required to be non-empty. Then, in
subsection <a href="HPC-paper.html#sec:equiv">3.2.2.2</a>, we have derived <span class="math inline">\(o(k)\)</span>, the number of MSR
equivalence classes for each such partition. The number of restricted
MSRs can then be written as</p>
<p><span class="math display" id="eq:N">\[\begin{equation}
N(\ell) = \sum_{k=1}^{4} C(\ell, k) \cdot o(k)
\tag{3.2}
\end{equation}\]</span></p>
<p>To derive the formula for <span class="math inline">\(C(\ell, k)\)</span>, we first recall that the number
of ways to partition <span class="math inline">\(n\)</span> elements into <span class="math inline">\(k\)</span> non-empty sets is known as
the Stirling number of the second kind and is denoted by
<span class="math inline">\(\tiny\bigg\{%
\begin{matrix}
    n \\
    k
\end{matrix}
\bigg\} \)</span><span class="citation"><sup><a href="#ref-grahamConcreteMathematicsFoundation1994" role="doc-biblioref">249</a></sup></span>. It can
be computed using the formula</p>
<p><span class="math display">\[\begin{equation*}
    \bigg\{%
\begin{matrix}
    n \\
    k
\end{matrix}
\bigg\}  = \frac{1}{k!}\sum_{i=0}^k(-1)^i\bigg(
\begin{matrix}
    k \\
    i
\end{matrix}
\bigg) (k-i)^n
\end{equation*}\]</span></p>
<p>Let <span class="math inline">\(j\)</span> be the number of the <span class="math inline">\(i(\ell)\)</span> <span class="math inline">\(\ell\)</span>-mers that are assigned to
<span class="math inline">\(S_0\)</span>. Note this does not include the <span class="math inline">\(\ell\)</span>-mers that are
self-complementary that are forced to be in <span class="math inline">\(S_0\)</span>. Let <span class="math inline">\(C(\ell,k,j)\)</span> be
the number of ways that <span class="math inline">\(i(\ell)\)</span> <span class="math inline">\(\ell\)</span>-mers can be partitioned into
<span class="math inline">\(k+1\)</span> sets <span class="math inline">\(S_0, \ldots, S_k\)</span>, such that <span class="math inline">\(j\)</span> of the <span class="math inline">\(\ell\)</span>-mers go into
<span class="math inline">\(|S_0|\)</span> and <span class="math inline">\(S_1, \ldots, S_k\)</span> to are non-empty. We need to consider
several cases depending on the value of <span class="math inline">\(j\)</span>:</p>
<ul>
<li><p>In the case that <span class="math inline">\(j = 0\)</span>, we are partitioning the <span class="math inline">\(i(\ell)\)</span> inputs
among non-empty sets <span class="math inline">\(S_1, \ldots, S_k\)</span>. Then
<span class="math inline">\(C(\ell, k,j) = \tiny{\bigg\{%
\begin{matrix}
    i(\ell) \\
    k
\end{matrix}
\bigg\} }\)</span>.</p></li>
<li><p>In the case that <span class="math inline">\(1 \leq j \leq i(\ell) - k\)</span>, there are
<span class="math inline">\(\tiny{\bigg(
\begin{matrix}
    i(\ell) \\
    j
\end{matrix}
\bigg) }\)</span> ways to choose which <span class="math inline">\(j\)</span> <span class="math inline">\(\ell\)</span>-mers are in <span class="math inline">\(S_0\)</span>, and
<span class="math inline">\(\tiny{\bigg\{%
\begin{matrix}
    i(\ell) - j \\
    k
\end{matrix}
\bigg\} }\)</span> ways to partition the remaining <span class="math inline">\(\ell\)</span>-mers into
<span class="math inline">\(S_1, \ldots, S_k\)</span>. Hence,
<span class="math inline">\(C(\ell, k,j) = \tiny{\bigg(
\begin{matrix}
    i(\ell) \\
    j
\end{matrix}
\bigg) }\tiny{\bigg\{%
\begin{matrix}
    i(\ell) - j \\
    k
\end{matrix}
\bigg\} }\)</span>.</p></li>
<li><p>In the case that <span class="math inline">\(j &gt; i(\ell) - k\)</span>, it is impossible to partition
the remaining <span class="math inline">\(k\)</span> (or fewer) <span class="math inline">\(\ell\)</span>-mers into <span class="math inline">\(S_1, \ldots, S_k\)</span>
such that the sets are non-empty. Recall that as we assume the
dimension is <span class="math inline">\(k\)</span>, each set must contain at least one element. Hence,
<span class="math inline">\(C(\ell, k,j) = 0\)</span>.</p></li>
</ul>
<p>Putting this together into Equation <a href="HPC-paper.html#eq:N">(3.2)</a>, we get</p>
<p><span class="math display">\[\begin{equation*}
    N(\ell) = \sum_{k=1}^4 o(k) \bigg( \bigg\{%
\begin{matrix}
    i(\ell) \\
    k
\end{matrix}
\bigg\}  + \sum_{j=1}^{i(\ell) - k}\bigg(
\begin{matrix}
    i(\ell) \\
    j
\end{matrix}
\bigg) \bigg\{%
\begin{matrix}
    i(\ell)-j \\
    k
\end{matrix}
\bigg\}   \bigg)
\end{equation*}\]</span></p>
<p>For <span class="math inline">\(\ell=2\)</span>, we have <span class="math inline">\(N(2)=2,135\)</span> restricted MSRs, which is
several orders of magnitude smaller than the initial <span class="math inline">\(5^{16}\)</span> possible
MSRs and allows us to test the performance of all of them. for order-3
MSRs we get <span class="math inline">\(N(3)=2.9\cdot10^{21}\)</span> which much smaller than the full
search space of <span class="math inline">\(5^{4^3}\approx5.4\cdot10^{44}\)</span>, for order-4 MSRs we get
a similar reduction in search space with <span class="math inline">\(N(4)=9.4\cdot10^{84}\)</span> as
opposed to the full search space of <span class="math inline">\(5^{4^4}\approx8.6\cdot10^{178}\)</span>.
For these higher order MSRs, although the restricted search space is
much smaller than the full naive one, it is still too large to
exhaustively search.</p>
</div>
</div>
</div>
<div id="datasets-and-pipelines" class="section level2 hasAnchor" number="3.3">
<h2><span class="header-section-number">3.3</span> Datasets and Pipelines<a href="HPC-paper.html#datasets-and-pipelines" class="anchor-section" aria-label="Anchor link to header"></a></h2>
<div id="datasets" class="section level3 hasAnchor" number="3.3.1">
<h3><span class="header-section-number">3.3.1</span> Datasets<a href="HPC-paper.html#datasets" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<p>The following three reference sequences were used for evaluation:</p>
<ol style="list-style-type: decimal">
<li><p><strong>Whole human genome:</strong> This reference sequence is a whole genome assembly
of the CHM13hTERT human cell line by the Telomere-to-Telomere consortium<span class="citation"><sup>@ <a href="#ref-nurk2022" role="doc-biblioref">4</a></sup></span>. We used the 1.1 assembly release (Genbank
Assembly ID
<a href="https://www.ncbi.nlm.nih.gov/assembly/GCA_009914755.3/">GCA_009914755.3</a>).</p></li>
<li><p><strong>Whole <em>Drosophila</em> genome:</strong> This reference sequence is a whole genome
assembly of a <em>Drosophila melanogaster</em>, release 6.35 (Genbank Assembly ID
<a href="https://www.ncbi.nlm.nih.gov/assembly/GCF_000001215.4/">GCA_000001215.4</a>)<span class="citation"><sup><a href="#ref-adamsGenomeSequenceDrosophila2000" role="doc-biblioref">250</a></sup></span>.</p></li>
<li><p><strong>Synthetic centromeric sequence:</strong> This sequence was obtained from the
<code>TandemTools</code> mapper test data<span class="citation"><sup><a href="#ref-mikheenkoTandemToolsMappingLong2020" role="doc-biblioref">245</a></sup></span>. It is
a simulated centromeric sequence that is inherently difficult to map reads
to. Appendix <a href="HPC-appendix.html#appendix:tandemtools">A.1</a> describes how it was constructed.</p></li>
</ol>
</div>
<div id="simulation-pipeline" class="section level3 hasAnchor" number="3.3.2">
<h3><span class="header-section-number">3.3.2</span> Simulation pipeline<a href="HPC-paper.html#simulation-pipeline" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<p>Given a reference sequence, simulated reads were obtained using <code>nanosim</code><span class="citation"><sup><a href="#ref-yangNanoSimNanoporeSequence2017" role="doc-biblioref">251</a></sup></span> with the
<code>human_NA12878_DNA_FAB49712_guppy_flipflop</code> pre-trained model, mimicking
sequencing with an Oxford Nanopore instrument. The number of simulated reads was
chosen to obtain a theoretical coverage of whole genomes around 1.5x, this
resulted in simulating <span class="math inline">\(\approx 6.6\cdot10^5\)</span> reads for the whole human genome
and <span class="math inline">\(\approx 2.6\cdot10^4\)</span> reads for the whole Drosophila genome. Since the
centromeric sequence is very short, we aimed for a theoretical coverage of 100x
which resulted in <span class="math inline">\(\approx 1.3\cdot10^4\)</span> simulated reads.</p>
<p>For each evaluated SSR, the reads as well as the reference sequence were reduced
by applying the SSR to them. The reduced reads were then mapped to the reduced
reference using <code>minimap2</code><span class="citation"><sup><a href="#ref-liMinimap2PairwiseAlignment2018" role="doc-biblioref">100</a></sup></span> with the <code>map-ont</code>
preset and the <code>-c</code> flag to generate precise alignments. Although HPC is an
option in <code>minimap2</code> we do not use it and we evaluate HPC as any of the other
SSRs by transforming the reference and reads prior to mapping. The starting
coordinates of the reduced reads on the reduced reference were updated to
reflect deletions incurred by the reduction process. The mapping results with
translated coordinates were filtered to keep only the primary alignments. This
process was done for each of our 2135 SSRs as well as with HPC and the original
untransformed reads (denoted as <em>raw</em>).</p>
</div>
<div id="sec:evalpipeline" class="section level3 hasAnchor" number="3.3.3">
<h3><span class="header-section-number">3.3.3</span> Evaluation pipeline<a href="HPC-paper.html#sec:evalpipeline" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<p>We use two metrics to evaluate the quality of a mapping of a simulated read set.
The first is the <em>fraction of reads mapped</em>, i.e. that have at least one
alignment. The second is the <em>error rate</em>, which is the fraction of mapped reads
that have an incorrect location as determined by <code>paftools mapeval</code><span class="citation"><sup><a href="#ref-liMinimap2PairwiseAlignment2018" role="doc-biblioref">100</a></sup></span>. This tool considers a read as correctly
mapped if the intersection between its true interval of origin, and the interval
where it has been mapped to, is at least 10% of the union of both intervals.</p>
<p>Furthermore, we measure the error rate as a function of a given <em>mapping quality
threshold</em>. Mapping quality (abbreviated mapq) is a metric reported by the
aligner that indicates its confidence in read placement; the highest value (60)
indicates that the mapping location is likely correct and unique with high
probability, and a low value (e.g. 0) indicates that the read has multiple
equally likely candidate mappings and that the reported location cannot be
trusted. The error rate at a mapq threshold <span class="math inline">\(t\)</span> is then defined as the error
rate of reads whose mapping quality is <span class="math inline">\(t\)</span> or above. For example, the error rate
at <span class="math inline">\(t=0\)</span> is the error rate of the whole read set, while the error rate at <span class="math inline">\(t=60\)</span>
is the error rate of only the most confident read mappings. Observe that the
error rate decreases as <span class="math inline">\(t\)</span> increases.</p>
</div>
</div>
<div id="hpc-results" class="section level2 hasAnchor" number="3.4">
<h2><span class="header-section-number">3.4</span> Results<a href="HPC-paper.html#hpc-results" class="anchor-section" aria-label="Anchor link to header"></a></h2>
<div id="selection-of-mapping-friendly-sequence-reductions" class="section level3 hasAnchor" number="3.4.1">
<h3><span class="header-section-number">3.4.1</span> Selection of mapping-friendly sequence reductions<a href="HPC-paper.html#selection-of-mapping-friendly-sequence-reductions" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<p>We selected a set of “promising” SSRs starting from all of the SSRs enumerated
in Section <a href="HPC-paper.html#sec:enum">3.2.2</a>, that we call <em>mapping-friendly sequence reductions</em>
(abbreviated <em>MSR</em>). The selection was performed by considering an independent
read set of lower (0.5x) coverage, simulated from the whole human genome
reference. This dataset is separate from the ones used for evaluation. Note that
overfitting MSRs to a particular genome is acceptable in applications where a
custom MSR can be used for each genome. Yet in this work, the same set of
selected MSRs will be used across all genomes.</p>
<div class="figure" style="text-align: center"><span style="display:block;" id="fig:threshold-choice"></span>
<img src="figures/HPC-MSRs/threshold_selection-v2.png" alt="**Illustration of how a respective mapq threshold is chosen for each
of our evaluated MSRs.**
The orange dot shows the error rate and
fraction of reads mapped for HPC at mapq threshold 60. Anything below
and to the right of this point is strictly better than HPC 60, i.e. it
has both a lower error rate and higher fraction of reads mapped. If an
evaluated MSR does not pass through this region, then it is discarded
from further consideration. In the figure, the blue MSR does pass
through this region, indicating that it is better than HPC 60. We
identify the leftmost point (marked as a blue dot) and use the mapq
threshold at that point as the respective threshold." width="90%" />
<p class="caption">
Figure 3.3: <strong>Illustration of how a respective mapq threshold is chosen for each
of our evaluated MSRs.</strong>
The orange dot shows the error rate and
fraction of reads mapped for HPC at mapq threshold 60. Anything below
and to the right of this point is strictly better than HPC 60, i.e. it
has both a lower error rate and higher fraction of reads mapped. If an
evaluated MSR does not pass through this region, then it is discarded
from further consideration. In the figure, the blue MSR does pass
through this region, indicating that it is better than HPC 60. We
identify the leftmost point (marked as a blue dot) and use the mapq
threshold at that point as the respective threshold.
</p>
</div>
<p>For each evaluated SSR, we selected, if it exists, the highest mapq threshold
for which the mapped read fraction is higher and the error rate is lower than
HPC at mapq 60 (<span class="math inline">\(0.93\)</span> and <span class="math inline">\(2.1\cdot 10^{-3}\)</span> respectively). Figure
<a href="HPC-paper.html#fig:threshold-choice">3.3</a> illustrates the idea. Then we identified the 20 SSRs
that have the highest fraction of reads mapped at their respective thresholds.
Similarly we identified the 20 SSRs with the lowest error rate. Finally we
select the 20 SSRs that have the higest percentage of thresholds “better” than
HPC at mapq 60; i.e. the number of mapq thresholds for which the SSR has both a
higher fraction of reads mapped and lower error rate than HPC at a mapq
threshold of 60, divided by the total number of thresholds (=60).</p>
<p>The union of these 3 sets of 20 SSRs resulted in a set of 58 “promising” MSRs.
Furthermore, we will highlight three MSRs that are “best in their category”,
i.e.</p>
<ul>
<li><p><strong>MSR</strong><span class="math inline">\(_{\text{F}}\)</span>: The MSR with the highest fraction of mapped reads at a
mapq threshold of 0.</p></li>
<li><p><strong>MSR</strong><span class="math inline">\(_{\text{E}}\)</span>: The MSR with the lowest error rate at its respective
mapq threshold.</p></li>
<li><p><strong>MSR</strong><span class="math inline">\(_{\text{P}}\)</span>: The MSR with the highest percentage of mapq thresholds
for which it is “better” than HPC at mapq 60.</p></li>
</ul>
<p>Figure <a href="HPC-paper.html#fig:topMSRs">3.4</a> shows the actual functions MSR<span class="math inline">\(_{\text{F}}\)</span>,
MSR<span class="math inline">\(_{\text{E}}\)</span>, MSR<span class="math inline">\(_{\text{P}}\)</span>. An intriguing property is that they output
predominantly As and Ts, with MSR<span class="math inline">\(_{\text{P}}\)</span> assigning 2 input pairs to the
G/C output whereas MSR<span class="math inline">\(_{\text{E}}\)</span> and MSR<span class="math inline">\(_{\text{F}}\)</span> assign only one.
Additionally, MSR<span class="math inline">\(_{\text{E}}\)</span> and MSR<span class="math inline">\(_{\text{P}}\)</span> both assign the {CC,GG}
input pair to the deletion output <span class="math inline">\(\varepsilon\)</span> removing any information
corresponding to repetitions of either G or C from the reduced sequence. Overall
this means the reduced sequences are much more AT-rich than their raw
counterparts, but somehow information pertinent to mapping is retained.</p>
<div class="figure" style="text-align: center"><span style="display:block;" id="fig:topMSRs"></span>
<img src="figures/HPC-MSRs/Top_MSRs.png" alt="**Graph representations of our highlighted MSRs: MSR$_{\text{E}}$,
MSR$_{\text{F}}$, and MSR$_{\text{P}}$.**
MSR$_{\text{E}}$ has the lowest error rate of among MSRs at the highest
mapq threshold for which it performs better than HPC at mapq 60,
MSR$_{\text{F}}$ has the highest fraction of reads mapped at mapq 60 and
MSR$_{\text{P}}$ has the highest percentage of mapq thresholds for which
it outperforms HPC at mapq 60. The grayed out nodes represent the
reverse complement of input dinucleotides and outputs, as in
Figure \@ref(fig:countingMSRs)C. For example for MSR$_{\text{E}}$, AA is
mapped to T, so TT is mapped to
A." width="90%" />
<p class="caption">
Figure 3.4: <strong>Graph representations of our highlighted MSRs: MSR<span class="math inline">\(_{\text{E}}\)</span>,
MSR<span class="math inline">\(_{\text{F}}\)</span>, and MSR<span class="math inline">\(_{\text{P}}\)</span>.</strong>
MSR<span class="math inline">\(_{\text{E}}\)</span> has the lowest error rate of among MSRs at the highest
mapq threshold for which it performs better than HPC at mapq 60,
MSR<span class="math inline">\(_{\text{F}}\)</span> has the highest fraction of reads mapped at mapq 60 and
MSR<span class="math inline">\(_{\text{P}}\)</span> has the highest percentage of mapq thresholds for which
it outperforms HPC at mapq 60. The grayed out nodes represent the
reverse complement of input dinucleotides and outputs, as in
Figure <a href="HPC-paper.html#fig:countingMSRs">3.1</a>C. For example for MSR<span class="math inline">\(_{\text{E}}\)</span>, AA is
mapped to T, so TT is mapped to
A.
</p>
</div>
</div>
<div id="mapping-friendly-sequence-reductions-lead-to-lower-mapping-errors-on-whole-genomes" class="section level3 hasAnchor" number="3.4.2">
<h3><span class="header-section-number">3.4.2</span> Mapping-friendly sequence reductions lead to lower mapping errors on whole genomes<a href="HPC-paper.html#mapping-friendly-sequence-reductions-lead-to-lower-mapping-errors-on-whole-genomes" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<p>Across the entire human genome, at high mapping quality thresholds (above 50),
our selected 58 MSRs generally have lower mapping error rate than HPC and raw
Figure <a href="HPC-paper.html#fig:mapeval">3.5</a>A and Table <a href="HPC-paper.html#tab:table-subset">3.1</a>. This is not
surprising, as we selected those MSRs partly on the criteria of outperforming
HPC at mapq 60; however, it does demonstrate that we did not overfit to the
simulated reads used to select the MSRs.</p>
<div class="figure" style="text-align: center"><span style="display:block;" id="fig:mapeval"></span>
<img src="figures/HPC-MSRs/MSR_mapeval_new_selection.reordered.png" alt=" **Performance of our 58 selected mapping-friendly sequence reductions
across genomes on reads simulated by `nanosim`**
Panel **A)** shows the whole human genome assembly, **B)** the subset of
mapped reads from panel B that originate from repetitive regions, and
**C)** the &quot;TandemTools&quot; synthetic centromeric reference sequence. We
highlighted the best-performing mapping-friendly sequence reductions as
MSR E, F and P, respectively in terms of cumulative `mapeval` error
rate, fraction of reads mapped, and percentage of better thresholds than
HPC. Each point on a line represents, from left to right, the mapping
quality thresholds 60, 50, 40, 30, 20, 10 and 0. For the first point of
each line, only reads of mapping quality 60 are considered, and the y
value represents the rate of these reads that are not correctly mapped,
the x value represents the fraction of simulated reads that are mapped
at this threshold. The next point is computed for all reads of mapping
quality $\geq50$, etc. The rightmost point on any curve represents the
mapping error rate and the fraction of mapped reads for all primary
alignments. The x-axes are clipped for lower mapped read fractions to
better differentiate HPC, raw and MSRs E, F and P." width="90%" />
<p class="caption">
Figure 3.5:  <strong>Performance of our 58 selected mapping-friendly sequence reductions
across genomes on reads simulated by <code>nanosim</code></strong>
Panel <strong>A)</strong> shows the whole human genome assembly, <strong>B)</strong> the subset of
mapped reads from panel B that originate from repetitive regions, and
<strong>C)</strong> the “TandemTools” synthetic centromeric reference sequence. We
highlighted the best-performing mapping-friendly sequence reductions as
MSR E, F and P, respectively in terms of cumulative <code>mapeval</code> error
rate, fraction of reads mapped, and percentage of better thresholds than
HPC. Each point on a line represents, from left to right, the mapping
quality thresholds 60, 50, 40, 30, 20, 10 and 0. For the first point of
each line, only reads of mapping quality 60 are considered, and the y
value represents the rate of these reads that are not correctly mapped,
the x value represents the fraction of simulated reads that are mapped
at this threshold. The next point is computed for all reads of mapping
quality <span class="math inline">\(\geq50\)</span>, etc. The rightmost point on any curve represents the
mapping error rate and the fraction of mapped reads for all primary
alignments. The x-axes are clipped for lower mapped read fractions to
better differentiate HPC, raw and MSRs E, F and P.
</p>
</div>
<p>Mapping quality is only an indication from the aligner to estimate whether a
read mapping is correct, and according to Figure <a href="HPC-paper.html#fig:mapeval">3.5</a>A the mapping
error rate of most MSRs is low even for mapping qualities lower than 60.
Therefore, we choose to compare MSR-mapped reads with lower mapping qualities
against raw or HPC-mapped reads with the highest (60) mapping quality (which is
the mapping quality thresholds most practitioners would use by default).</p>
<p>Table <a href="HPC-paper.html#tab:table-subset">3.1</a> shows that the three selected MSRs outperform both
HPC and raw in terms of mapping error rate, with similar fractions of mapped
reads overall. For example on the human genome, at mapq<span class="math inline">\(\geq50\)</span>,
MSR<span class="math inline">\(_{\text{F}}\)</span>, MSR<span class="math inline">\(_{\text{P}}\)</span> and MSR<span class="math inline">\(_{\text{E}}\)</span> all map more reads than
either HPC or raw at mapq=60, and MSR<span class="math inline">\(_{\text{P}}\)</span> and MSR<span class="math inline">\(_{\text{E}}\)</span> also
have error rates an order of magnitude lower than either HPC or raw.</p>
<p>To evaluate the robustness of MSRs E, F and P we investigated the impact of
mapping to a different organism or using another mapper. To this effect we
repeated the evaluation pipeline in these different settings:</p>
<ul>
<li><p>Using the <em>Drosophila melanogaster</em> whole genome assembly as reference and
mapping with <code>minimap2</code></p></li>
<li><p>Using the whole human genome assembly as reference but mapping with
<code>winnowmap2</code>(version 2.02)<span class="citation"><sup><a href="#ref-jainWeightedMinimizerSampling2020" role="doc-biblioref">101</a></sup></span>. The same
options as <code>minimap2</code> were used, and k-mers were counted using <code>meryl</code><span class="citation"><sup><a href="#ref-rhieMerquryReferencefreeQuality2020" role="doc-biblioref">252</a></sup></span>, considering the top <span class="math inline">\(0.02\%\)</span> as
repetitive (as suggested by the <code>winnowmap2</code> usage guide).</p></li>
</ul>
<p>MSRs E, F and P behave very similarly in both of these contexts compared to
HPC/raw: by selecting mapped reads with mapq<span class="math inline">\(\geq\)</span> 50 for the three MSRs we
obtain a similar fraction of mapped reads with much lower error rates (Table
<a href="HPC-paper.html#tab:table-subset">3.1</a>). A noticeable exception is the <code>winnowmap2</code> experiment,
where a larger fraction of raw reads are mapped than any other MSR and even HPC.
A more detailed results table can be found in Table <a href="HPC-appendix.html#tab:mapperComparison">A.1</a>,
and a graph of MSR performance on the whole Drosophila genome in Figure
<a href="HPC-appendix.html#fig:drosophila-results">A.7</a>. As Figure <a href="HPC-appendix.html#fig:drosophila-results">A.7</a> shows, we
also evaluated these MSRs on a whole <em>Escherichia coli</em> (Genbank ID
<a href="https://www.ncbi.nlm.nih.gov/nuccore/U00096.2">U00096.2</a>) genome, where we
observed similar results, albeit the best MSRs do not seem to be one of our
three candidates. This might mean that specific MSRs are more suited to
particular types of genomes.</p>
<template id="b5a27c35-c227-406c-83a6-f526729af96d"><style>
.tabwid table{
  border-spacing:0px !important;
  border-collapse:collapse;
  line-height:1;
  margin-left:auto;
  margin-right:auto;
  border-width: 0;
  display: table;
  margin-top: 1.275em;
  margin-bottom: 1.275em;
  border-color: transparent;
}
.tabwid_left table{
  margin-left:0;
}
.tabwid_right table{
  margin-right:0;
}
.tabwid td {
    padding: 0;
}
.tabwid a {
  text-decoration: none;
}
.tabwid thead {
    background-color: transparent;
}
.tabwid tfoot {
    background-color: transparent;
}
.tabwid table tr {
background-color: transparent;
}
</style><div class="tabwid"><style>.cl-e166d386{table-layout:auto;width:100%;}.cl-e15e8f0a{font-family:'Helvetica';font-size:11pt;font-weight:normal;font-style:normal;text-decoration:none;color:rgba(0, 0, 0, 1.00);background-color:transparent;}.cl-e15e8f3c{font-family:'Helvetica';font-size:6.6pt;font-weight:normal;font-style:normal;text-decoration:none;color:rgba(0, 0, 0, 1.00);background-color:transparent;position: relative;top:3.3pt;}.cl-e15e8f46{font-family:'Helvetica';font-size:11pt;font-weight:bold;font-style:normal;text-decoration:none;color:rgba(0, 0, 0, 1.00);background-color:transparent;}.cl-e15eab16{margin:0;text-align:left;border-bottom: 0 solid rgba(0, 0, 0, 1.00);border-top: 0 solid rgba(0, 0, 0, 1.00);border-left: 0 solid rgba(0, 0, 0, 1.00);border-right: 0 solid rgba(0, 0, 0, 1.00);padding-bottom:5pt;padding-top:5pt;padding-left:5pt;padding-right:5pt;line-height: 1;background-color:transparent;}.cl-e15eab20{margin:0;text-align:right;border-bottom: 0 solid rgba(0, 0, 0, 1.00);border-top: 0 solid rgba(0, 0, 0, 1.00);border-left: 0 solid rgba(0, 0, 0, 1.00);border-right: 0 solid rgba(0, 0, 0, 1.00);padding-bottom:5pt;padding-top:5pt;padding-left:5pt;padding-right:5pt;line-height: 1;background-color:transparent;}.cl-e15ee388{background-color:transparent;vertical-align: middle;border-bottom: 0 solid rgba(0, 0, 0, 1.00);border-top: 0 solid rgba(0, 0, 0, 1.00);border-left: 0 solid rgba(0, 0, 0, 1.00);border-right: 0 solid rgba(0, 0, 0, 1.00);margin-bottom:0;margin-top:0;margin-left:0;margin-right:0;}.cl-e15ee392{background-color:transparent;vertical-align: middle;border-bottom: 0 solid rgba(0, 0, 0, 1.00);border-top: 0 solid rgba(0, 0, 0, 1.00);border-left: 0 solid rgba(0, 0, 0, 1.00);border-right: 0 solid rgba(0, 0, 0, 1.00);margin-bottom:0;margin-top:0;margin-left:0;margin-right:0;}.cl-e15ee393{background-color:transparent;vertical-align: middle;border-bottom: 2pt solid rgba(102, 102, 102, 1.00);border-top: 0 solid rgba(0, 0, 0, 1.00);border-left: 0 solid rgba(0, 0, 0, 1.00);border-right: 0 solid rgba(0, 0, 0, 1.00);margin-bottom:0;margin-top:0;margin-left:0;margin-right:0;}.cl-e15ee39c{background-color:transparent;vertical-align: middle;border-bottom: 2pt solid rgba(102, 102, 102, 1.00);border-top: 0 solid rgba(0, 0, 0, 1.00);border-left: 0 solid rgba(0, 0, 0, 1.00);border-right: 0 solid rgba(0, 0, 0, 1.00);margin-bottom:0;margin-top:0;margin-left:0;margin-right:0;}.cl-e15ee39d{background-color:transparent;vertical-align: middle;border-bottom: 2pt solid rgba(102, 102, 102, 1.00);border-top: 2pt solid rgba(102, 102, 102, 1.00);border-left: 0 solid rgba(0, 0, 0, 1.00);border-right: 0 solid rgba(0, 0, 0, 1.00);margin-bottom:0;margin-top:0;margin-left:0;margin-right:0;}.cl-e15ee39e{background-color:transparent;vertical-align: middle;border-bottom: 1pt solid rgba(102, 102, 102, 1.00);border-top: 2pt solid rgba(102, 102, 102, 1.00);border-left: 0 solid rgba(0, 0, 0, 1.00);border-right: 0 solid rgba(0, 0, 0, 1.00);margin-bottom:0;margin-top:0;margin-left:0;margin-right:0;}.cl-e15ee3a6{background-color:transparent;vertical-align: middle;border-bottom: 2pt solid rgba(102, 102, 102, 1.00);border-top: 2pt solid rgba(102, 102, 102, 1.00);border-left: 0 solid rgba(0, 0, 0, 1.00);border-right: 0 solid rgba(0, 0, 0, 1.00);margin-bottom:0;margin-top:0;margin-left:0;margin-right:0;}.cl-e15ee3a7{background-color:transparent;vertical-align: middle;border-bottom: 2pt solid rgba(102, 102, 102, 1.00);border-top: 1pt solid rgba(102, 102, 102, 1.00);border-left: 0 solid rgba(0, 0, 0, 1.00);border-right: 0 solid rgba(0, 0, 0, 1.00);margin-bottom:0;margin-top:0;margin-left:0;margin-right:0;}.cl-e15ee3a8{background-color:transparent;vertical-align: middle;border-bottom: 2pt solid rgba(102, 102, 102, 1.00);border-top: 1pt solid rgba(102, 102, 102, 1.00);border-left: 0 solid rgba(0, 0, 0, 1.00);border-right: 0 solid rgba(0, 0, 0, 1.00);margin-bottom:0;margin-top:0;margin-left:0;margin-right:0;}</style><table class='cl-e166d386'><thead><tr style="overflow-wrap:break-word;"><td  rowspan="2"class="cl-e15ee39d"><p class="cl-e15eab16"><span class="cl-e15e8f0a">label</span></p></td><td  rowspan="2"class="cl-e15ee3a6"><p class="cl-e15eab20"><span class="cl-e15e8f0a">mapq</span></p></td><td  colspan="2"class="cl-e15ee39e"><p class="cl-e15eab16"><span class="cl-e15e8f0a">Whole human genome (minimap2)</span></p></td><td  colspan="2"class="cl-e15ee39e"><p class="cl-e15eab16"><span class="cl-e15e8f0a">Whole human genome (winnowmap2)</span></p></td><td  colspan="2"class="cl-e15ee39e"><p class="cl-e15eab16"><span class="cl-e15e8f0a">Whole Drosophila genome (minimap2)</span></p></td></tr><tr style="overflow-wrap:break-word;"><td class="cl-e15ee3a7"><p class="cl-e15eab16"><span class="cl-e15e8f0a">fraction</span></p></td><td class="cl-e15ee3a7"><p class="cl-e15eab16"><span class="cl-e15e8f0a">error</span></p></td><td class="cl-e15ee3a7"><p class="cl-e15eab16"><span class="cl-e15e8f0a">fraction</span></p></td><td class="cl-e15ee3a7"><p class="cl-e15eab16"><span class="cl-e15e8f0a">error</span></p></td><td class="cl-e15ee3a7"><p class="cl-e15eab16"><span class="cl-e15e8f0a">fraction</span></p></td><td class="cl-e15ee3a7"><p class="cl-e15eab16"><span class="cl-e15e8f0a">error</span></p></td></tr></thead><tbody><tr style="overflow-wrap:break-word;"><td class="cl-e15ee388"><p class="cl-e15eab16"><span class="cl-e15e8f0a">HPC</span></p></td><td class="cl-e15ee392"><p class="cl-e15eab20"><span class="cl-e15e8f0a">60</span></p></td><td class="cl-e15ee388"><p class="cl-e15eab16"><span class="cl-e15e8f0a">0.935</span><span class="cl-e15e8f0a"> </span><span class="cl-e15e8f0a">+0%</span></p></td><td class="cl-e15ee388"><p class="cl-e15eab16"><span class="cl-e15e8f0a">1.85e-03</span><span class="cl-e15e8f0a"> </span><span class="cl-e15e8f0a">+0%</span></p></td><td class="cl-e15ee388"><p class="cl-e15eab16"><span class="cl-e15e8f0a">0.894</span><span class="cl-e15e8f0a"> </span><span class="cl-e15e8f0a">+0%</span></p></td><td class="cl-e15ee388"><p class="cl-e15eab16"><span class="cl-e15e8f0a">1.43e-03</span><span class="cl-e15e8f0a"> </span><span class="cl-e15e8f0a">+0%</span></p></td><td class="cl-e15ee388"><p class="cl-e15eab16"><span class="cl-e15e8f0a">0.957</span><span class="cl-e15e8f0a"> </span><span class="cl-e15e8f0a">+0%</span></p></td><td class="cl-e15ee388"><p class="cl-e15eab16"><span class="cl-e15e8f0a">2.27e-03</span><span class="cl-e15e8f0a"> </span><span class="cl-e15e8f0a">+0%</span></p></td></tr><tr style="overflow-wrap:break-word;"><td class="cl-e15ee388"><p class="cl-e15eab16"><span class="cl-e15e8f0a">raw</span></p></td><td class="cl-e15ee392"><p class="cl-e15eab20"><span class="cl-e15e8f0a">60</span></p></td><td class="cl-e15ee388"><p class="cl-e15eab16"><span class="cl-e15e8f0a">0.921</span><span class="cl-e15e8f0a"> </span><span class="cl-e15e8f0a">-1%</span></p></td><td class="cl-e15ee388"><p class="cl-e15eab16"><span class="cl-e15e8f0a">1.86e-03</span><span class="cl-e15e8f0a"> </span><span class="cl-e15e8f0a">+0%</span></p></td><td class="cl-e15ee388"><p class="cl-e15eab16"><span class="cl-e15e8f46">0.932</span><span class="cl-e15e8f46"> </span><span class="cl-e15e8f46">+4%</span></p></td><td class="cl-e15ee388"><p class="cl-e15eab16"><span class="cl-e15e8f0a">1.75e-03</span><span class="cl-e15e8f0a"> </span><span class="cl-e15e8f0a">+23%</span></p></td><td class="cl-e15ee388"><p class="cl-e15eab16"><span class="cl-e15e8f0a">0.958</span><span class="cl-e15e8f0a"> </span><span class="cl-e15e8f0a">+0%</span></p></td><td class="cl-e15ee388"><p class="cl-e15eab16"><span class="cl-e15e8f0a">2.27e-03</span><span class="cl-e15e8f0a"> </span><span class="cl-e15e8f0a">-0%</span></p></td></tr><tr style="overflow-wrap:break-word;"><td class="cl-e15ee388"><p class="cl-e15eab16"><span class="cl-e15e8f0a">MSR</span><span class="cl-e15e8f3c">F</span></p></td><td class="cl-e15ee392"><p class="cl-e15eab20"><span class="cl-e15e8f0a">50</span></p></td><td class="cl-e15ee388"><p class="cl-e15eab16"><span class="cl-e15e8f46">0.938</span><span class="cl-e15e8f46"> </span><span class="cl-e15e8f46">+0%</span></p></td><td class="cl-e15ee388"><p class="cl-e15eab16"><span class="cl-e15e8f0a">1.29e-03</span><span class="cl-e15e8f0a"> </span><span class="cl-e15e8f0a">-30%</span></p></td><td class="cl-e15ee388"><p class="cl-e15eab16"><span class="cl-e15e8f0a">0.886</span><span class="cl-e15e8f0a"> </span><span class="cl-e15e8f0a">-1%</span></p></td><td class="cl-e15ee388"><p class="cl-e15eab16"><span class="cl-e15e8f0a">3.82e-04</span><span class="cl-e15e8f0a"> </span><span class="cl-e15e8f0a">-73%</span></p></td><td class="cl-e15ee388"><p class="cl-e15eab16"><span class="cl-e15e8f46">0.960</span><span class="cl-e15e8f46"> </span><span class="cl-e15e8f46">+0%</span></p></td><td class="cl-e15ee388"><p class="cl-e15eab16"><span class="cl-e15e8f0a">1.37e-03</span><span class="cl-e15e8f0a"> </span><span class="cl-e15e8f0a">-39%</span></p></td></tr><tr style="overflow-wrap:break-word;"><td class="cl-e15ee388"><p class="cl-e15eab16"><span class="cl-e15e8f0a">MSR</span><span class="cl-e15e8f3c">E</span></p></td><td class="cl-e15ee392"><p class="cl-e15eab20"><span class="cl-e15e8f0a">50</span></p></td><td class="cl-e15ee388"><p class="cl-e15eab16"><span class="cl-e15e8f0a">0.936</span><span class="cl-e15e8f0a"> </span><span class="cl-e15e8f0a">+0%</span></p></td><td class="cl-e15ee388"><p class="cl-e15eab16"><span class="cl-e15e8f46">1.17e-04</span><span class="cl-e15e8f46"> </span><span class="cl-e15e8f46">-94%</span></p></td><td class="cl-e15ee388"><p class="cl-e15eab16"><span class="cl-e15e8f0a">0.820</span><span class="cl-e15e8f0a"> </span><span class="cl-e15e8f0a">-8%</span></p></td><td class="cl-e15ee388"><p class="cl-e15eab16"><span class="cl-e15e8f46">8.93e-05</span><span class="cl-e15e8f46"> </span><span class="cl-e15e8f46">-94%</span></p></td><td class="cl-e15ee388"><p class="cl-e15eab16"><span class="cl-e15e8f0a">0.954</span><span class="cl-e15e8f0a"> </span><span class="cl-e15e8f0a">-0%</span></p></td><td class="cl-e15ee388"><p class="cl-e15eab16"><span class="cl-e15e8f46">0</span><span class="cl-e15e8f46"> </span><span class="cl-e15e8f46">-100%</span></p></td></tr><tr style="overflow-wrap:break-word;"><td class="cl-e15ee393"><p class="cl-e15eab16"><span class="cl-e15e8f0a">MSR</span><span class="cl-e15e8f3c">P</span></p></td><td class="cl-e15ee39c"><p class="cl-e15eab20"><span class="cl-e15e8f0a">50</span></p></td><td class="cl-e15ee393"><p class="cl-e15eab16"><span class="cl-e15e8f46">0.938</span><span class="cl-e15e8f46"> </span><span class="cl-e15e8f46">0%</span></p></td><td class="cl-e15ee393"><p class="cl-e15eab16"><span class="cl-e15e8f0a">4.15e-04</span><span class="cl-e15e8f0a"> </span><span class="cl-e15e8f0a">-78%</span></p></td><td class="cl-e15ee393"><p class="cl-e15eab16"><span class="cl-e15e8f0a">0.845</span><span class="cl-e15e8f0a"> </span><span class="cl-e15e8f0a">-6%</span></p></td><td class="cl-e15ee393"><p class="cl-e15eab16"><span class="cl-e15e8f0a">1.14e-04</span><span class="cl-e15e8f0a"> </span><span class="cl-e15e8f0a">-92%</span></p></td><td class="cl-e15ee393"><p class="cl-e15eab16"><span class="cl-e15e8f0a">0.957</span><span class="cl-e15e8f0a"> </span><span class="cl-e15e8f0a">+0%</span></p></td><td class="cl-e15ee393"><p class="cl-e15eab16"><span class="cl-e15e8f0a">8.11e-04</span><span class="cl-e15e8f0a"> </span><span class="cl-e15e8f0a">-64%</span></p></td></tr></tbody>
<caption class="caption">
<p><span id="tab:table-subset">Table 3.1: </span><strong>Performance of MSRs, HPC, and raw mappings across different mappers and reference sequences.</strong>
For each reference sequence and mapper pair, we report the fraction of reads mapped (“fraction” columns), the <code>paftools mapeval</code> mapping error rate (“error” columns). The percentage differences are computed w.r.t to the respective HPC value. For HPC and the raw these metrics were obtained for alignments of mapping quality of 60. For MSRs E, F and P these metrics were obtained for alignments of mapping quality <span class="math inline">\(\geq 50\)</span>.</p>
</caption>
</table></div></template>
<div class="flextable-shadow-host" id="bcb26c98-4431-41c7-a15f-51b44b83e2e1"></div>
<script>
var dest = document.getElementById("bcb26c98-4431-41c7-a15f-51b44b83e2e1");
var template = document.getElementById("b5a27c35-c227-406c-83a6-f526729af96d");
var caption = template.content.querySelector("caption");
if(caption) {
  caption.style.cssText = "display:block;text-align:center;";
  var newcapt = document.createElement("p");
  newcapt.appendChild(caption)
  dest.parentNode.insertBefore(newcapt, dest.nextSibling);
}
var fantome = dest.attachShadow({mode: 'open'});
var templateContent = template.content;
fantome.appendChild(templateContent);
</script>

</div>
<div id="mapping-friendly-sequence-reductions-increase-mapping-quality-on-repeated-regions-of-the-human-genome" class="section level3 hasAnchor" number="3.4.3">
<h3><span class="header-section-number">3.4.3</span> Mapping-friendly sequence reductions increase mapping quality on repeated regions of the human genome<a href="HPC-paper.html#mapping-friendly-sequence-reductions-increase-mapping-quality-on-repeated-regions-of-the-human-genome" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<p>To evaluate the performance of our MSRs specifically on repeats, we extracted
the simulated reads for which an overlap with repeated region of the whole human
genome was greater than <span class="math inline">\(50\%\)</span> of the read length. We then evaluated the MSRs on
these reads only. Repeated regions were obtained from
<a href="https://t2t.gi.ucsc.edu/chm13/hub/t2t-chm13-v1.1/rmsk/rmsk.bigBed" class="uri">https://t2t.gi.ucsc.edu/chm13/hub/t2t-chm13-v1.1/rmsk/rmsk.bigBed</a>.</p>
<p>We obtained similar results as on the whole human genome, with MSRs E, F and P
performing better than HPC at mapq 50 (Figure <a href="HPC-paper.html#fig:mapeval">3.5</a>B). At a mapq
threshold of 50, the error rate is <span class="math inline">\(53\%\)</span>, <span class="math inline">\(31\%\)</span>, and <span class="math inline">\(39\%\)</span> lower than HPC at
mapq 60 for MSRs E, F and P respectively, while the fraction of mapped reads
remains slightly higher. At mapq=60, raw has a error rate <span class="math inline">\(40\%\)</span> lower than HPC
but it the mapped fraction is also <span class="math inline">\(17\%\)</span> lower.</p>
</div>
<div id="raw-mapping-improves-upon-hpc-on-centromeric-regions" class="section level3 hasAnchor" number="3.4.4">
<h3><span class="header-section-number">3.4.4</span> Raw mapping improves upon HPC on centromeric regions<a href="HPC-paper.html#raw-mapping-improves-upon-hpc-on-centromeric-regions" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<p>On the “TandemTools” centromeric reference, HPC consistently maps a smaller
fraction of reads than raw, across all mapping quality thresholds (Figure
<a href="HPC-paper.html#fig:mapeval">3.5</a>C). Additionally, the error rate for raw is often inferior to
that of HPC. The same is true for our selected MSRs: most of them have
comparable performance to HPC, but none of them outperform raw mapping (Figure
<a href="HPC-paper.html#fig:mapeval">3.5</a>C).</p>
<p>We conjecture this is due to the highly repetitive nature of centromeres. HPC
likely removes small unique repetitions in the reads and the reference that
might allow mappers to better match reads to a particular occurrence a
centromeric pattern. Mapping raw reads on the other hand preserves all bases in
the read and better differentiates repeats. Therefore it seems inadvisable to
use HPC when mapping reads to highly repetitive regions of a genome, such as a
centromere.</p>
</div>
<div id="positions-of-incorrectly-mapped-reads-across-the-entire-human-genome" class="section level3 hasAnchor" number="3.4.5">
<h3><span class="header-section-number">3.4.5</span> Positions of incorrectly mapped reads across the entire human genome<a href="HPC-paper.html#positions-of-incorrectly-mapped-reads-across-the-entire-human-genome" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<p>To study how MSRs E, F, and P improve over HPC and raw mapping in terms of error
rate on the human genome, we selected all the primary alignments that
<code>paftools mapeval</code> reported as incorrectly mapped. For HPC and raw, only
alignments of mapping quality equal to 60 were considered. To report a
comparable fraction of aligned reads, we selected alignments of mapping quality
<span class="math inline">\(\geq 50\)</span> for MSRs. We then reported the origin of those incorrectly mapped
reads on whole human genome reference, shown per-chromosome in Appendix
<a href="HPC-appendix.html#fig:error-hists">A.1</a>.</p>
<p>We observe that erroneously mapped reads are not only those from centromeres,
and instead originate from many other genomic regions. MSRs E and P have a
markedly lower number of these incorrect mappings than either HPC or raw, with
1118 incorrect mappings for raw mappings and 1130 for HPC as opposed to 549, 970
and 361 for MSRs E, F and P respectively. This stays true even for difficult
regions of the genome such as chromosome X, where raw and HPC have 70 incorrect
mappings as opposed MSRs E and P that have 39, and 27 errors respectively.</p>
<p>We also investigated where all simulated reads were mapped on the whole human
genome assembly, for raw, HPC and MSRs E,F and P in Figures <a href="HPC-appendix.html#fig:hist-raw">A.2</a>
to <a href="HPC-appendix.html#fig:hist-msr-f">A.6</a>. The correctly mapped reads are, as expected, evenly
distributed along each chromosome. The incorrectly mapped reads are however
unevenly distributed. For most chromosomes there is a sharp peak in the
distribution of incorrectly mapped reads, located at the position of the
centromere. For the acrocentric chromosomes, there is a second peak
corresponding to the “stalk” satellite region, with an enrichment of incorrectly
mapped reads. This is expected since both centromeres and “stalks” are
repetitive regions which are a challenge for mapping. For chromosomes 1, 9 and
16 however the majority of incorrectly mapped reads originate in repeated
regions just after the centromere.</p>
</div>
</div>
<div id="hpc-discussion" class="section level2 hasAnchor" number="3.5">
<h2><span class="header-section-number">3.5</span> Discussion<a href="HPC-paper.html#hpc-discussion" class="anchor-section" aria-label="Anchor link to header"></a></h2>
<p>We have introduced the concept of mapping-friendly sequence reduction and shown
that it improves the accuracy of the popular mapping tool <code>minimap2</code> on
simulated Oxford Nanopore long reads.</p>
<p>We focused on reads with high mapping quality (50-60), as it is a common
practice to disregard reads with low mapping
quality <span class="citation"><sup><a href="#ref-prodanovSensitiveAlignmentUsing2020" role="doc-biblioref">243</a>,<a href="#ref-liNewStrategiesImprove2021" role="doc-biblioref">253</a>,<a href="#ref-liSyntheticdiploidBenchmarkAccurate2018" role="doc-biblioref">254</a></sup></span>. However across all mapped reads (mapq
<span class="math inline">\(\geq 0\)</span>), HPC and our MSRs have lower mapping accuracies than raw reads,
consistent with the recommendation made in <code>minimap2</code> to not apply HPC to ONT
data. Despite this, we newly show the benefit of using HPC (and our MSRs) with
<code>minimap2</code> on ONT data when focusing on high mapping quality reads. Furthermore
MSRs provide a higher fraction of high-mapq reads compared to both raw and HPC,
as shown on the human and Drosophila genomes.</p>
<p>A natural future direction is to also test whether our MSRs perform well on
mapping Pacific Biosciences long reads. Furthermore, it is important to
highlight that our sampling of MSRs is incomplete. This is of course due to only
looking at functions having <span class="math inline">\(\ell=2\)</span>, but also to the operational definition of
RC-core-insensitive functions, and finally to taking representatives of
equivalence classes. An interesting future direction would consist in exploring
other families of MSRs, especially those that would include HPC and/or close
variations of it.</p>
<p>Additionally, our analyses suggests to not perform HPC on centromeres and other
repeated regions, hinting at applying sequence transformations to only some
parts of the genomes. We leave this direction for future work.</p>
</div>
<div id="limitations-of-this-study" class="section level2 hasAnchor" number="3.6">
<h2><span class="header-section-number">3.6</span> Limitations of this study<a href="HPC-paper.html#limitations-of-this-study" class="anchor-section" aria-label="Anchor link to header"></a></h2>
<p>Our proposed MSRs improve upon HPC at mapq 60, both in terms of fraction of
reads mapped and error rate, on whole human and <em>Drosophila melanogaster</em>
genomes. We chose these sequences because they were from organisms that we
deemed different enough, however it would be interesting to verify if our
proposed MSRs are still advantageous on very different organisms, e.g. more
bacterial or viral genomes. This would allow us to assess the generalizability
of our proposed MSRs.</p>
<p>We made the choice of using simulated data to be able to compute a mapping error
rate. Some metrics, such as fraction of reads mapped might still be informative
with regards to the mapping performance benefits of MSRs, even on real data.
Evaluating the MSRs on real data might be more challenging but would offer
insight into real-world usage of such pre-processing transformations.</p>
<p>Finally, the restrictions we imposed to define RC-core-insensitive MSRs though
intuitively understandable are somewhat arbitrary, so exploring a larger search
space might be beneficial. Alternatively for higher order MSRs, even with our
restrictions, the search spaces remain much too large to be explored
exhaustively. To mitigate this problem, either further restrictions need to be
found, or an alternative, optimization-based exploration method should be
implemented.</p>
</div>
<div id="code-availability" class="section level2 hasAnchor" number="3.7">
<h2><span class="header-section-number">3.7</span> Code availability<a href="HPC-paper.html#code-availability" class="anchor-section" aria-label="Anchor link to header"></a></h2>
<p>The scripts and pipelines used to obtain the results, as well as do the analysis
and figures are available in an online repository at
<a href="https://github.com/lucblassel/MSR_discovery">github.com/lucblassel/MSR_discovery</a></p>
</div>
<div id="supplementary-information" class="section level2 unnumbered hasAnchor">
<h2>Supplementary information<a href="HPC-paper.html#supplementary-information" class="anchor-section" aria-label="Anchor link to header"></a></h2>
<p>Supporting Information can be found in Appendix <a href="HPC-appendix.html#HPC-appendix">A</a></p>

</div>
</div>
<h3>References</h3>
<div id="refs" class="references csl-bib-body" line-spacing="2">
<div id="ref-nurk2022" class="csl-entry">
<div class="csl-left-margin">4. </div><div class="csl-right-inline">Nurk, S. <em>et al.</em> <a href="https://doi.org/10.1126/science.abj6987">The complete sequence of a human genome</a>. <em>Science</em> <strong>376</strong>, 44–53 (2022).</div>
</div>
<div id="ref-dohmBenchmarkingLongreadCorrection2020" class="csl-entry">
<div class="csl-left-margin">81. </div><div class="csl-right-inline">Dohm, J. C., Peters, P., Stralis-Pavese, N. &amp; Himmelbauer, H. <a href="https://doi.org/10.1093/nargab/lqaa037">Benchmarking of long-read correction methods</a>. <em>NAR Genomics and Bioinformatics</em> <strong>2</strong>, (2020).</div>
</div>
<div id="ref-nurkHiCanuAccurateAssembly2020" class="csl-entry">
<div class="csl-left-margin">93. </div><div class="csl-right-inline">Nurk, S. <em>et al.</em> <a href="https://doi.org/10.1101/gr.263566.120"><span>HiCanu</span>: Accurate assembly of segmental duplications, satellites, and allelic variants from high-fidelity long reads</a>. <em>Genome Res.</em> <strong>30</strong>, 1291–1305 (2020).</div>
</div>
<div id="ref-ekimMinimizerspaceBruijnGraphs2021" class="csl-entry">
<div class="csl-left-margin">94. </div><div class="csl-right-inline">Ekim, B., Berger, B. &amp; Chikhi, R. <a href="https://doi.org/10.1016/j.cels.2021.08.009">Minimizer-space de <span>Bruijn</span> graphs: Whole-genome assembly of long reads in minutes on a personal computer</a>. <em>Cell Systems</em> <strong>12</strong>, 958–968.e6 (2021).</div>
</div>
<div id="ref-millerAggressiveAssemblyPyrosequencing2008" class="csl-entry">
<div class="csl-left-margin">95. </div><div class="csl-right-inline">Miller, J. R. <em>et al.</em> <a href="https://doi.org/10.1093/bioinformatics/btn548">Aggressive assembly of pyrosequencing reads with mates</a>. <em>Bioinformatics</em> <strong>24</strong>, 2818–2824 (2008).</div>
</div>
<div id="ref-sahlinNovoClusteringLongRead2020" class="csl-entry">
<div class="csl-left-margin">97. </div><div class="csl-right-inline">Sahlin, K. &amp; Medvedev, P. <a href="https://doi.org/10.1089/cmb.2019.0299">De <span>Novo Clustering</span> of <span>Long-Read Transcriptome Data Using</span> a <span>Greedy</span>, <span>Quality Value-Based Algorithm</span></a>. <em>Journal of Computational Biology</em> <strong>27</strong>, 472–484 (2020).</div>
</div>
<div id="ref-auImprovingPacBioLong2012" class="csl-entry">
<div class="csl-left-margin">98. </div><div class="csl-right-inline">Au, K. F., Underwood, J. G., Lee, L. &amp; Wong, W. H. <a href="https://doi.org/10.1371/journal.pone.0046679">Improving <span>PacBio Long Read Accuracy</span> by <span>Short Read Alignment</span></a>. <em>PLOS ONE</em> <strong>7</strong>, e46679 (2012).</div>
</div>
<div id="ref-liMinimap2PairwiseAlignment2018" class="csl-entry">
<div class="csl-left-margin">100. </div><div class="csl-right-inline">Li, H. <a href="https://doi.org/10.1093/bioinformatics/bty191">Minimap2: Pairwise alignment for nucleotide sequences</a>. <em>Bioinformatics</em> <strong>34</strong>, 3094–3100 (2018).</div>
</div>
<div id="ref-jainWeightedMinimizerSampling2020" class="csl-entry">
<div class="csl-left-margin">101. </div><div class="csl-right-inline">Jain, C. <em>et al.</em> <a href="https://doi.org/10.1093/bioinformatics/btaa435">Weighted minimizer sampling improves long read mapping</a>. <em>Bioinformatics</em> <strong>36</strong>, i111–i118 (2020).</div>
</div>
<div id="ref-gusfieldAlgorithmsStringsTrees1997" class="csl-entry">
<div class="csl-left-margin">108. </div><div class="csl-right-inline">Gusfield, D. <em>Algorithms on strings, trees, and sequences: Computer science and computational biology</em>. (Cambridge University Press, 1997). doi:<a href="https://doi.org/10.1017/CBO9780511574931">10.1017/CBO9780511574931</a>.</div>
</div>
<div id="ref-prodanovSensitiveAlignmentUsing2020" class="csl-entry">
<div class="csl-left-margin">243. </div><div class="csl-right-inline">Prodanov, T. &amp; Bansal, V. <a href="https://doi.org/10.1093/nar/gkaa829">Sensitive alignment using paralogous sequence variants improves long-read mapping and variant calling in segmental duplications</a>. <em>Nucleic Acids Research</em> <strong>48</strong>, e114 (2020).</div>
</div>
<div id="ref-mikheenkoTandemToolsMappingLong2020" class="csl-entry">
<div class="csl-left-margin">245. </div><div class="csl-right-inline">Mikheenko, A., Bzikadze, A. V., Gurevich, A., Miga, K. H. &amp; Pevzner, P. A. <a href="https://doi.org/10.1093/bioinformatics/btaa440"><span>TandemTools</span>: Mapping long reads and assessing/improving assembly quality in extra-long tandem repeats</a>. <em>Bioinformatics</em> <strong>36</strong>, i75–i83 (2020).</div>
</div>
<div id="ref-braggFastAccurateErrorcorrection2012" class="csl-entry">
<div class="csl-left-margin">246. </div><div class="csl-right-inline">Bragg, L., Stone, G., Imelfort, M., Hugenholtz, P. &amp; Tyson, G. W. <a href="https://doi.org/10.1038/nmeth.1990">Fast, accurate error-correction of amplicon pyrosequences using <span>Acacia</span></a>. <em>Nat Methods</em> <strong>9</strong>, 425–426 (2012).</div>
</div>
<div id="ref-sahlinErrorCorrectionEnables2021" class="csl-entry">
<div class="csl-left-margin">247. </div><div class="csl-right-inline">Sahlin, K. &amp; Medvedev, P. <a href="https://doi.org/10.1038/s41467-020-20340-8">Error correction enables use of <span>Oxford Nanopore</span> technology for reference-free transcriptome analysis</a>. <em>Nat Commun</em> <strong>12</strong>, 2 (2021).</div>
</div>
<div id="ref-liuSMARTdenovoNovoAssembler2021" class="csl-entry">
<div class="csl-left-margin">248. </div><div class="csl-right-inline">Liu, H. <em>et al.</em> <a href="https://doi.org/10.46471/gigabyte.15"><span>SMARTdenovo</span>: A de novo assembler using long noisy reads</a>. <em>Gigabyte</em> <strong>2021</strong>, 1–9 (2021).</div>
</div>
<div id="ref-grahamConcreteMathematicsFoundation1994" class="csl-entry">
<div class="csl-left-margin">249. </div><div class="csl-right-inline">Graham, R. L., Knuth, D. E. &amp; Patashnik, O. <em>Concrete mathematics: A foundation for computer science</em>. (<span>Addison-Wesley</span>, 1994).</div>
</div>
<div id="ref-adamsGenomeSequenceDrosophila2000" class="csl-entry">
<div class="csl-left-margin">250. </div><div class="csl-right-inline">Adams, M. D. <em>et al.</em> <a href="https://doi.org/10.1126/science.287.5461.2185">The genome sequence of <span>Drosophila</span> melanogaster</a>. <em>Science</em> <strong>287</strong>, 2185–2195 (2000).</div>
</div>
<div id="ref-yangNanoSimNanoporeSequence2017" class="csl-entry">
<div class="csl-left-margin">251. </div><div class="csl-right-inline">Yang, C., Chu, J., Warren, R. L. &amp; Birol, I. <a href="https://doi.org/10.1093/gigascience/gix010"><span>NanoSim</span>: Nanopore sequence read simulator based on statistical characterization</a>. <em>GigaScience</em> <strong>6</strong>, (2017).</div>
</div>
<div id="ref-rhieMerquryReferencefreeQuality2020" class="csl-entry">
<div class="csl-left-margin">252. </div><div class="csl-right-inline">Rhie, A., Walenz, B. P., Koren, S. &amp; Phillippy, A. M. <a href="https://doi.org/10.1186/s13059-020-02134-9">Merqury: Reference-free quality, completeness, and phasing assessment for genome assemblies</a>. <em>Genome Biology</em> <strong>21</strong>, 245 (2020).</div>
</div>
<div id="ref-liNewStrategiesImprove2021" class="csl-entry">
<div class="csl-left-margin">253. </div><div class="csl-right-inline">Li, H. New strategies to improve Minimap2 alignment accuracy. <a href="https://arxiv.org/abs/2108.03515">https://arxiv.org/abs/2108.03515</a> (2021).</div>
</div>
<div id="ref-liSyntheticdiploidBenchmarkAccurate2018" class="csl-entry">
<div class="csl-left-margin">254. </div><div class="csl-right-inline">Li, H. <em>et al.</em> <a href="https://doi.org/10.1038/s41592-018-0054-7">A synthetic-diploid benchmark for accurate variant-calling evaluation</a>. <em>Nat Methods</em> <strong>15</strong>, 595–597 (2018).</div>
</div>
</div>
            </section>

          </div>
        </div>
      </div>
<a href="aligning-sequence-data.html" class="navigation navigation-prev " aria-label="Previous page"><i class="fa fa-angle-left"></i></a>
<a href="learning-from-alignments.html" class="navigation navigation-next " aria-label="Next page"><i class="fa fa-angle-right"></i></a>
    </div>
  </div>
<script src="libs/gitbook-2.6.7/js/app.min.js"></script>
<script src="libs/gitbook-2.6.7/js/clipboard.min.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-search.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-sharing.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-fontsettings.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-bookdown.js"></script>
<script src="libs/gitbook-2.6.7/js/jquery.highlight.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-clipboard.js"></script>
<script>
gitbook.require(["gitbook"], function(gitbook) {
gitbook.start({
"sharing": {
"github": false,
"facebook": true,
"twitter": true,
"linkedin": false,
"weibo": false,
"instapaper": false,
"vk": false,
"whatsapp": false,
"all": ["facebook", "twitter", "linkedin", "weibo", "instapaper"]
},
"fontsettings": {
"theme": "white",
"family": "sans",
"size": 2
},
"edit": {
"link": "https://github.com/lucblassel/phd-manuscript/edit/main/03-HPC-paper.Rmd",
"text": "Edit"
},
"history": {
"link": null,
"text": null
},
"view": {
"link": null,
"text": null
},
"download": ["_main.pdf"],
"search": {
"engine": "fuse",
"options": null
},
"toc": {
"collapse": "none"
}
});
});
</script>

<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    var src = "true";
    if (src === "" || src === "true") src = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML";
    if (location.protocol !== "file:")
      if (/^https?:/.test(src))
        src = src.replace(/^https?:/, '');
    script.src = src;
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>
</body>

</html>
