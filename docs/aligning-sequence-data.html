<!DOCTYPE html>
<html lang="" xml:lang="">
<head>

  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <title>Chapter 2 Aligning sequence data | From sequences to knowledge, improving and learning from sequence alignments</title>
  <meta name="description" content="Chapter 2 Aligning sequence data | From sequences to knowledge, improving and learning from sequence alignments" />
  <meta name="generator" content="bookdown 0.26 and GitBook 2.6.7" />

  <meta property="og:title" content="Chapter 2 Aligning sequence data | From sequences to knowledge, improving and learning from sequence alignments" />
  <meta property="og:type" content="book" />
  
  
  <meta name="github-repo" content="lucblassel/phd-manuscript" />

  <meta name="twitter:card" content="summary" />
  <meta name="twitter:title" content="Chapter 2 Aligning sequence data | From sequences to knowledge, improving and learning from sequence alignments" />
  
  
  

<meta name="author" content="Luc Blassel" />


<meta name="date" content="2022-09-22" />

  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black" />
  
  
<link rel="prev" href="what-is-sequence-data.html"/>
<link rel="next" href="HPC-paper.html"/>
<script src="libs/jquery-3.6.0/jquery-3.6.0.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/fuse.js@6.4.6/dist/fuse.min.js"></script>
<link href="libs/gitbook-2.6.7/css/style.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-table.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-bookdown.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-highlight.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-search.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-fontsettings.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-clipboard.css" rel="stylesheet" />








<link href="libs/anchor-sections-1.1.0/anchor-sections.css" rel="stylesheet" />
<link href="libs/anchor-sections-1.1.0/anchor-sections-hash.css" rel="stylesheet" />
<script src="libs/anchor-sections-1.1.0/anchor-sections.js"></script>
<link href="libs/tabwid-1.0.0/tabwid.css" rel="stylesheet" />
<link href="libs/tabwid-1.0.0/scrool.css" rel="stylesheet" />



<style type="text/css">
/* Used with Pandoc 2.11+ new --citeproc when CSL is used */
div.csl-bib-body { }
div.csl-entry {
  clear: both;
}
.hanging div.csl-entry {
  margin-left:2em;
  text-indent:-2em;
}
div.csl-left-margin {
  min-width:2em;
  float:left;
}
div.csl-right-inline {
  margin-left:2em;
  padding-left:1em;
}
div.csl-indent {
  margin-left: 2em;
}
</style>

<link rel="stylesheet" href="style.css" type="text/css" />
</head>

<body>



  <div class="book without-animation with-summary font-size-2 font-family-1" data-basepath=".">

    <div class="book-summary">
      <nav role="navigation">

<ul class="summary">
<li><a href="./">From sequences to knowledge,</br> improving and learning from sequence alignments.</a></li>

<li class="divider"></li>
<li><a href="index.html#section"></a>
<ul>
<li class="chapter" data-level="" data-path="index.html"><a href="index.html"><i class="fa fa-check"></i>Abstract</a></li>
<li class="chapter" data-level="" data-path="index.html"><a href="index.html#résumé"><i class="fa fa-check"></i>Résumé</a></li>
</ul></li>
<li class="chapter" data-level="" data-path="acknowledgments.html"><a href="acknowledgments.html"><i class="fa fa-check"></i>Acknowledgments</a></li>
<li class="chapter" data-level="" data-path="list-of-acronyms-and-abbreviations.html"><a href="list-of-acronyms-and-abbreviations.html"><i class="fa fa-check"></i>List of Acronyms and abbreviations</a></li>
<li class="chapter" data-level="" data-path="general-introduction.html"><a href="general-introduction.html"><i class="fa fa-check"></i>General Introduction</a>
<ul>
<li class="chapter" data-level="" data-path="general-introduction.html"><a href="general-introduction.html#research-output"><i class="fa fa-check"></i>Research output</a>
<ul>
<li class="chapter" data-level="" data-path="general-introduction.html"><a href="general-introduction.html#journal-publications"><i class="fa fa-check"></i>Journal publications</a></li>
<li class="chapter" data-level="" data-path="general-introduction.html"><a href="general-introduction.html#presentations-and-posters"><i class="fa fa-check"></i>Presentations and posters</a></li>
</ul></li>
</ul></li>
<li class="chapter" data-level="1" data-path="what-is-sequence-data.html"><a href="what-is-sequence-data.html"><i class="fa fa-check"></i><b>1</b> What is Sequence data ?</a>
<ul>
<li class="chapter" data-level="1.1" data-path="what-is-sequence-data.html"><a href="what-is-sequence-data.html#biological-sequences-a-primer"><i class="fa fa-check"></i><b>1.1</b> Biological sequences, a primer</a>
<ul>
<li class="chapter" data-level="1.1.1" data-path="what-is-sequence-data.html"><a href="what-is-sequence-data.html#what-is-dna"><i class="fa fa-check"></i><b>1.1.1</b> What is DNA ?</a></li>
<li class="chapter" data-level="1.1.2" data-path="what-is-sequence-data.html"><a href="what-is-sequence-data.html#from-information-to-action"><i class="fa fa-check"></i><b>1.1.2</b> From Information to action</a></li>
</ul></li>
<li class="chapter" data-level="1.2" data-path="what-is-sequence-data.html"><a href="what-is-sequence-data.html#obtaining-sequence-data"><i class="fa fa-check"></i><b>1.2</b> Obtaining sequence data</a>
<ul>
<li class="chapter" data-level="1.2.1" data-path="what-is-sequence-data.html"><a href="what-is-sequence-data.html#sanger-sequencing-a-breakthrough"><i class="fa fa-check"></i><b>1.2.1</b> Sanger sequencing, a breakthrough</a></li>
<li class="chapter" data-level="1.2.2" data-path="what-is-sequence-data.html"><a href="what-is-sequence-data.html#next-generation-sequencing"><i class="fa fa-check"></i><b>1.2.2</b> Next-generation sequencing</a></li>
<li class="chapter" data-level="1.2.3" data-path="what-is-sequence-data.html"><a href="what-is-sequence-data.html#long-read-sequencing"><i class="fa fa-check"></i><b>1.2.3</b> Long read sequencing</a></li>
</ul></li>
<li class="chapter" data-level="1.3" data-path="what-is-sequence-data.html"><a href="what-is-sequence-data.html#sequencing-errors-how-to-account-for-them"><i class="fa fa-check"></i><b>1.3</b> Sequencing errors, how to account for them ?</a>
<ul>
<li class="chapter" data-level="1.3.1" data-path="what-is-sequence-data.html"><a href="what-is-sequence-data.html#error-correction-methods"><i class="fa fa-check"></i><b>1.3.1</b> Error correction methods</a></li>
<li class="chapter" data-level="1.3.2" data-path="what-is-sequence-data.html"><a href="what-is-sequence-data.html#more-accurate-sequencing-methods"><i class="fa fa-check"></i><b>1.3.2</b> More accurate sequencing methods</a></li>
</ul></li>
<li class="chapter" data-level="1.4" data-path="what-is-sequence-data.html"><a href="what-is-sequence-data.html#the-special-case-of-homopolymers"><i class="fa fa-check"></i><b>1.4</b> The special case of homopolymers</a>
<ul>
<li class="chapter" data-level="1.4.1" data-path="what-is-sequence-data.html"><a href="what-is-sequence-data.html#homopolymers-and-the-human-genome"><i class="fa fa-check"></i><b>1.4.1</b> Homopolymers and the human genome</a></li>
<li class="chapter" data-level="1.4.2" data-path="what-is-sequence-data.html"><a href="what-is-sequence-data.html#homopolymers-and-long-reads"><i class="fa fa-check"></i><b>1.4.2</b> Homopolymers and long reads</a></li>
<li class="chapter" data-level="1.4.3" data-path="what-is-sequence-data.html"><a href="what-is-sequence-data.html#accounting-for-homopolymers"><i class="fa fa-check"></i><b>1.4.3</b> Accounting for homopolymers</a></li>
</ul></li>
<li class="chapter" data-level="1.5" data-path="what-is-sequence-data.html"><a href="what-is-sequence-data.html#conclusion"><i class="fa fa-check"></i><b>1.5</b> Conclusion</a></li>
</ul></li>
<li class="chapter" data-level="2" data-path="aligning-sequence-data.html"><a href="aligning-sequence-data.html"><i class="fa fa-check"></i><b>2</b> Aligning sequence data</a>
<ul>
<li class="chapter" data-level="2.1" data-path="aligning-sequence-data.html"><a href="aligning-sequence-data.html#what-is-an-alignment"><i class="fa fa-check"></i><b>2.1</b> What is an alignment ?</a>
<ul>
<li class="chapter" data-level="2.1.1" data-path="aligning-sequence-data.html"><a href="aligning-sequence-data.html#why-align"><i class="fa fa-check"></i><b>2.1.1</b> Why align ?</a></li>
<li class="chapter" data-level="2.1.2" data-path="aligning-sequence-data.html"><a href="aligning-sequence-data.html#how-to-align-two-sequences"><i class="fa fa-check"></i><b>2.1.2</b> How to align two sequences ?</a></li>
<li class="chapter" data-level="2.1.3" data-path="aligning-sequence-data.html"><a href="aligning-sequence-data.html#scoring-and-substitution-models"><i class="fa fa-check"></i><b>2.1.3</b> Scoring and substitution models</a></li>
<li class="chapter" data-level="2.1.4" data-path="aligning-sequence-data.html"><a href="aligning-sequence-data.html#dealing-with-gaps"><i class="fa fa-check"></i><b>2.1.4</b> Dealing with gaps</a></li>
</ul></li>
<li class="chapter" data-level="2.2" data-path="aligning-sequence-data.html"><a href="aligning-sequence-data.html#how-do-we-speed-up-pairwise-alignment"><i class="fa fa-check"></i><b>2.2</b> How do we speed up pairwise alignment ?</a>
<ul>
<li class="chapter" data-level="2.2.1" data-path="aligning-sequence-data.html"><a href="aligning-sequence-data.html#changing-the-method"><i class="fa fa-check"></i><b>2.2.1</b> Changing the method</a></li>
<li class="chapter" data-level="2.2.2" data-path="aligning-sequence-data.html"><a href="aligning-sequence-data.html#seed-and-extend-with-data-structures"><i class="fa fa-check"></i><b>2.2.2</b> Seed and extend with data structures</a></li>
</ul></li>
<li class="chapter" data-level="2.3" data-path="aligning-sequence-data.html"><a href="aligning-sequence-data.html#the-specificities-of-read-mapping"><i class="fa fa-check"></i><b>2.3</b> The specificities of read-mapping</a>
<ul>
<li class="chapter" data-level="2.3.1" data-path="aligning-sequence-data.html"><a href="aligning-sequence-data.html#what-is-read-mapping"><i class="fa fa-check"></i><b>2.3.1</b> What is read-mapping ?</a></li>
<li class="chapter" data-level="2.3.2" data-path="aligning-sequence-data.html"><a href="aligning-sequence-data.html#challenges-of-read-mapping"><i class="fa fa-check"></i><b>2.3.2</b> Challenges of read-mapping</a></li>
</ul></li>
<li class="chapter" data-level="2.4" data-path="aligning-sequence-data.html"><a href="aligning-sequence-data.html#multiple-sequence-alignment"><i class="fa fa-check"></i><b>2.4</b> Multiple sequence alignment</a>
<ul>
<li class="chapter" data-level="2.4.1" data-path="aligning-sequence-data.html"><a href="aligning-sequence-data.html#progressive-alignment"><i class="fa fa-check"></i><b>2.4.1</b> Progressive alignment</a></li>
<li class="chapter" data-level="2.4.2" data-path="aligning-sequence-data.html"><a href="aligning-sequence-data.html#other-methods"><i class="fa fa-check"></i><b>2.4.2</b> Other methods</a></li>
</ul></li>
<li class="chapter" data-level="2.5" data-path="aligning-sequence-data.html"><a href="aligning-sequence-data.html#conclusion-1"><i class="fa fa-check"></i><b>2.5</b> Conclusion</a></li>
</ul></li>
<li class="chapter" data-level="3" data-path="HPC-paper.html"><a href="HPC-paper.html"><i class="fa fa-check"></i><b>3</b> Contribution 1: Improving read alignment by exploring a sequence transformation space</a>
<ul>
<li class="chapter" data-level="" data-path="HPC-paper.html"><a href="HPC-paper.html#highlights"><i class="fa fa-check"></i>Highlights</a></li>
<li class="chapter" data-level="" data-path="HPC-paper.html"><a href="HPC-paper.html#graphical-abstract"><i class="fa fa-check"></i>Graphical Abstract</a></li>
<li class="chapter" data-level="" data-path="HPC-paper.html"><a href="HPC-paper.html#hpc-abstract"><i class="fa fa-check"></i>Abstract</a></li>
<li class="chapter" data-level="3.1" data-path="HPC-paper.html"><a href="HPC-paper.html#hpc-introduction"><i class="fa fa-check"></i><b>3.1</b> Introduction</a></li>
<li class="chapter" data-level="3.2" data-path="HPC-paper.html"><a href="HPC-paper.html#methods"><i class="fa fa-check"></i><b>3.2</b> Methods</a>
<ul>
<li class="chapter" data-level="3.2.1" data-path="HPC-paper.html"><a href="HPC-paper.html#sec:msr-def"><i class="fa fa-check"></i><b>3.2.1</b> Streaming sequence reductions</a></li>
<li class="chapter" data-level="3.2.2" data-path="HPC-paper.html"><a href="HPC-paper.html#sec:enum"><i class="fa fa-check"></i><b>3.2.2</b> Restricting the space of streaming sequence reductions</a></li>
</ul></li>
<li class="chapter" data-level="3.3" data-path="HPC-paper.html"><a href="HPC-paper.html#datasets-and-pipelines"><i class="fa fa-check"></i><b>3.3</b> Datasets and Pipelines</a>
<ul>
<li class="chapter" data-level="3.3.1" data-path="HPC-paper.html"><a href="HPC-paper.html#datasets"><i class="fa fa-check"></i><b>3.3.1</b> Datasets</a></li>
<li class="chapter" data-level="3.3.2" data-path="HPC-paper.html"><a href="HPC-paper.html#simulation-pipeline"><i class="fa fa-check"></i><b>3.3.2</b> Simulation pipeline</a></li>
<li class="chapter" data-level="3.3.3" data-path="HPC-paper.html"><a href="HPC-paper.html#evaluation-pipeline"><i class="fa fa-check"></i><b>3.3.3</b> Evaluation pipeline</a></li>
</ul></li>
<li class="chapter" data-level="3.4" data-path="HPC-paper.html"><a href="HPC-paper.html#hpc-results"><i class="fa fa-check"></i><b>3.4</b> Results</a>
<ul>
<li class="chapter" data-level="3.4.1" data-path="HPC-paper.html"><a href="HPC-paper.html#selection-of-mapping-friendly-sequence-reductions"><i class="fa fa-check"></i><b>3.4.1</b> Selection of mapping-friendly sequence reductions</a></li>
<li class="chapter" data-level="3.4.2" data-path="HPC-paper.html"><a href="HPC-paper.html#mapping-friendly-sequence-reductions-lead-to-lower-mapping-errors-on-whole-genomes"><i class="fa fa-check"></i><b>3.4.2</b> Mapping-friendly sequence reductions lead to lower mapping errors on whole genomes</a></li>
<li class="chapter" data-level="3.4.3" data-path="HPC-paper.html"><a href="HPC-paper.html#mapping-friendly-sequence-reductions-increase-mapping-quality-on-repeated-regions-of-the-human-genome"><i class="fa fa-check"></i><b>3.4.3</b> Mapping-friendly sequence reductions increase mapping quality on repeated regions of the human genome</a></li>
<li class="chapter" data-level="3.4.4" data-path="HPC-paper.html"><a href="HPC-paper.html#raw-mapping-improves-upon-hpc-on-centromeric-regions"><i class="fa fa-check"></i><b>3.4.4</b> Raw mapping improves upon HPC on centromeric regions</a></li>
<li class="chapter" data-level="3.4.5" data-path="HPC-paper.html"><a href="HPC-paper.html#positions-of-incorrectly-mapped-reads-across-the-entire-human-genome"><i class="fa fa-check"></i><b>3.4.5</b> Positions of incorrectly mapped reads across the entire human genome</a></li>
</ul></li>
<li class="chapter" data-level="3.5" data-path="HPC-paper.html"><a href="HPC-paper.html#discussion"><i class="fa fa-check"></i><b>3.5</b> Discussion</a></li>
<li class="chapter" data-level="3.6" data-path="HPC-paper.html"><a href="HPC-paper.html#limitations-of-this-study"><i class="fa fa-check"></i><b>3.6</b> Limitations of this study</a></li>
<li class="chapter" data-level="" data-path="HPC-paper.html"><a href="HPC-paper.html#acknowledgements"><i class="fa fa-check"></i>Acknowledgements</a></li>
<li class="chapter" data-level="" data-path="HPC-paper.html"><a href="HPC-paper.html#author-contributions"><i class="fa fa-check"></i>Author contributions</a></li>
<li class="chapter" data-level="" data-path="HPC-paper.html"><a href="HPC-paper.html#declaration-of-interests"><i class="fa fa-check"></i>Declaration of interests</a></li>
<li class="chapter" data-level="" data-path="HPC-paper.html"><a href="HPC-paper.html#star-methods"><i class="fa fa-check"></i>STAR Methods</a>
<ul>
<li class="chapter" data-level="" data-path="HPC-paper.html"><a href="HPC-paper.html#lead-contact"><i class="fa fa-check"></i>Lead contact</a></li>
<li class="chapter" data-level="" data-path="HPC-paper.html"><a href="HPC-paper.html#materials-availability"><i class="fa fa-check"></i>Materials availability</a></li>
<li class="chapter" data-level="" data-path="HPC-paper.html"><a href="HPC-paper.html#data-and-code-availability"><i class="fa fa-check"></i>Data and code availability</a></li>
<li class="chapter" data-level="" data-path="HPC-paper.html"><a href="HPC-paper.html#method-details"><i class="fa fa-check"></i>Method details</a></li>
</ul></li>
<li class="chapter" data-level="" data-path="HPC-paper.html"><a href="HPC-paper.html#supplementary-information"><i class="fa fa-check"></i>Supplementary information</a></li>
</ul></li>
<li class="chapter" data-level="4" data-path="learning-from-sequences-and-alignments.html"><a href="learning-from-sequences-and-alignments.html"><i class="fa fa-check"></i><b>4</b> Learning from sequences and alignments</a>
<ul>
<li class="chapter" data-level="4.1" data-path="learning-from-sequences-and-alignments.html"><a href="learning-from-sequences-and-alignments.html#why-learn-from-alignments"><i class="fa fa-check"></i><b>4.1</b> Why learn from alignments ?</a></li>
<li class="chapter" data-level="4.2" data-path="learning-from-sequences-and-alignments.html"><a href="learning-from-sequences-and-alignments.html#what-to-learn"><i class="fa fa-check"></i><b>4.2</b> What to learn ?</a>
<ul>
<li class="chapter" data-level="4.2.1" data-path="learning-from-sequences-and-alignments.html"><a href="learning-from-sequences-and-alignments.html#supervised-learning"><i class="fa fa-check"></i><b>4.2.1</b> Supervised learning</a></li>
<li class="chapter" data-level="4.2.2" data-path="learning-from-sequences-and-alignments.html"><a href="learning-from-sequences-and-alignments.html#unsupervised-learning"><i class="fa fa-check"></i><b>4.2.2</b> Unsupervised learning</a></li>
<li class="chapter" data-level="4.2.3" data-path="learning-from-sequences-and-alignments.html"><a href="learning-from-sequences-and-alignments.html#others-paradigms"><i class="fa fa-check"></i><b>4.2.3</b> Others paradigms</a></li>
</ul></li>
<li class="chapter" data-level="4.3" data-path="learning-from-sequences-and-alignments.html"><a href="learning-from-sequences-and-alignments.html#how-to-learn"><i class="fa fa-check"></i><b>4.3</b> How to learn ?</a>
<ul>
<li class="chapter" data-level="4.3.1" data-path="learning-from-sequences-and-alignments.html"><a href="learning-from-sequences-and-alignments.html#general-setting"><i class="fa fa-check"></i><b>4.3.1</b> General setting</a></li>
<li class="chapter" data-level="4.3.2" data-path="learning-from-sequences-and-alignments.html"><a href="learning-from-sequences-and-alignments.html#tests-and-statistical-learning"><i class="fa fa-check"></i><b>4.3.2</b> Tests and statistical learning</a></li>
<li class="chapter" data-level="4.3.3" data-path="learning-from-sequences-and-alignments.html"><a href="learning-from-sequences-and-alignments.html#more-complex-methods"><i class="fa fa-check"></i><b>4.3.3</b> More complex methods</a></li>
</ul></li>
<li class="chapter" data-level="4.4" data-path="learning-from-sequences-and-alignments.html"><a href="learning-from-sequences-and-alignments.html#preprocessing-the-alignment-for-machine-learning"><i class="fa fa-check"></i><b>4.4</b> Preprocessing the alignment for machine learning</a>
<ul>
<li class="chapter" data-level="4.4.1" data-path="learning-from-sequences-and-alignments.html"><a href="learning-from-sequences-and-alignments.html#general-purpose-encodings"><i class="fa fa-check"></i><b>4.4.1</b> General purpose encodings</a></li>
<li class="chapter" data-level="4.4.2" data-path="learning-from-sequences-and-alignments.html"><a href="learning-from-sequences-and-alignments.html#biological-sequence-specific-encodings"><i class="fa fa-check"></i><b>4.4.2</b> Biological sequence-specific encodings</a></li>
</ul></li>
<li class="chapter" data-level="4.5" data-path="learning-from-sequences-and-alignments.html"><a href="learning-from-sequences-and-alignments.html#conclusion-2"><i class="fa fa-check"></i><b>4.5</b> Conclusion</a></li>
</ul></li>
<li class="chapter" data-level="5" data-path="viruses-hiv-and-drug-resistance.html"><a href="viruses-hiv-and-drug-resistance.html"><i class="fa fa-check"></i><b>5</b> Viruses, HIV and drug resistance</a>
<ul>
<li class="chapter" data-level="5.1" data-path="viruses-hiv-and-drug-resistance.html"><a href="viruses-hiv-and-drug-resistance.html#what-are-viruses"><i class="fa fa-check"></i><b>5.1</b> What are viruses ?</a></li>
<li class="chapter" data-level="5.2" data-path="viruses-hiv-and-drug-resistance.html"><a href="viruses-hiv-and-drug-resistance.html#getting-to-know-hiv"><i class="fa fa-check"></i><b>5.2</b> Getting to know HIV</a>
<ul>
<li class="chapter" data-level="5.2.1" data-path="viruses-hiv-and-drug-resistance.html"><a href="viruses-hiv-and-drug-resistance.html#quick-presentation-of-hiv"><i class="fa fa-check"></i><b>5.2.1</b> Quick Presentation of HIV</a></li>
<li class="chapter" data-level="5.2.2" data-path="viruses-hiv-and-drug-resistance.html"><a href="viruses-hiv-and-drug-resistance.html#the-replication-cycle-of-hiv"><i class="fa fa-check"></i><b>5.2.2</b> The replication cycle of HIV</a></li>
<li class="chapter" data-level="5.2.3" data-path="viruses-hiv-and-drug-resistance.html"><a href="viruses-hiv-and-drug-resistance.html#genetics-of-hiv"><i class="fa fa-check"></i><b>5.2.3</b> Genetics of HIV</a></li>
</ul></li>
<li class="chapter" data-level="5.3" data-path="viruses-hiv-and-drug-resistance.html"><a href="viruses-hiv-and-drug-resistance.html#drug-resistance-in-hiv"><i class="fa fa-check"></i><b>5.3</b> Drug resistance in HIV</a>
<ul>
<li class="chapter" data-level="5.3.1" data-path="viruses-hiv-and-drug-resistance.html"><a href="viruses-hiv-and-drug-resistance.html#a-quick-history-of-art"><i class="fa fa-check"></i><b>5.3.1</b> A quick history of ART</a></li>
<li class="chapter" data-level="5.3.2" data-path="viruses-hiv-and-drug-resistance.html"><a href="viruses-hiv-and-drug-resistance.html#drug-mechanisms"><i class="fa fa-check"></i><b>5.3.2</b> Main mechanisms of viral proteins, antiretroviral drugs and associated resistance.</a></li>
<li class="chapter" data-level="5.3.3" data-path="viruses-hiv-and-drug-resistance.html"><a href="viruses-hiv-and-drug-resistance.html#consequences-of-resistance-on-global-health"><i class="fa fa-check"></i><b>5.3.3</b> Consequences of resistance on global health</a></li>
<li class="chapter" data-level="5.3.4" data-path="viruses-hiv-and-drug-resistance.html"><a href="viruses-hiv-and-drug-resistance.html#finding-drms"><i class="fa fa-check"></i><b>5.3.4</b> Finding DRMs </a></li>
</ul></li>
<li class="chapter" data-level="5.4" data-path="viruses-hiv-and-drug-resistance.html"><a href="viruses-hiv-and-drug-resistance.html#conclusion-3"><i class="fa fa-check"></i><b>5.4</b> Conclusion</a></li>
</ul></li>
<li class="chapter" data-level="6" data-path="HIV-paper.html"><a href="HIV-paper.html"><i class="fa fa-check"></i><b>6</b> Contribution 2: Inferring mutation roles from sequence alignments using machine learning</a>
<ul>
<li class="chapter" data-level="" data-path="HIV-paper.html"><a href="HIV-paper.html#abstract-paper"><i class="fa fa-check"></i>Abstract</a></li>
<li class="chapter" data-level="" data-path="HIV-paper.html"><a href="HIV-paper.html#author-summary"><i class="fa fa-check"></i>Author summary</a></li>
<li class="chapter" data-level="6.1" data-path="HIV-paper.html"><a href="HIV-paper.html#hiv-introduction"><i class="fa fa-check"></i><b>6.1</b> Introduction</a></li>
<li class="chapter" data-level="6.2" data-path="HIV-paper.html"><a href="HIV-paper.html#materials-and-methods"><i class="fa fa-check"></i><b>6.2</b> Materials and methods</a>
<ul>
<li class="chapter" data-level="6.2.1" data-path="HIV-paper.html"><a href="HIV-paper.html#data"><i class="fa fa-check"></i><b>6.2.1</b> Data</a></li>
<li class="chapter" data-level="6.2.2" data-path="HIV-paper.html"><a href="HIV-paper.html#classifier-training"><i class="fa fa-check"></i><b>6.2.2</b> Classifier training</a></li>
<li class="chapter" data-level="6.2.3" data-path="HIV-paper.html"><a href="HIV-paper.html#measuring-classifier-performance"><i class="fa fa-check"></i><b>6.2.3</b> Measuring classifier performance</a></li>
</ul></li>
<li class="chapter" data-level="6.3" data-path="HIV-paper.html"><a href="HIV-paper.html#hiv-results"><i class="fa fa-check"></i><b>6.3</b> Results</a>
<ul>
<li class="chapter" data-level="6.3.1" data-path="HIV-paper.html"><a href="HIV-paper.html#classifier-performance-interpretation"><i class="fa fa-check"></i><b>6.3.1</b> Classifier performance &amp; interpretation</a></li>
<li class="chapter" data-level="6.3.2" data-path="HIV-paper.html"><a href="HIV-paper.html#additional-classification-results"><i class="fa fa-check"></i><b>6.3.2</b> Additional classification results</a></li>
<li class="chapter" data-level="6.3.3" data-path="HIV-paper.html"><a href="HIV-paper.html#identifying-new-mutations-from-classifiers"><i class="fa fa-check"></i><b>6.3.3</b> Identifying new mutations from classifiers</a></li>
<li class="chapter" data-level="6.3.4" data-path="HIV-paper.html"><a href="HIV-paper.html#detailed-analysis-of-potentially-resistance-associated-mutations"><i class="fa fa-check"></i><b>6.3.4</b> Detailed analysis of potentially resistance-associated mutations</a></li>
</ul></li>
<li class="chapter" data-level="6.4" data-path="HIV-paper.html"><a href="HIV-paper.html#discussion-and-perspectives"><i class="fa fa-check"></i><b>6.4</b> Discussion and perspectives</a></li>
<li class="chapter" data-level="" data-path="HIV-paper.html"><a href="HIV-paper.html#hiv-acknowledgments"><i class="fa fa-check"></i>Acknowledgments</a></li>
<li class="chapter" data-level="" data-path="HIV-paper.html"><a href="HIV-paper.html#supporting-information"><i class="fa fa-check"></i>Supporting Information</a></li>
</ul></li>
<li class="chapter" data-level="7" data-path="learning-alignments-an-interesting-perspective.html"><a href="learning-alignments-an-interesting-perspective.html"><i class="fa fa-check"></i><b>7</b> Learning alignments, an interesting perspective</a>
<ul>
<li class="chapter" data-level="7.1" data-path="learning-alignments-an-interesting-perspective.html"><a href="learning-alignments-an-interesting-perspective.html#intro-to-deep-learning"><i class="fa fa-check"></i><b>7.1</b> Intro to deep learning</a></li>
<li class="chapter" data-level="7.2" data-path="learning-alignments-an-interesting-perspective.html"><a href="learning-alignments-an-interesting-perspective.html#learning-sequence-embeddings"><i class="fa fa-check"></i><b>7.2</b> Learning sequence embeddings</a></li>
<li class="chapter" data-level="7.3" data-path="learning-alignments-an-interesting-perspective.html"><a href="learning-alignments-an-interesting-perspective.html#learning-pairwise-alignment"><i class="fa fa-check"></i><b>7.3</b> Learning pairwise alignment</a>
<ul>
<li class="chapter" data-level="7.3.1" data-path="learning-alignments-an-interesting-perspective.html"><a href="learning-alignments-an-interesting-perspective.html#dedal"><i class="fa fa-check"></i><b>7.3.1</b> DEDAL</a></li>
<li class="chapter" data-level="7.3.2" data-path="learning-alignments-an-interesting-perspective.html"><a href="learning-alignments-an-interesting-perspective.html#predicting-an-alignment"><i class="fa fa-check"></i><b>7.3.2</b> predicting an alignment</a></li>
</ul></li>
<li class="chapter" data-level="7.4" data-path="learning-alignments-an-interesting-perspective.html"><a href="learning-alignments-an-interesting-perspective.html#what-else-could-we-learn"><i class="fa fa-check"></i><b>7.4</b> What else could we learn ?</a>
<ul>
<li class="chapter" data-level="7.4.1" data-path="learning-alignments-an-interesting-perspective.html"><a href="learning-alignments-an-interesting-perspective.html#learn-to-predict-seeds-or-starting-positions"><i class="fa fa-check"></i><b>7.4.1</b> Learn to predict seeds or starting positions</a></li>
<li class="chapter" data-level="7.4.2" data-path="learning-alignments-an-interesting-perspective.html"><a href="learning-alignments-an-interesting-perspective.html#learn-pre-processing-functions"><i class="fa fa-check"></i><b>7.4.2</b> Learn pre-processing functions</a></li>
</ul></li>
</ul></li>
<li class="chapter" data-level="" data-path="global-conclusion.html"><a href="global-conclusion.html"><i class="fa fa-check"></i>Global conclusion</a>
<ul>
<li class="chapter" data-level="" data-path="global-conclusion.html"><a href="global-conclusion.html#hpc-part"><i class="fa fa-check"></i>HPC part</a></li>
<li class="chapter" data-level="" data-path="global-conclusion.html"><a href="global-conclusion.html#hiv-part"><i class="fa fa-check"></i>HIV part</a></li>
<li class="chapter" data-level="" data-path="global-conclusion.html"><a href="global-conclusion.html#final-words"><i class="fa fa-check"></i>Final words</a></li>
</ul></li>
<li class="chapter" data-level="" data-path="global-references.html"><a href="global-references.html"><i class="fa fa-check"></i>Global References</a></li>
<li class="appendix"><span><b>Appendix</b></span></li>
<li class="chapter" data-level="A" data-path="HPC-appendix.html"><a href="HPC-appendix.html"><i class="fa fa-check"></i><b>A</b> Supporting Information for “Mapping-friendly sequence reductions: going beyond homopolymer compression”</a>
<ul>
<li class="chapter" data-level="A.1" data-path="HPC-appendix.html"><a href="HPC-appendix.html#appendix:tandemtools"><i class="fa fa-check"></i><b>A.1</b> “TandemTools” dataset generation</a></li>
<li class="chapter" data-level="A.2" data-path="HPC-appendix.html"><a href="HPC-appendix.html#msr-performance-comparison"><i class="fa fa-check"></i><b>A.2</b> MSR performance comparison</a></li>
<li class="chapter" data-level="A.3" data-path="HPC-appendix.html"><a href="HPC-appendix.html#analyzing-read-origin-on-whole-human-genome"><i class="fa fa-check"></i><b>A.3</b> Analyzing read origin on whole human genome</a></li>
<li class="chapter" data-level="A.4" data-path="HPC-appendix.html"><a href="HPC-appendix.html#performance-of-msrs-on-the-drosophila-genome"><i class="fa fa-check"></i><b>A.4</b> Performance of MSRs on the Drosophila genome</a></li>
<li class="chapter" data-level="A.5" data-path="HPC-appendix.html"><a href="HPC-appendix.html#key-resource-table"><i class="fa fa-check"></i><b>A.5</b> Key Resource Table</a></li>
</ul></li>
<li class="chapter" data-level="B" data-path="HIV-intro-appendix.html"><a href="HIV-intro-appendix.html"><i class="fa fa-check"></i><b>B</b> Supporting Information for “HIV and DRMs”</a>
<ul>
<li class="chapter" data-level="B.1" data-path="HIV-intro-appendix.html"><a href="HIV-intro-appendix.html#detailed-list-of-hiv-1-protein-structures-used-for-figure-generation."><i class="fa fa-check"></i><b>B.1</b> Detailed list of HIV-1 protein structures used for figure generation.</a></li>
<li class="chapter" data-level="B.2" data-path="HIV-intro-appendix.html"><a href="HIV-intro-appendix.html#list-of-all-antiretroviral-drugs"><i class="fa fa-check"></i><b>B.2</b> List of all antiretroviral drugs</a></li>
</ul></li>
<li class="chapter" data-level="C" data-path="HIV-appendix.html"><a href="HIV-appendix.html"><i class="fa fa-check"></i><b>C</b> Supporting Information for “Using Machine Learning and Big Data to Explore the Drug Resistance Landscape in HIV”</a>
<ul>
<li class="chapter" data-level="C.1" data-path="HIV-appendix.html"><a href="HIV-appendix.html#S1-Appendix"><i class="fa fa-check"></i><b>C.1</b> S1 Appendix (Technical appendix).</a>
<ul>
<li class="chapter" data-level="C.1.1" data-path="HIV-appendix.html"><a href="HIV-appendix.html#data-appendix"><i class="fa fa-check"></i><b>C.1.1</b> Data</a></li>
<li class="chapter" data-level="C.1.2" data-path="HIV-appendix.html"><a href="HIV-appendix.html#classifiers"><i class="fa fa-check"></i><b>C.1.2</b> Classifiers</a></li>
<li class="chapter" data-level="C.1.3" data-path="HIV-appendix.html"><a href="HIV-appendix.html#scoring"><i class="fa fa-check"></i><b>C.1.3</b> Scoring</a></li>
</ul></li>
<li class="chapter" data-level="C.2" data-path="HIV-appendix.html"><a href="HIV-appendix.html#s1-fig."><i class="fa fa-check"></i><b>C.2</b> S1 Fig.</a></li>
<li class="chapter" data-level="C.3" data-path="HIV-appendix.html"><a href="HIV-appendix.html#s2-fig."><i class="fa fa-check"></i><b>C.3</b> S2 Fig.</a></li>
<li class="chapter" data-level="C.4" data-path="HIV-appendix.html"><a href="HIV-appendix.html#s3-fig."><i class="fa fa-check"></i><b>C.4</b> S3 Fig.</a></li>
<li class="chapter" data-level="C.5" data-path="HIV-appendix.html"><a href="HIV-appendix.html#S1-Table"><i class="fa fa-check"></i><b>C.5</b> S1 Table.</a></li>
<li class="chapter" data-level="C.6" data-path="HIV-appendix.html"><a href="HIV-appendix.html#S2-Appendix"><i class="fa fa-check"></i><b>C.6</b> S2 Appendix. (Fisher exact tests)</a></li>
<li class="chapter" data-level="C.7" data-path="HIV-appendix.html"><a href="HIV-appendix.html#s1-data."><i class="fa fa-check"></i><b>C.7</b> S1 Data.</a></li>
<li class="chapter" data-level="C.8" data-path="HIV-appendix.html"><a href="HIV-appendix.html#s2-data."><i class="fa fa-check"></i><b>C.8</b> S2 Data.</a></li>
</ul></li>
<li class="divider"></li>
<li><a href="https://lucblassel.com" target="blank">Back to main website</a></li>
<li><a href="https://github.com/rstudio/bookdown" target="blank">Published with bookdown</a></li>

</ul>

      </nav>
    </div>

    <div class="book-body">
      <div class="body-inner">
        <div class="book-header" role="navigation">
          <h1>
            <i class="fa fa-circle-o-notch fa-spin"></i><a href="./">From sequences to knowledge, improving and learning from sequence alignments</a>
          </h1>
        </div>

        <div class="page-wrapper" tabindex="-1" role="main">
          <div class="page-inner">

            <section class="normal" id="section-">
<div id="aligning-sequence-data" class="section level1 hasAnchor" number="2">
<h1><span class="header-section-number">Chapter 2</span> Aligning sequence data<a href="aligning-sequence-data.html#aligning-sequence-data" class="anchor-section" aria-label="Anchor link to header"></a></h1>
<div id="what-is-an-alignment" class="section level2 hasAnchor" number="2.1">
<h2><span class="header-section-number">2.1</span> What is an alignment ?<a href="aligning-sequence-data.html#what-is-an-alignment" class="anchor-section" aria-label="Anchor link to header"></a></h2>
<p>In biology, comparison is at the heart of many studies: between individuals, between species, between sequencing runs, <em>etc</em>… In order to do this at a fine grained level and extract knowledge from it we need to compare what is comparable, this is where sequence alignment steps in. In broad terms, during sequence alignment, we aim to find regions similar to each other in two or more sequences and group them together. When this process is done with only two sequences it is called a <em>pairwise alignment</em>, when three or more sequences are used it is called <em>multiple alignment</em>. We will first focus on pairwise alignment as it was used as the basis for the more complex multiple alignment.</p>
<div id="why-align" class="section level3 hasAnchor" number="2.1.1">
<h3><span class="header-section-number">2.1.1</span> Why align ?<a href="aligning-sequence-data.html#why-align" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<p>The first question we might ask ourselves is why align at all, if we want to compare two sequences there are plenty of distances and metrics out there to use. Something like the Hamming distance<span class="citation"><sup><a href="#ref-hammingCodingInformationTheory1980" role="doc-biblioref">127</a></sup></span> is very quick and easy to compute by comparing characters two by two. It is however ill-suited to our needs in biology: while it can handle substitutions but indels induce very large Hamming distances. Indeed, insertions and/or deletions shift one of the sequences, compared to the other, and introduce many character-to-character differences that could be explained by a single indel.</p>
<p>For example, let us consider the two following sequences: <code>ATGTGCAGTA</code> and <code>AGTGCAGTAC</code>. if we count the differences character by character, except the first pair of A, all the characters are different (c.f. below). However if we consider that the first T was deleted and a C was inserted at the end of the second sequence then we can see that none of the characters are actually different. In order to represent insertions and deletions <em>gaps</em> are inserted in the sequences as seen below:</p>
<center>
<div class="line-block"><strong><code>ATGTGCAGTA-</code></strong><br />
<strong><code>A-GTGCAGTAC</code></strong></div>
</center>
<p>This problem of comparing two sequences with insertions or deletions is a fairly studied one in text algorithmics: the string-edit problem<span class="citation"><sup><a href="#ref-gusfieldAlgorithmsStringsTrees1997" role="doc-biblioref">128</a></sup></span>. Some metrics like the Levenshtein distance<span class="citation"><sup><a href="#ref-levenshteinBinaryCodesCapable1966" role="doc-biblioref">129</a></sup></span> and the edit distance<span class="citation"><sup><a href="#ref-gusfieldAlgorithmsStringsTrees1997" role="doc-biblioref">128</a></sup></span> exist and are closely related to the pairwise sequence alignment problem, finding the minimal number of substitution, insertion of deletion operations to go from one sequence to the other.</p>
<p>Sequence alignments have many downstream use-cases. They are the basis of comparative genomics<span class="citation"><sup><a href="#ref-hardisonComparativeGenomics2003" role="doc-biblioref">130</a></sup></span> and are used to infer evolutionary relationships and phylogenetic tree reconstruction methods usually take as input multiple alignments<span class="citation"><sup><a href="#ref-felsensteinEvolutionaryTreesDNA1981" role="doc-biblioref">131</a>–<a href="#ref-priceFastTreeApproximatelyMaximumLikelihood2010" role="doc-biblioref">135</a></sup></span>. Sequence alignments have been used to study protein structure<span class="citation"><sup><a href="#ref-jumperHighlyAccurateProtein2021" role="doc-biblioref">136</a>,<a href="#ref-karplusPredictingProteinStructure1999" role="doc-biblioref">137</a> </sup></span> and function<span class="citation"><sup><a href="#ref-watsonPredictingProteinFunction2005" role="doc-biblioref">138</a>,<a href="#ref-leePredictingProteinFunction2007" role="doc-biblioref">139</a></sup></span>. They can be used to correct sequencing errors<span class="citation"><sup><a href="#ref-hacklProovreadLargescaleHighaccuracy2014" role="doc-biblioref">80</a>,<a href="#ref-korenHybridErrorCorrection2012" role="doc-biblioref">82</a>,<a href="#ref-salmelaCorrectingErrorsShort2011" role="doc-biblioref">140</a></sup></span> or detect structural variations in genomes<span class="citation"><sup><a href="#ref-medvedevComputationalMethodsDiscovering2009" role="doc-biblioref">141</a>,<a href="#ref-mahmoudStructuralVariantCalling2019" role="doc-biblioref">142</a></sup></span>. All this to say that they are absolutely fundamental to the field of computational biology and errors in alignments can lead to errors somewhere down the line.</p>
</div>
<div id="how-to-align-two-sequences" class="section level3 hasAnchor" number="2.1.2">
<h3><span class="header-section-number">2.1.2</span> How to align two sequences ?<a href="aligning-sequence-data.html#how-to-align-two-sequences" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<p>There are two approaches for pairwise alignment<span class="citation"><sup><a href="#ref-sungAlgorithmsBioinformaticsPractical2011" role="doc-biblioref">143</a></sup></span>: <em>global alignment</em> where the entirety of both sequences is used when aligning them, and <em>local alignment</em> where we only seek to find regions in each sequence that are most similar to each other. Global alignment is used when the two sequences are expected to be quite similar (e.g. comparing two related proteins), whereas local alignment is mostly used when we expect the sequences to be fairly different but with highly similar regions, like genomes of two distantly related species that share a highly conserved region.</p>
<p>The seminal method for global pairwise alignment was the Needleman-Wünsch algorithm<span class="citation"><sup><a href="#ref-needlemanGeneralMethodApplicable1970" role="doc-biblioref">144</a></sup></span> based on a dynamic programming method. A decade later, the Smith-Waterman algorithm<span class="citation"><sup><a href="#ref-smithIdentificationCommonMolecular1981" role="doc-biblioref">145</a></sup></span> was developed with similar ideas to perform local alignment. Both are still used today for pairwise alignment.</p>
<p>Dynamic programming is often used to solve complex problems by breaking it into smaller sub-problems and solving each one optimally and separately<span class="citation"><sup><a href="#ref-bradleyAppliedMathematicalProgramming1977" role="doc-biblioref">146</a>,<a href="#ref-bellmanTheoryDynamicProgramming1954" role="doc-biblioref">147</a></sup></span>, it is particularly useful when we wish to have a precise alignment between 2 sequences.</p>
<div id="global-alignment" class="section level4 hasAnchor" number="2.1.2.1">
<h4><span class="header-section-number">2.1.2.1</span> Global alignment<a href="aligning-sequence-data.html#global-alignment" class="anchor-section" aria-label="Anchor link to header"></a></h4>
<p>The fundamental algorithm for globally aligning two sequences was the Needleman-Wünsch (NW) algorithm<span class="citation"><sup><a href="#ref-needlemanGeneralMethodApplicable1970" role="doc-biblioref">144</a></sup></span>, this can be conceptualized in one of two equivalent ways: finding the alignment with 1) the lowest edit-distance or 2) the highest alignment score. These two are equivalent so in this section we will maximize the alignment score.</p>
<p>The first thing that is needed is, given an alignment, how to compute an alignment score. To do this we need to assign costs to each operation. Usually matches (i.e. aligning two identical characters) are given a positive cost and mismatches or indels a negative cost. If we assign a cost of +1 to a match and a cost of -1 to mismatches and indels then the alignment presented above in Section <a href="aligning-sequence-data.html#why-align">2.1.1</a> would have an alignment score of 9 - 2 = 7 <em>(9 matches and two indels)</em>.</p>
<p>The NW algorithm is based on a simple recurrence relation: the optimal alignment score of two sequences <span class="math inline">\(S_1\)</span> and <span class="math inline">\(S_2\)</span> of lengths <span class="math inline">\(n\)</span> and <span class="math inline">\(m\)</span> respectively is the maximum of:</p>
<ol style="list-style-type: decimal">
<li><p>The optimal alignment score of <span class="math inline">\(S_1[1,n-1]\)</span><a href="#fn4" class="footnote-ref" id="fnref4"><sup>4</sup></a> and <span class="math inline">\(S_2[1,m-1]\)</span> plus the cost of a match or mismatch between the <span class="math inline">\(n^{th}\)</span> character of <span class="math inline">\(S_1\)</span> and the <span class="math inline">\(m^{th}\)</span> character of <span class="math inline">\(S_2\)</span></p></li>
<li><p>The optimal alignment score of <span class="math inline">\(S_1\)</span> and <span class="math inline">\(S_2[1,m-1]\)</span> plus the cost of an indel</p></li>
<li><p>The optimal alignment score of <span class="math inline">\(S_1[1,n-1]\)</span> and <span class="math inline">\(S_2\)</span> plus the cost of an indel</p></li>
</ol>
<p>This simple relation can be used to compute optimal global alignment score for two sequences, however if it is implemented naively it can be very inefficient as the number of scores to compute grows exponentially with sequence lengths, and many intermediary alignment scores need to be computed many times. This is where dynamic programming comes in: these intermediary costs are pre-computed in an efficient manner and one can then deduce the optimal alignment from these. This pre-computing step is usually represented as filling out a matrix whose rows and columns represent the characters in each sequence to be aligned.</p>
<p>If <span class="math inline">\(S_1\)</span> represents the rows of the matrix, and <span class="math inline">\(S_2\)</span> the columns, the value <span class="math inline">\(C(i,j)\)</span> of a cell <span class="math inline">\((i,j)\)</span> of this matrix represents the optimal alignment score between <span class="math inline">\(S_1[1,i]\)</span> and <span class="math inline">\(S_2[1,j]\)</span>. In the recurrence relation described above the alignment score as dependant on the optimal alignment scores of subsequences, when filling out the dynamic programming matrix we proceed in the inverse fashion by using the scores of short subsequences to build up the scores of progressively longer sequences.</p>
<p>We will go here through a short example showing how the NW algorithm is used to align two short sequences: <span class="math inline">\(S_1=\)</span><code>ACCTGA</code> and <span class="math inline">\(S_2=\)</span><code>ACGGA</code>. The first step is to represent the dynamic programming matrix, prefix each sequence with an empty character and label the rows of the matrix with one of the sequences and the columns with the other <em>(this extra row and column at the beginning of each sequence are indexed as column and row 0)</em>. In this matrix, due to the recurrence relation stated above, the score of a particular cell, <span class="math inline">\(C(i,j)\)</span> is the maximum of:</p>
<ol style="list-style-type: decimal">
<li>The score in the diagonally adjacent cell <span class="math inline">\(C(i-1,j-1)\)</span> plus the cost of a match or mismatch between <span class="math inline">\(S_1[i]\)</span> and <span class="math inline">\(S_2[j]\)</span>.</li>
<li>The score of the cell to the left <span class="math inline">\(C(i,j-1)\)</span> plus the cost of an indel</li>
<li>The score of the cell on top <span class="math inline">\(C(i-1,j)\)</span> plus the cost of an indel</li>
</ol>
<p>Therefore in order to compute <span class="math inline">\(C(i,j)\)</span> we need to know the three values of <span class="math inline">\(C(i-1,j-1)\)</span>, <span class="math inline">\(C(i-1,j)\)</span> and <span class="math inline">\(C(i,j-1)\)</span>. This is the reason why we start with an extra column and row at the beginning of each sequence that we can fill out with the increasing costs of indels. In our case since the cost of an indel is -1, this row and column are filled out with decreasing relative integers, as can be seen in Figure <a href="aligning-sequence-data.html#fig:nwAlign">2.1</a>A.</p>
<p>From this starting point we can fill out the Dynamic programming matrix with all the alignment scores. To compute <span class="math inline">\(C(1,1)\)</span> we have three possible values:</p>
<ol style="list-style-type: decimal">
<li><span class="math inline">\(C(0,0)\)</span> plus the cost of a match between <span class="math inline">\(S_1[1]=A\)</span> and <span class="math inline">\(S_2[1]=A\)</span>: <span class="math inline">\(0+1=1\)</span></li>
<li><span class="math inline">\(C(0,1)\)</span> plus the cost of an indel: <span class="math inline">\(-1 -1 = -2\)</span></li>
<li><span class="math inline">\(C(0,1)\)</span> plus the cost of an indel: <span class="math inline">\(-1-1=-2\)</span></li>
</ol>
<p>By taking the maximum out of these three values we can fill out the matrix with <span class="math inline">\(C(1,1)=1\)</span>. By continuing this process until we fill out the whole we obtain the scores visible below. This is enough if we only want to compute the optimal global alignment score between <span class="math inline">\(S_1\)</span> and <span class="math inline">\(S_2\)</span>, however if we want to deduce the operations leading to alignment, and therefore the alignment itself, we need to keep track of which operation we made to get a specific score. The easiest way to do that is to also consider this matrix as a graph where each cell is a vertex. When we compute the score of cell <span class="math inline">\((i,j)\)</span> we add an edge from this cell to the previous cell that was used to compute <span class="math inline">\(C(i,j)\)</span>. In our example above, we obtained <span class="math inline">\(C(1,1)\)</span> from a match and <span class="math inline">\(C(0,0)\)</span>, so we can add an edge in our graph going from cell <span class="math inline">\((1,1)\)</span> to cell <span class="math inline">\((0,0)\)</span>. The filled out matrix with the graph edges represented as arrows can be seen in Figure <a href="aligning-sequence-data.html#fig:nwAlign">2.1</a>B.</p>
<div class="figure" style="text-align: center"><span style="display:block;" id="fig:nwAlign"></span>
<img src="figures/Align-Intro/NW-total.png" alt="**Example global alignment with the Needleman-Wunsch algorithm.**  
This figure represents three different steps in the NW algorithm, with a match cost of +1, a mismatch cost of -1 and an indel cost of -1. **A)** the matrix is initialized with $S_1$ as the columns and $S_2$ as the rows. Column and row 0 are filled out. **B)** The dynamic programming matrix is filled out, and the alignment graph is constructed. **C)** The alignment graph is traversed from the vertex in the bottom right cell to the vertex in the top left cell. Each of the three possible paths corresponds to an optimal global alignment, represented on the right." width="100%" />
<p class="caption">
Figure 2.1: <strong>Example global alignment with the Needleman-Wunsch algorithm.</strong><br />
This figure represents three different steps in the NW algorithm, with a match cost of +1, a mismatch cost of -1 and an indel cost of -1. <strong>A)</strong> the matrix is initialized with <span class="math inline">\(S_1\)</span> as the columns and <span class="math inline">\(S_2\)</span> as the rows. Column and row 0 are filled out. <strong>B)</strong> The dynamic programming matrix is filled out, and the alignment graph is constructed. <strong>C)</strong> The alignment graph is traversed from the vertex in the bottom right cell to the vertex in the top left cell. Each of the three possible paths corresponds to an optimal global alignment, represented on the right.
</p>
</div>
<p>Once this matrix <em>(and corresponding graph)</em> is filled out, we can deduce the alignment by following a path through the graph starting at cell <span class="math inline">\((n,m)\)</span> to cell <span class="math inline">\((0,0)\)</span>. A diagonal edge starting at <span class="math inline">\((i,j)\)</span> indicates a match or mismatch between <span class="math inline">\(S_1[i]\)</span> and <span class="math inline">\(S_2[j]\)</span>, a vertical edge indicates a gap in <span class="math inline">\(S_2\)</span> and a horizontal edge a gap in <span class="math inline">\(S_1\)</span>. This can lead to several optimal alignments if there are several such paths in the graph. In our case this algorithm yields three equally optimal global alignments shown in Figure <a href="aligning-sequence-data.html#fig:nwAlign">2.1</a>C.</p>
<p>This algorithm although guaranteed to result in an optimal alignment, has a time complexity of <span class="math inline">\(O(nm)\)</span> where <span class="math inline">\(n\)</span> and <span class="math inline">\(m\)</span> are the lengths of the sequences to align<span class="citation"><sup><a href="#ref-sungAlgorithmsBioinformaticsPractical2011" role="doc-biblioref">143</a></sup></span>. Some methods have been proposed to speed up<span class="citation"><sup><a href="#ref-masekFasterAlgorithmComputing1980" role="doc-biblioref">148</a></sup></span>, however the complexity is still <span class="math inline">\(O(nm/\log(n))\)</span>. Lower bounds have been studied and there is not much optimization to be done if optimal exact alignment are needed<span class="citation"><sup><a href="#ref-vinhInformationTheoreticMeasures2010" role="doc-biblioref">149</a>,<a href="#ref-ullmanBoundsComplexityLongest1976" role="doc-biblioref">150</a></sup></span>. If we want to do better we have to rely on heuristics.</p>
<p>Another issue is space complexity since we need to store the matrix, the space complexity is also <span class="math inline">\(O(nm)\)</span>. If we wish to align 2 human genomes we would need to store <span class="math inline">\(\approx 10^{19}\)</span> matrix cells, which would amount to 10 Exabytes of storage if we use 8bit integers <em>(i.e. the storage scale of a data-center)</em>. However, in practice, we can do much better than that, and construct an optimal alignment in linear space complexity <span class="math inline">\(O(n+m)\)</span><span class="citation"><sup><a href="#ref-hirschbergLinearSpaceAlgorithm1975" role="doc-biblioref">151</a></sup></span> meaning we would only need a couple gigabytes to store the matrix for 2 human genomes. This resulted in an improved global alignment algorithm, the Myers-Miller algorithm<span class="citation"><sup><a href="#ref-myersOptimalAlignmentsLinear1988" role="doc-biblioref">152</a></sup></span>, implemented in the EMBOSS stretcher alignment software<span class="citation"><sup><a href="#ref-riceEMBOSSEuropeanMolecular2000" role="doc-biblioref">153</a></sup></span>.</p>
</div>
<div id="local-alignment" class="section level4 hasAnchor" number="2.1.2.2">
<h4><span class="header-section-number">2.1.2.2</span> Local alignment<a href="aligning-sequence-data.html#local-alignment" class="anchor-section" aria-label="Anchor link to header"></a></h4>
<p>In global alignment two full sequences are aligned to each other. In local alignment the goal is to find the optimal alignment of two subsequences from these parent sequences. The main algorithm for locally aligning is the Smith-Waterman (SW) algorithm<span class="citation"><sup><a href="#ref-smithIdentificationCommonMolecular1981" role="doc-biblioref">145</a></sup></span> developed a decade later than NW.</p>
<p>The two algorithms are very similar, SW also relies on first building the dynamic programming matrix with the same parametrizable costs for matches, mismatches and indels as NW. One key difference is that the optimal scores in the matrix are bound by 0 so they cannot become negative, we only store edges in the alignment graph is the starting cell has an alignment score &gt; 0.</p>
<p>In this new formulation, the score in cell <span class="math inline">\(C(i,j)\)</span> is the maximum of the following values:</p>
<ol style="list-style-type: decimal">
<li>The score in the diagonally adjacent cell <span class="math inline">\(C(i-1,j-1)\)</span> plus the cost of a match or mismatch between <span class="math inline">\(S_1[i]\)</span> and <span class="math inline">\(S_2[j]\)</span>.</li>
<li>The score of the cell to the left <span class="math inline">\(C(i,j-1)\)</span> plus the cost of an indel.</li>
<li>The score of the cell on top <span class="math inline">\(C(i-1,j)\)</span> plus the cost of an indel.</li>
<li><span class="math inline">\(0\)</span>.</li>
</ol>
<p>If we use the SW algorithm to locally align the two example sequences <span class="math inline">\(S_1\)</span> and <span class="math inline">\(S_2\)</span> and the same costs as used above, we obtain the dynamic programming matrix and graph shown in Figure <a href="aligning-sequence-data.html#fig:swAlign">2.2</a>.</p>
<div class="figure" style="text-align: center"><span style="display:block;" id="fig:swAlign"></span>
<img src="figures/Align-Intro/SW-total.png" alt="**Example local alignment with the Smith-Waterman algorithm.**  
Two sequences $S_1$ and $S_2$ (the same as in Figure \@ref(fig:nwAlign)) are locally aligned. A match has a cost of +1, a mismatch a cost of -1 and indels a cost of -1. **A)** The dynamic programming matrix is filled out and the alignment graph constructed. Alignment scores are constrained to be non-negative. **B)** We find paths in the graph between the vertex with the maximal score and a score of 0. Here there are two such paths resulting in two optimal local alignments represented on the right. " width="60%" />
<p class="caption">
Figure 2.2: <strong>Example local alignment with the Smith-Waterman algorithm.</strong><br />
Two sequences <span class="math inline">\(S_1\)</span> and <span class="math inline">\(S_2\)</span> (the same as in Figure <a href="aligning-sequence-data.html#fig:nwAlign">2.1</a>) are locally aligned. A match has a cost of +1, a mismatch a cost of -1 and indels a cost of -1. <strong>A)</strong> The dynamic programming matrix is filled out and the alignment graph constructed. Alignment scores are constrained to be non-negative. <strong>B)</strong> We find paths in the graph between the vertex with the maximal score and a score of 0. Here there are two such paths resulting in two optimal local alignments represented on the right.
</p>
</div>
<p>The traceback part to determine the optimal alignment is very similar to NW, however instead of starting at cell <span class="math inline">\((n,m)\)</span>, we start at the cell in with the maximal alignment score and follow the path back until we arrive at a cell with an alignment score of 0. In the example shown in Figure <a href="aligning-sequence-data.html#fig:swAlign">2.2</a>, two cells contain the maximal alignment score of 2. Tracing back from these cells gives two optimal local alignments between <span class="math inline">\(S_1\)</span> and <span class="math inline">\(S_2\)</span>: <code>AC</code> to <code>AC</code> and <code>GA</code> to <code>GA</code>.</p>
<p>Since the SW algorithm is so similar to NW it has the same quadratic time and space complexity, however the same optimization can be used to bring it down to a linear space complexity<span class="citation"><sup><a href="#ref-sungAlgorithmsBioinformaticsPractical2011" role="doc-biblioref">143</a></sup></span>. Optimizations were resulted in the Huang and Miller algorithm<span class="citation"><sup><a href="#ref-huangTimeefficientLinearspaceLocal1991" role="doc-biblioref">154</a></sup></span> which is implemented in the EMBOSS Lalign tool<span class="citation"><sup><a href="#ref-riceEMBOSSEuropeanMolecular2000" role="doc-biblioref">153</a></sup></span>, and the Waterman Eggert algorithm<span class="citation"><sup><a href="#ref-watermanNewAlgorithmBest1987" role="doc-biblioref">155</a></sup></span>.</p>
<p>Both the NW and the SW algorithms are implemented in many different software tools and are used widely to perform pairwise alignments of short sequences<span class="citation"><sup><a href="#ref-riceEMBOSSEuropeanMolecular2000" role="doc-biblioref">153</a>,<a href="#ref-stajichBioperlToolkitPerl2002" role="doc-biblioref">156</a>,<a href="#ref-gentlemanBioconductorOpenSoftware2004" role="doc-biblioref">157</a></sup></span>. Some versions even benefit from hardware acceleration with version implemented for specific CPU instruction sets<span class="citation"><sup><a href="#ref-dailyParasailSIMDLibrary2016" role="doc-biblioref">158</a></sup></span> or GPUs<span class="citation"><sup><a href="#ref-frohmbergGPASImprovedVersion2012" role="doc-biblioref">159</a></sup></span> to substantially speed up alignment.</p>
</div>
</div>
<div id="scoring-and-substitution-models" class="section level3 hasAnchor" number="2.1.3">
<h3><span class="header-section-number">2.1.3</span> Scoring and substitution models<a href="aligning-sequence-data.html#scoring-and-substitution-models" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<p>In the examples used above to present the NW and SW algorithms, we used a very simple cost function: a match has a cost of +1 while mismatches and indels have a cost of -1. This is really the simplest cost function we can use but also the crudest. In many cases it may be interesting to infuse this cost function with biological knowledge. For example some substitutions might occur more rarely than others in nature so it would stand to reason to penalize those more than other, more common, substitutions.</p>
<p>These biology-aware cost functions usually take the form of a matrix, called scoring or substitution matrix corresponding to an underlying evolutionary model. When using these matrices, matches and mismatches between specific characters are given. For example the cost of aligning an A and a T might be lower than aligning that same A with a G. A lot of different substitution matrices have been developed especially for protein alignments<span class="citation"><sup><a href="#ref-altschulSubstitutionMatrices2013" role="doc-biblioref">160</a></sup></span>, developed with different techniques and underlying models and with different use-cases.</p>
<p>The earliest and simplest substitution matrices are match/mismatch matrices, they are effectively what we used above where all matches are given a fixed positive score and all mismatches a fixed negative score. In our examples above the corresponding substitution matrix would be a four by four matrix with ones on the diagonal indicating matches and -1 everywhere else. These are simple and useful however when dealing with proteins they have a severe limitation as they ignore the biology of amino acids.</p>
<p>In order to reflect this biological reality of proteins, new substitution matrices were developed using Log-odds models, based on the fact that substitutions in amino acids are not equiprobable, and some mutations between related amino acids <em>(e.g. I and L)</em> are much more common than others. Two of the most widely used substitution matrices, PAM and BLOSUM matrices, were built this way. The score for aligning residue <span class="math inline">\(i\)</span> with residue <span class="math inline">\(j\)</span> is given by the matrix entry <span class="math inline">\(s_{ij}\)</span> by looking at the background frequencies <em>(i.e. how often one expects to see a particular residue in a sequence)</em> of <span class="math inline">\(i\)</span> and <span class="math inline">\(j\)</span> denoted <span class="math inline">\(p_i\)</span> and <span class="math inline">\(p_j\)</span> respectively and the frequency <span class="math inline">\(q_{ij}\)</span> with which <span class="math inline">\(i\)</span> and <span class="math inline">\(j\)</span> are aligned in accurate biological alignments. from this we can compute the substitution score <span class="math inline">\(s_{ij}\)</span> as a Log-odds<span class="citation"><sup><a href="#ref-altschulSubstitutionMatrices2013" role="doc-biblioref">160</a></sup></span>:</p>
<p><span class="math display">\[
S_{i,j}=\log\bigg(\frac{q_{ij}}{p_ip_j}\bigg)
\]</span></p>
<p>This Log-odds formulation yields values with nice properties for sequence alignment. <span class="math inline">\(q_{ij}\)</span> can be thought of as the probability of the alignment between amino acids <span class="math inline">\(i\)</span> and <span class="math inline">\(j\)</span> resulting from a substitution, and <span class="math inline">\(p_ip_j\)</span> is the probability under the null hypothesis that both of these amino acids were aligned randomly. Therefore log of the ratio is negative when the random alignment is more frequent (meaning the substitution is unlikely), and positive when the substitution is likely. Both <span class="math inline">\(p_i\)</span> and <span class="math inline">\(p_j\)</span> are easy to compute from available biological sequence data, the real work in developing a Log-odds based substitution matrix is to estimate <span class="math inline">\(q_{ij}\)</span> values, and that is often done using biologically accurate protein sequence alignments.</p>
<p>The PAM matrix, developed in 1978<span class="citation"><sup><a href="#ref-dayhoffModelEvolutionaryChange1978" role="doc-biblioref">161</a></sup></span>, is one such matrix. A <em>Point accepted mutation</em> (PAM) is defined as the substitution of one amino acid by another that is accepted by natural selection <em>(i.e. visible along the branch of a phylogenetic tree)</em>. Dayhoff <em>et al.</em> also defined a PAM as an evolutionary distance, where two sequences distant by one PAM are expected to have one amino acid substitution per one hundred residues, which is equivalent to expecting a substitution at 1% of positions. To develop their matrix, Dayhoff <em>et al.</em> used phylogenetic trees built on 71 families of closely related proteins and counted the PAMs that appeared in these trees. This resulted in a matrix <span class="math inline">\(A\)</span> where <span class="math inline">\(A_{ij}=A_{ji}=\)</span> the number of times a substitution between amino acids <span class="math inline">\(i\)</span> and <span class="math inline">\(j\)</span> was observed in the trees. By using trees built on closely related sequences, Dayhoff <em>et al.</em> could be fairly certain that the observed substitutions were the result of a single mutation and not many subsequent mutations over long evolutionary times. From this matrix <span class="math inline">\(A\)</span>, Dayhoff <em>et al.</em> reconstructed the mutation probability <span class="math inline">\(M_1\)</span> where entries <span class="math inline">\(M_{1,ij}\)</span> represent the probability of amino acid <span class="math inline">\(j\)</span> being replaced by amino acid <span class="math inline">\(i\)</span> after an interval of 1 PAM. Entries of this matrix are computed as follows:</p>
<span class="math display">\[\begin{align}
M_{1,ij}&amp;=\frac{\lambda m_j A_{ij}}{\sum_i A_{ij}}\;\; &amp; \text{if}\;\;i\neq j\\
M_{1,ij}&amp;=1-\lambda m_j &amp; \text{if}\;\; i = j
\end{align}\]</span>
<p>here <span class="math inline">\(m_j\)</span> is the observed mutability of amino acid <span class="math inline">\(j\)</span>, and <span class="math inline">\(\lambda\)</span> is a constant factor used to tune the matrix so that it reflects mutation rates corresponding to 1 PAM where 99% of positions are unchanged which means that the diagonal of <span class="math inline">\(M_1\)</span> must sum to 0.99. By assuming that evolution follows a Markov process it is simple to derive the mutation matrices for sequences separated by greater evolutionary distances. The <span class="math inline">\(M_n\)</span> matrix, corresponding to a distance of <span class="math inline">\(n\)</span> PAMs is equal to <span class="math inline">\(M_1^n\)</span>. Finally the <span class="math inline">\(q_{ij}\)</span> values can be derived with <span class="math inline">\(q_ij=p_jM_{ij}\)</span>. By choosing different values of <span class="math inline">\(n\)</span> for the mutation matrix we can estimate scoring matrices for sequences that are at varying evolutionary distances from one another. The correspondence between PAMs and and the observed proportion of diferent residues is not one to one, therefore a distance of 250 PAMs corresponds to around only about 20% of identical residues where a distance of 180 PAMs corresponds to around 27% identical residuess<span class="citation"><sup><a href="#ref-altschulSubstitutionMatrices2013" role="doc-biblioref">160</a>,<a href="#ref-dayhoffModelEvolutionaryChange1978" role="doc-biblioref">161</a></sup></span>. Therefore the PAM<sub>250</sub> matrix, derived from <span class="math inline">\(M_{250}\)</span>, is suited to align more distantely related proteins than the PAM<sub>180</sub> for example. By changing the mathematical model underlying the estimate of mutation probabilities, PAM-like matrices<span class="citation"><sup><a href="#ref-mullerModelingAminoAcid2000" role="doc-biblioref">162</a></sup></span> were later developed based on the same principles.</p>
<p>The other main type of substitution matrix are the BLOSUM matrices (Block Substitution matrix), developed in 1992<span class="citation"><sup><a href="#ref-henikoffAminoAcidSubstitution1992" role="doc-biblioref">163</a></sup></span>. Instead of using whole, closely-related, protein sequences like the PAM matrices, the values of <span class="math inline">\(q_{ij}\)</span> were estimated on highly conserved segments, called <em>blocks</em>, across whole protein families. The <span class="math inline">\(q_{ij}\)</span> values are then estimated as the number of time amino acids <span class="math inline">\(i\)</span> and <span class="math inline">\(j\)</span> are aligned divided by the number of total amino acid pairs in the alignment. Therefore <span class="math inline">\(q_{ij}\)</span> is the observed frequency of the aligned pair of amino acids <span class="math inline">\(i\)</span> and <span class="math inline">\(j\)</span> in all the conserved blocks. Like with PAM matrices, several BLOSUM matrices were constructed adapted for aligning sequences with different evolutionary distances. The BLOSUM62 matrix was estimated on blocks in aligned sequences that are at most 62% identical, BLOSUM80 on sequences that ar at most 80% identical. Therefore, inversely to the PAM matrices, the higher the number of the BLOSUM matrix the more suited it is to align more closely related sequences.</p>
<p>PAM and BLOSUM matrices have fairly broad use-cases and are widely used in alignment, however there exist many other protein substitution models. Instead of using log-odds, some substitution models were developed by estimating scores with maximum-likelihood approaches<span class="citation"><sup><a href="#ref-whelanGeneralEmpiricalModel2001" role="doc-biblioref">164</a>,<a href="#ref-leImprovedGeneralAmino2008" role="doc-biblioref">165</a></sup></span>. Some matrices were developed with very specific usage conditions in mind. Some are tailored to specific types of proteins like Transmembrane<span class="citation"><sup><a href="#ref-mullerNonsymmetricScoreMatrices2001" role="doc-biblioref">166</a>,<a href="#ref-ngPHATTransmembranespecificSubstitution2000" role="doc-biblioref">167</a></sup></span>, disordered<span class="citation"><sup><a href="#ref-trivediAminoAcidSubstitution2019" role="doc-biblioref">168</a></sup></span> or polar/non-polar<span class="citation"><sup><a href="#ref-goonesekereContextspecificAminoAcid2008" role="doc-biblioref">169</a></sup></span> proteins. Some matrices were developed to align sequences from specific organisms like <em>P. falciparum</em><span class="citation"><sup><a href="#ref-pailaGenomeBiasInfluences2008" role="doc-biblioref">170</a></sup></span> <em>(responsible for malaria)</em> or HIV<span class="citation"><sup><a href="#ref-nickleHIVSpecificProbabilisticModels2007" role="doc-biblioref">171</a></sup></span>. A substitution matrix was even developed in 2005 specifically for global rather than local alignment<span class="citation"><sup><a href="#ref-sardiuScoreStatisticsGlobal2005" role="doc-biblioref">172</a></sup></span>.</p>
<p>This wealth of protein substitution matrices reflects the biological and evolutionary diversity of proteins, however substitution matrices for aligning DNA sequences are much less frequent. Some work has been done to derive matrices similar to PAM matrices from DNA alignments<span class="citation"><sup><a href="#ref-chiaromonteScoringPairwiseGenomic2001" role="doc-biblioref">173</a></sup></span>. Codon substitution matrices<span class="citation"><sup><a href="#ref-schneiderEmpiricalCodonSubstitution2005" role="doc-biblioref">174</a>,<a href="#ref-doron-faigenboimCombinedEmpiricalMechanistic2007" role="doc-biblioref">175</a></sup></span> have been developed as well, although they are used in DNA sequence alignment, ultimately they use knowledge derived from protein alignments.</p>
</div>
<div id="dealing-with-gaps" class="section level3 hasAnchor" number="2.1.4">
<h3><span class="header-section-number">2.1.4</span> Dealing with gaps<a href="aligning-sequence-data.html#dealing-with-gaps" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<p>In the NW and SW examples of Section <a href="aligning-sequence-data.html#how-to-align-two-sequences">2.1.2</a>, as with the simplistic match/mismatch costs, we used a very simple cost of insertions and deletions: any indel has a cost of -1. However this, as was the case with substitutions, does not reflect the biological reality very well.</p>
<p>In biology, when insertions or deletions occur it is more likely that the indel will span several nucleotides rather than just one<span class="citation"><sup><a href="#ref-cartwrightProblemsSolutionsEstimating2009" role="doc-biblioref">176</a></sup></span>. This means that when inserting gaps into longer gap stretches are more likely than many individual gaps. For example the two alignments below have the same number of matches, mismatches and gaps. The second one is more likely since it is the result of a single insertion (or deletion) of <code>AGGT</code> rather than multiple independent indels.</p>
<center>
<div class="line-block"><strong><code>AGGAGGTTCG</code></strong>        <strong><code>AGGAGGTTCG</code></strong><br />
<strong><code>A-G-G-T-CC</code></strong>        <strong><code>AGG----TCC</code></strong></div>
</center>
<p>The first approach was to try and optimize the gaps more generally<span class="citation"><sup><a href="#ref-fitchOptimalSequenceAlignments1983" role="doc-biblioref">177</a></sup></span> over the whole aligned sequence, however even with dynamic programming this has at best a time complexity of <span class="math inline">\(o(n^2m)\)</span><span class="citation"><sup><a href="#ref-watermanBiologicalSequenceMetrics1976" role="doc-biblioref">178</a></sup></span>. In 1982, Gotoh proposed affine gap costs<span class="citation"><sup><a href="#ref-gotohImprovedAlgorithmMatching1982" role="doc-biblioref">179</a></sup></span>, with this model there are two separate costs associated to indels: 1) the gap open cost and 2) the gap extend cost. Usually the costs are set up so that opening a new gap is more costly than extending it, meaning that longer gap stretches are favored over many short indels. The other major advantage is that with Gotoh’s algorithm time complexity is back down to <span class="math inline">\(o(nm)\)</span>. The algorithm was further refined by Altschul <em>et al.</em><span class="citation"><sup><a href="#ref-altschulOptimalSequenceAlignment1986" role="doc-biblioref">180</a></sup></span>.</p>
<p>Over the years different types of gap costs were developed and tested like the logarithmic gap costs proposed by Waterman<span class="citation"><sup><a href="#ref-watermanEfficientSequenceAlignment1984" role="doc-biblioref">181</a></sup></span> and improved by Miller and Myers<span class="citation"><sup><a href="#ref-millerSequenceComparisonConcave1988" role="doc-biblioref">182</a></sup></span> turned out to be less accurate than affine gap costs<span class="citation"><sup><a href="#ref-cartwrightLogarithmicGapCosts2006" role="doc-biblioref">183</a></sup></span>). A bi-linear gap cost was also proposed to replace the affine cost<span class="citation"><sup><a href="#ref-goonesekereFrequencyGapsObserved2004" role="doc-biblioref">184</a></sup></span>, with a breakpoint at gaps of length three, the size of a codon. As more and more sequence data became available, similarly to what happened with substitution matrices, empirical profile-based models derived from this data were developed<span class="citation"><sup><a href="#ref-bennerEmpiricalStructuralModels1993" role="doc-biblioref">185</a></sup></span>. Some of these penalties leverage structural information and context for proteins<span class="citation"><sup><a href="#ref-wrablGapsStructurallySimilar2004" role="doc-biblioref">186</a>,<a href="#ref-zhangSP5ImprovingProtein2008" role="doc-biblioref">187</a></sup></span>. A context dependent gap penalty depending on the hydrophobicity of aligned residues is implemented in Clustal X<span class="citation"><sup><a href="#ref-jeanmouginMultipleSequenceAlignment1998" role="doc-biblioref">188</a></sup></span> one of the most widely used sequence aligners. Although quite complex and empirically derived, these profile-based penalties show limited improvement over the affine and bi-linear penalties<span class="citation"><sup><a href="#ref-wangComparisonLinearGap2011" role="doc-biblioref">189</a></sup></span>.</p>
<p>More recently, methodological and algorithmic developments have resulted in the WaveFront algorithm (WFA) for pairwise alignment<span class="citation"><sup><a href="#ref-marco-solaFastGapaffinePairwise2020" role="doc-biblioref">190</a></sup></span>. This algorithm computes a NW alignment with affine gap costs with a much lower time complexity of <span class="math inline">\(o(ns)\)</span>, where <span class="math inline">\(s\)</span> is the alignment score, reducing the quadratic relationship to sequence length to a linear one. This algorithm is also easily vectorizable and can take advantage of hardware acceleration, making its implementation run between 10 to 300 times faster than alternative methods depending on the testing context<span class="citation"><sup><a href="#ref-marco-solaFastGapaffinePairwise2020" role="doc-biblioref">190</a></sup></span>.</p>
</div>
</div>
<div id="how-do-we-speed-up-pairwise-alignment" class="section level2 hasAnchor" number="2.2">
<h2><span class="header-section-number">2.2</span> How do we speed up pairwise alignment ?<a href="aligning-sequence-data.html#how-do-we-speed-up-pairwise-alignment" class="anchor-section" aria-label="Anchor link to header"></a></h2>
<p>The NW and SW algorithms, as well as their improvements, are proven to be optimal<span class="citation"><sup><a href="#ref-pearson27DynamicProgramming1992" role="doc-biblioref">191</a></sup></span>. However when dealing with large sequences, which are more and more common, or when having to do many pairwise alignments they become limiting due to their time and space complexity. In many cases, to get around these limitations, optimality was left aside in favor of heuristics and approximate methods speeding up alignment.</p>
<div id="changing-the-method" class="section level3 hasAnchor" number="2.2.1">
<h3><span class="header-section-number">2.2.1</span> Changing the method<a href="aligning-sequence-data.html#changing-the-method" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<p>One of the early approaches to speed up alignment was to focus on speeding up the dynamic programming which is the time and space consuming step of the NW and SW algorithms. Bounded dynamic programming<span class="citation"><sup><a href="#ref-spougeSpeedingDynamicProgramming1989a" role="doc-biblioref">192</a></sup></span> is one such approach. By making the assumption that the majority of alignment operations are matches and mismatches instead of indels we can make the hypothesis about the alignment graph. Most probably, the path in the graph corresponding to the optimal alignment will be around the diagonal of the dynamic programming matrix, and scores far away from the diagonal are probably not needed. By making these assumptions a lot of the scores of the matrix do not need to be computed, speeding up the execution and leading to a sparse dynamic programming matrix (shown in Figure <a href="aligning-sequence-data.html#fig:boundedDP">2.3</a>). This approach was used to speed up alignment early on in 1984<span class="citation"><sup><a href="#ref-fickettFastOptimalAlignment1984" role="doc-biblioref">193</a></sup></span>. The advantage of this method is that the optimal alignment can be found very efficiently, however if there are many indels in the optimal alignment, this algorithm is not guaranteed to run faster than NW.</p>
<div class="figure" style="text-align: center"><span style="display:block;" id="fig:boundedDP"></span>
<img src="figures/Align-Intro/boundedDP.png" alt="**Bounded dynamic programming to speed up alignment.**  
The dynamic programming matrix is shown here, only values in the blue section are computed, speeding up the process. Here the optimal path in the alignment graph, shown in red, is included entirely in the bounds.
Adapted from [@chaoDevelopmentsAlgorithmsSequence2022]." width="50%" />
<p class="caption">
Figure 2.3: <strong>Bounded dynamic programming to speed up alignment.</strong><br />
The dynamic programming matrix is shown here, only values in the blue section are computed, speeding up the process. Here the optimal path in the alignment graph, shown in red, is included entirely in the bounds.
Adapted from<span class="citation"><sup><a href="#ref-chaoDevelopmentsAlgorithmsSequence2022" role="doc-biblioref">194</a></sup></span>.
</p>
</div>
<p>More “exotic” methods have also been used successfully for sequence alignment. Fast Fourier Transform (FFT) are used in the MAFFT aligner<span class="citation"><sup><a href="#ref-katohMAFFTNovelMethod2002" role="doc-biblioref">195</a></sup></span> in order to quickly find homologous segments between two sequences. These homologous regions can be used as the basis for alignment. MAFFT, primarily a multiple sequence aligner <em>(c.f. Section</em> <a href="aligning-sequence-data.html#multiple-sequence-alignment">2.4</a> <em>below)</em>, can also be used for pairwise alignment.</p>
</div>
<div id="seed-and-extend-with-data-structures" class="section level3 hasAnchor" number="2.2.2">
<h3><span class="header-section-number">2.2.2</span> Seed and extend with data structures<a href="aligning-sequence-data.html#seed-and-extend-with-data-structures" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<p>In parallel to the development of new alignment algorithms, another way of substantially speeding up pairwise alignment is the so-called “seed and extend” method. This is based on the observation that a pairwise alignment most likely has several short subsequences that are almost identical in both sequences to align. These homologous subsequences, the seeds, can be used to initialize an alignment that can be extended in both directions with dynamic programming until we have a suitable alignment.</p>
<p>This method can be used for 1) local alignment, where seeds indicate possible local matches which can be extended in local alignments; or 2) for global alignment where the seeds anchor the dynamic programming matrix, limiting the number of cells to fill out as shown in Figure <a href="aligning-sequence-data.html#fig:anchor">2.4</a>. In both cases this approach follows the divide and conquer philosophy and extending seeds or filling out the matrix between anchors can be done independently and in parallel.</p>
<div class="figure" style="text-align: center"><span style="display:block;" id="fig:anchor"></span>
<img src="figures/Align-Intro/anchors.png" alt="**Divide and conquer to speed up alignment.**  
Here anchors are used to speed up alignment. Anchors are shown as dark blue dots in the dynamic programing matrix. Only values in blocks between anchors, shown in blue, need to be computed. The majority of the matrix can be left empty. The optimal path in the resulting alignment graph must go through each anchor and is shown in red.
Adapted from [@chaoDevelopmentsAlgorithmsSequence2022]." width="50%" />
<p class="caption">
Figure 2.4: <strong>Divide and conquer to speed up alignment.</strong><br />
Here anchors are used to speed up alignment. Anchors are shown as dark blue dots in the dynamic programing matrix. Only values in blocks between anchors, shown in blue, need to be computed. The majority of the matrix can be left empty. The optimal path in the resulting alignment graph must go through each anchor and is shown in red.
Adapted from<span class="citation"><sup><a href="#ref-chaoDevelopmentsAlgorithmsSequence2022" role="doc-biblioref">194</a></sup></span>.
</p>
</div>
<p>This type of approach can also be used for many-to-one local alignments: either trying to find homologies between a query sequence and a database of sequences, or find several local alignments in a large reference sequence like in read-mapping (see Section <a href="aligning-sequence-data.html#what-is-read-mapping">2.3.1</a>). In these many-to-one scenarios it is useful to index seeds in data structures that allow rapid querying and compact storage. This general framework has proven to be quite flexible with many different ways to pick seeds<span class="citation"><sup><a href="#ref-sunChoosingBestHeuristic2006" role="doc-biblioref">196</a></sup></span> and many different data structures to index them<span class="citation"><sup><a href="#ref-liSurveySequenceAlignment2010" role="doc-biblioref">197</a></sup></span>.</p>
<div id="k-mers-and-hash-tables" class="section level4 hasAnchor" number="2.2.2.1">
<h4><span class="header-section-number">2.2.2.1</span> <span class="math inline">\(k\)</span>-mers and hash tables<a href="aligning-sequence-data.html#k-mers-and-hash-tables" class="anchor-section" aria-label="Anchor link to header"></a></h4>
<div id="the-blast-algorithm" class="section level5 hasAnchor" number="2.2.2.1.1">
<h5><span class="header-section-number">2.2.2.1.1</span> The BLAST Algorithm<a href="aligning-sequence-data.html#the-blast-algorithm" class="anchor-section" aria-label="Anchor link to header"></a></h5>
<p>One of the early methods for very quick heuristic alignment is the Basic Local Alignment Search Tool, BLAST<span class="citation"><sup><a href="#ref-altschulBasicLocalAlignment1990" role="doc-biblioref">198</a></sup></span>. It is widely used to this day to find homologous sequences in large databases and as such is one of the most cited papers of all time with over 100,000 citations, and is available as a web service hosted by the NCBI (<a href="https://blast.ncbi.nlm.nih.gov/Blast.cgi" class="uri">https://blast.ncbi.nlm.nih.gov/Blast.cgi</a>). Over the year many different versions for different use cases have been developed like BLASTP for protein sequences or BLASTN and MEGABLAST for nucleic acid sequences.</p>
<p>In our description of the BLAST algorithm we will have a target sequence and a query sequence that we wish to align.</p>
<ol style="list-style-type: decimal">
<li>For each sequence we build a hash table that uses subsequences of length <span class="math inline">\(k\)</span>, called <span class="math inline">\(k\)</span><em>-mers</em>, as keys and their position in the whole sequence as values.</li>
<li>The hash tables are then scanned to check for exact matches between <span class="math inline">\(k\)</span>-mers in the target and query sequences, called <em>hits.</em></li>
<li>The positions of the hits in the target and query sequences are used to seed a candidate local alignment</li>
<li>The candidate local alignment are extended in both directions from the seed with the SW algorithm. If the alignment score reaches a value under a specified threshold, the alignment stop and the candidate is discarded</li>
</ol>
<p>By selecting the right size <span class="math inline">\(k\)</span> of the seeds (by default 11 when aligning nucleotides, 3 when aligning amino acids) as well as the alignment score threshold, one can adjust the sensitivity of the method at the cost of runtime.</p>
<p>It might not seem very useful to precompute the target hash-table for a single target. However, in practice BLAST is used to find local alignments between a query sequence and a very large number of target sequences; databases hosted by NCBI have hundreds of millions of target sequences (<a href="https://ftp.ncbi.nlm.nih.gov/blast/db/" class="uri">https://ftp.ncbi.nlm.nih.gov/blast/db/</a>), at these scales pre-computing the target database saves an enormous amount of time.</p>
<p>Over time, several improvements have been developed for BLAST, PSI-BLAST<span class="citation"><sup><a href="#ref-altschulGappedBLASTPSIBLAST1997" role="doc-biblioref">199</a></sup></span> iteratively refines the alignments, Gapped BLAST<span class="citation"><sup><a href="#ref-altschulGappedBLASTPSIBLAST1997" role="doc-biblioref">199</a></sup></span>and BLASTZ<span class="citation"><sup><a href="#ref-schwartzHumanMouseAlignments2003" role="doc-biblioref">200</a></sup></span> use spaced seeds, introduced in the PatternHunter method<span class="citation"><sup><a href="#ref-maPatternHunterFasterMore2002" role="doc-biblioref">201</a></sup></span>, corresponding to seeds where not all characters match, increasing sensitivity. By sorting the target sequences it is possible to stop earlier and gain some speed as well<span class="citation"><sup><a href="#ref-edgarSearchClusteringOrders2010" role="doc-biblioref">202</a></sup></span>. The Diamond aligner<span class="citation"><sup><a href="#ref-buchfinkFastSensitiveProtein2015" role="doc-biblioref">203</a></sup></span> increase alignment speed by using double indexing and thus leveraging CPU cache and reducing time waiting for memory or disk access, improving alignment speed up to 360-fold over BLAST in later version<span class="citation"><sup><a href="#ref-buchfinkSensitiveProteinAlignments2021" role="doc-biblioref">204</a></sup></span>.</p>
<p>FASTA<span class="citation"><sup><a href="#ref-pearsonImprovedToolsBiological1988" role="doc-biblioref">205</a></sup></span>, an improvement on FASTP<span class="citation"><sup><a href="#ref-lipmanRapidSensitiveProtein1985" role="doc-biblioref">206</a></sup></span>, is another method for local alignment. Similarly to BLAST, <span class="math inline">\(k\)</span>-mers for the target and query sequence are indexed in a hash table and hits are found between the two sequences. The <span class="math inline">\(k\)</span>-mers used in the FASTA tool are usually shorter than for BLAST, so instead of initializing an alignment at a single hit, FASTA identifies regions in both sequences that have a high density of hits, keeping the best 10. These regions are then scored using matrices discussed in Section <a href="aligning-sequence-data.html#scoring-and-substitution-models">2.1.3</a> and high scoring regions are combined to build an approximate alignment. An optimal version of this alignment is then computed using the SW algorithm and banded dynamic programming.</p>
<p>Both FASTA and BLAST are very fast, it takes only a couple of seconds to find approximate local alignments between 100 query sequences<span class="citation"><sup><a href="#ref-saripellaBenchmarkingNextGeneration2016" role="doc-biblioref">207</a></sup></span> in a database of over 80 million target sequences<span class="citation"><sup><a href="#ref-finnPfamProteinFamilies2016" role="doc-biblioref">208</a></sup></span>. Trying this task with standard SW or NW algorithms would be much slower<span class="citation"><sup><a href="#ref-essoussiComparisonFourPairwise2007" role="doc-biblioref">209</a></sup></span> but would yield more sensitive, optimal alignments<span class="citation"><sup><a href="#ref-shpaerSensitivitySelectivityProtein1996" role="doc-biblioref">210</a></sup></span>.</p>
</div>
<div id="other-algorithms" class="section level5 hasAnchor" number="2.2.2.1.2">
<h5><span class="header-section-number">2.2.2.1.2</span> Other Algorithms<a href="aligning-sequence-data.html#other-algorithms" class="anchor-section" aria-label="Anchor link to header"></a></h5>
<p>One of the problems with such an approach is the size of the index, indeed storing all the <span class="math inline">\(k\)</span>-mers of a length <span class="math inline">\(n\)</span> sequence would require a maximum of <span class="math inline">\((n-k + 1)\cdot k\)</span> characters as the hash table keys, if all <span class="math inline">\(k\)</span>-mers are distinct. This space constraint is acceptable for very large scale homology search on hosted web services such as NCBI BLAST, however on a personal computer this can easily exceed memory capacity. Storing the hash table on disk has drastic consequences on query times, therefore methods to reduce the storage needs of these data structures were developed.</p>
<p>One of the ways to make everything fit in memory is to not store all <span class="math inline">\(k\)</span>-mers, one way is through the use of so-called minimizers, introduced independently in 2003<span class="citation"><sup><a href="#ref-schleimerWinnowingLocalAlgorithms2003" role="doc-biblioref">211</a></sup></span> and 2004<span class="citation"><sup><a href="#ref-robertsReducingStorageRequirements2004" role="doc-biblioref">212</a></sup></span>. Given a window of <span class="math inline">\(w\)</span> consecutive <span class="math inline">\(k\)</span>-mers and an ordering, a <span class="math inline">\((w,k)\)</span> minimizer is the “smallest” k-mer in the window w.r.t. the chosen ordering. Let us consider the following window of <span class="math inline">\(3\)</span>-mers with <span class="math inline">\(w=4\)</span>: <code>TGACAT</code>, yielding the following <span class="math inline">\(3\)</span>-mers: <code>TGA</code>, <code>GAC</code>, <code>ACA</code>, <code>CAT</code>. Following a simple ordering, such as lexigographical ordering (i.e. alphabetical order), then the “smallest” <span class="math inline">\(3\)</span>-mer and our <span class="math inline">\((4,3)\)</span> minimizer would be <code>ACA</code>, and only this one would be sampled and added to our hash table. Minimizers have interesting properties, adjacent windows often share a minimizer (see Figure <a href="aligning-sequence-data.html#fig:minimizers">2.5</a>) and if two strings have a <span class="math inline">\(w-k+1\)</span> sequence in common then they are guaranteed to share a <span class="math inline">\((w,k)\)</span> minimizer<span class="citation"><sup><a href="#ref-robertsReducingStorageRequirements2004" role="doc-biblioref">212</a></sup></span>. These properties make minimizers very useful for the seed and extend alignment strategy and they are used in several aligners such as Minimap<span class="citation"><sup><a href="#ref-liMinimapMiniasmFast2016" role="doc-biblioref">213</a></sup></span> and Minimap2<span class="citation"><sup><a href="#ref-liMinimap2PairwiseAlignment2018" role="doc-biblioref">118</a></sup></span>, MashMap2<span class="citation"><sup><a href="#ref-jainFastAdaptiveAlgorithm2018" role="doc-biblioref">214</a></sup></span> and Winnowmap<span class="citation"><sup><a href="#ref-jainWeightedMinimizerSampling2020" role="doc-biblioref">119</a></sup></span>.</p>
<div class="figure" style="text-align: center"><span style="display:block;" id="fig:minimizers"></span>
<img src="figures/Align-Intro/minimizers.png" alt="**$k$-mer minimizers in action.**  
**A**) The $3$-mers are shown under a window of size $w=4$ $k$-mers. The $(4,3)$ minimizer according to the lexicographical ordering is highlighted in red. **B)** All the $w=4$ windows of $3$-mers are shown underneath the sequence. $(4,3)$ minimizers of each window are highlighted in red. Here both $3$-mer minimizer is shared by 4 windows. Adapted from [@robertsReducingStorageRequirements2004]." width="70%" />
<p class="caption">
Figure 2.5: <strong><span class="math inline">\(k\)</span>-mer minimizers in action.</strong><br />
<strong>A</strong>) The <span class="math inline">\(3\)</span>-mers are shown under a window of size <span class="math inline">\(w=4\)</span> <span class="math inline">\(k\)</span>-mers. The <span class="math inline">\((4,3)\)</span> minimizer according to the lexicographical ordering is highlighted in red. <strong>B)</strong> All the <span class="math inline">\(w=4\)</span> windows of <span class="math inline">\(3\)</span>-mers are shown underneath the sequence. <span class="math inline">\((4,3)\)</span> minimizers of each window are highlighted in red. Here both <span class="math inline">\(3\)</span>-mer minimizer is shared by 4 windows. Adapted from<span class="citation"><sup><a href="#ref-robertsReducingStorageRequirements2004" role="doc-biblioref">212</a></sup></span>.
</p>
</div>
<p>While the lexicographical ordering is easy to conceptualize, and the one proposed intially by Roberts <em>et al.</em> it has an undesirable characteristic: it tends to select simpler kmers with repeated <code>A</code> at the beginning. As discussed in Section <a href="what-is-sequence-data.html#homopolymers-and-long-reads">1.4.2</a>, repeated stretches of nucleotides are prone to sequencing errors and as such are not ideal for seeding alignments. Furthermore, when the window shifts <span class="math inline">\(k\)</span>-mers at the beginning of successive are likely to be selected as minimizers without being shared between windows, meaning that we sample more <span class="math inline">\(k\)</span>-mers than needed. Roberts <em>et al.</em> proposed an alternative ordering based on nucleotide frequencies<span class="citation"><sup><a href="#ref-robertsReducingStorageRequirements2004" role="doc-biblioref">212</a></sup></span>, however this is also not ideal. Different orderings have been studied and those based on universal hitting sets<span class="citation"><sup><a href="#ref-orensteinCompactUniversalKmer2016" role="doc-biblioref">215</a></sup></span>, or random orderings (such as the ones defined by a hash function) have more desirable properties than the lexicographical ordering<span class="citation"><sup><a href="#ref-marcaisImprovingPerformanceMinimizers2017" role="doc-biblioref">216</a></sup></span>. A minimizer ordering based on frequency of appearance of kmers has been shown to provide well-balanced partitioning of k-mer sets<span class="citation"><sup><a href="#ref-chikhiRepresentationBruijnGraphs2014" role="doc-biblioref">217</a></sup></span>.</p>
<p>Over the years more strategies have been developed to sample <span class="math inline">\(k\)</span>-mers and reduce the data structure size for efficient sequence alignement, such as syncmers<span class="citation"><sup><a href="#ref-edgarSyncmersAreMore2021" role="doc-biblioref">218</a></sup></span>, strobemers<span class="citation"><sup><a href="#ref-sahlinEffectiveSequenceSimilarity2021" role="doc-biblioref">219</a></sup></span> or a combination of both<span class="citation"><sup><a href="#ref-sahlinFlexibleSeedSize2022" role="doc-biblioref">220</a></sup></span>. These novel seed sampling strategies allow for sparser seed sampling, smaller data structures and therefore faster alignment software.</p>
</div>
</div>
<div id="exact-matches-and-suffix-trees" class="section level4 hasAnchor" number="2.2.2.2">
<h4><span class="header-section-number">2.2.2.2</span> Exact matches and suffix trees<a href="aligning-sequence-data.html#exact-matches-and-suffix-trees" class="anchor-section" aria-label="Anchor link to header"></a></h4>
<p>While <span class="math inline">\(k\)</span>-mer seeds have shown success it is not the only way to implement a seed and extend alignment method. The other way to seed alignments is through maximal exact matches (MEMs) which is the longest possible exact match between two sequences. MEMs can be found with data structures like suffix trees<span class="citation"><sup><a href="#ref-weinerLinearPatternMatching1973" role="doc-biblioref">221</a></sup></span>, suffix arrays<span class="citation"><sup><a href="#ref-manberSuffixArraysNew1993" role="doc-biblioref">222</a>,<a href="#ref-abouelhodaEnhancedSuffixArray2002" role="doc-biblioref">223</a></sup></span> or FM indices<span class="citation"><sup><a href="#ref-ferraginaOpportunisticDataStructures2000" role="doc-biblioref">224</a></sup></span>.</p>
<p>Suffix trees have long been used for pattern matching applications<span class="citation"><sup><a href="#ref-gusfieldAlgorithmsStringsTrees1997" role="doc-biblioref">128</a></sup></span>, the AVID aligner<span class="citation"><sup><a href="#ref-brayAVIDGlobalAlignment2003" role="doc-biblioref">225</a></sup></span> uses them to find maximal exact matches between two sequences to anchor a global alignment. MUMmer2<span class="citation"><sup><a href="#ref-delcherFastAlgorithmsLargescale2002" role="doc-biblioref">226</a></sup></span> uses suffix trees to find unique maximal unique matches (MUMs) to anchor alignments.</p>
<p>Suffix trees, although very useful, have quadratic space complexity w.r.t. to the length of the indexed sequence<span class="citation"><sup><a href="#ref-gusfieldAlgorithmsStringsTrees1997" role="doc-biblioref">128</a></sup></span>. This is fine for small bacterial or viral genomes, however in the age of whole genome sequencing and the human genome project it is inadequate. Therefore some aligners have switched data structures to use suffix arrays, in fact it is possible to replace suffix trees with these more space efficient suffix arrays in any algorithm<span class="citation"><sup><a href="#ref-abouelhodaReplacingSuffixTrees2004" role="doc-biblioref">227</a></sup></span>. Newer versions of MUMmer<span class="citation"><sup><a href="#ref-marcaisMUMmer4FastVersatile2018" role="doc-biblioref">228</a></sup></span> have made this choice and now use suffix arrays for improved performance.</p>
<p>Finally another data structure that is widely used is the so-called FM index proposed in 2000<span class="citation"><sup><a href="#ref-ferraginaOpportunisticDataStructures2000" role="doc-biblioref">224</a></sup></span> and based on the Burrows-Wheeler transform<span class="citation"><sup><a href="#ref-burrowsBlockSortingLosslessData1994" role="doc-biblioref">229</a></sup></span>. The FM index is very memory efficient<span class="citation"><sup><a href="#ref-vyvermanProspectsLimitationsFulltext2012" role="doc-biblioref">230</a></sup></span>. This comes at the cost of some efficiency in index lookup operations, although some work has been done to improve this<span class="citation"><sup><a href="#ref-chengFMtreeFastLocating2018" role="doc-biblioref">231</a></sup></span>. As such, FM-indices have been used in many aligners such as BWT-SW<span class="citation"><sup><a href="#ref-lamCompressedIndexingLocal2008" role="doc-biblioref">232</a></sup></span>, BWA<span class="citation"><sup><a href="#ref-liFastAccurateShort2009" role="doc-biblioref">233</a></sup></span> and BWA-SW<span class="citation"><sup><a href="#ref-liFastAccurateLongread2010" role="doc-biblioref">234</a></sup></span>, BWA-MEM<span class="citation"><sup><a href="#ref-liAligningSequenceReads2013" role="doc-biblioref">235</a></sup></span>, CUSHAW<span class="citation"><sup><a href="#ref-liuLongReadAlignment2012" role="doc-biblioref">236</a></sup></span> or Bowtie2<span class="citation"><sup><a href="#ref-langmeadFastGappedreadAlignment2012" role="doc-biblioref">237</a></sup></span>.</p>
<p>The seed and extend paradigm has been very useful in the field of genomics to deal with the scale of data and keep up with sequencing technologies, and some newer alignment algorithms like the WFA algorithm mentioned above, have even been used in such a context<span class="citation"><sup><a href="#ref-songAnchorWaveSensitiveAlignment2022" role="doc-biblioref">238</a></sup></span>.</p>
<p>Some methodological development have been aimed towards improving alignment sensitivity instead of speed. One of these methods, fairly well studied in general, and in the context of alignment, are hidden markov models (HMMs). In certain circumstances PairHMMs, HMMs used for pairwise alignment, can be mathematically equivalent to NW<span class="citation"><sup><a href="#ref-durbinBiologicalSequenceAnalysis1998" role="doc-biblioref">239</a></sup></span>. HMMs have been used for sequence alignment in many software tools like HHsearch<span class="citation"><sup><a href="#ref-sodingProteinHomologyDetection2005" role="doc-biblioref">240</a></sup></span>, HMMer<span class="citation"><sup><a href="#ref-finnHMMERWebServer2011" role="doc-biblioref">241</a></sup></span> or MCALIGN2<span class="citation"><sup><a href="#ref-wangMCALIGN2FasterAccurate2006" role="doc-biblioref">242</a></sup></span> which is used to efficiently search for alignments in large databases of sequences.</p>
</div>
</div>
</div>
<div id="the-specificities-of-read-mapping" class="section level2 hasAnchor" number="2.3">
<h2><span class="header-section-number">2.3</span> The specificities of read-mapping<a href="aligning-sequence-data.html#the-specificities-of-read-mapping" class="anchor-section" aria-label="Anchor link to header"></a></h2>
<p>Since read-mapping is special case of pairwise alignment and the focus of Chapter <a href="HPC-paper.html#HPC-paper">3</a>, it stands to reason that we use this section to explain the stakes and challenges of mapping.</p>
<div id="what-is-read-mapping" class="section level3 hasAnchor" number="2.3.1">
<h3><span class="header-section-number">2.3.1</span> What is read-mapping ?<a href="aligning-sequence-data.html#what-is-read-mapping" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<p>Read-mapping, or sometimes read-alignment is the process of comparing a sequencing read to a reference sequence and finding the region in the reference homologous to the read. Sometimes, mappers only output the position where this region starts in the reference but more often than not, they output local or semi-global alignments between the reads and the reference. In <em>semi-global alignment</em>, two sequences are globally aligned but indels at the end and beginning of each sequence are not penalized, this can be useful to detect overlap between two sequences or align two sequences of very different sizes.</p>
<p>Read-mapping is often the first step of many bioinformatics analysis pipelines, and as such is often crucial. Therefore it makes sense that this is a very active field with many reviews<span class="citation"><sup><a href="#ref-ruffaloComparativeAnalysisAlgorithms2011" role="doc-biblioref">243</a>–<a href="#ref-alserTechnologyDictatesAlgorithms2021" role="doc-biblioref">247</a></sup></span> and some benchmarking procedures<span class="citation"><sup><a href="#ref-brindaRNFGeneralFramework2016" role="doc-biblioref">248</a></sup></span> to compare tools.</p>
<p>From a technical and algorithmic standpoint, the task of mapping many sequencing reads to a single reference lends itself very well to the “divide and conquer” approach presented in Section <a href="aligning-sequence-data.html#seed-and-extend-with-data-structures">2.2.2</a>. Indexing the reference beforehand and using this index as a database to align can lead to substantial execution speed gains. As a matter of fact, many of the aligners presented in Section <a href="aligning-sequence-data.html#seed-and-extend-with-data-structures">2.2.2</a> are actually read-mappers that can also do pairwise alignment. As such most implement the seed-and-extend paradigm with hash-tables like minimap2<span class="citation"><sup><a href="#ref-liMinimap2PairwiseAlignment2018" role="doc-biblioref">118</a></sup></span>; FM-indices like BWT-SW<span class="citation"><sup><a href="#ref-lamCompressedIndexingLocal2008" role="doc-biblioref">232</a></sup></span>, Bowtie2<span class="citation"><sup><a href="#ref-langmeadFastGappedreadAlignment2012" role="doc-biblioref">237</a></sup></span>, BWA<span class="citation"><sup><a href="#ref-liFastAccurateShort2009" role="doc-biblioref">233</a></sup></span>, BWA-SW<span class="citation"><sup><a href="#ref-liFastAccurateLongread2010" role="doc-biblioref">234</a></sup></span>, BWA-MEM<span class="citation"><sup><a href="#ref-liAligningSequenceReads2013" role="doc-biblioref">235</a></sup></span> and CUSHAW<span class="citation"><sup><a href="#ref-liuLongReadAlignment2012" role="doc-biblioref">236</a></sup></span>; or even other divide and conquer approaches like Kart<span class="citation"><sup><a href="#ref-linKartDivideandconquerAlgorithm2017" role="doc-biblioref">249</a></sup></span>. As sequencing technologies yield longer and more numerous reads, these heuristics become more important if we wish to be able to analyze this data, however this can be partly mitigated through hardware acceleration<span class="citation"><sup><a href="#ref-olsonHardwareAccelerationShort2012" role="doc-biblioref">250</a>–<a href="#ref-zeniLOGANHighPerformanceGPUBased2020" role="doc-biblioref">253</a></sup></span>.</p>
</div>
<div id="challenges-of-read-mapping" class="section level3 hasAnchor" number="2.3.2">
<h3><span class="header-section-number">2.3.2</span> Challenges of read-mapping<a href="aligning-sequence-data.html#challenges-of-read-mapping" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<p>Read-mapping, as one might expect, is no easy task. The length of recent sequencing reads and their number are of course challenging, but algorithmic tricks described above can help. There are other aspects of sequencing data that make read-mapping as hard as it is.</p>
<p>Sequencing technologies, although have improved over time can still make errors, and these errors can lower the homology between reads and reference making mapping harder<span class="citation"><sup><a href="#ref-gusfieldAlgorithmsStringsTrees1997" role="doc-biblioref">128</a></sup></span>. This is particularly true of long reads where the error rate is higher, to mitigate that some specific long-read mappers take these errors into account when aligning a read to the reference. Some mappers are tied to a specific sequencing technology like BLASR<span class="citation"><sup><a href="#ref-chaissonMappingSingleMolecule2012" role="doc-biblioref">254</a></sup></span> or lordFAST<span class="citation"><sup><a href="#ref-haghshenasLordFASTSensitiveFast2019" role="doc-biblioref">255</a></sup></span> for PacBIO reads, and GraphMap<span class="citation"><sup><a href="#ref-sovicFastSensitiveMapping2016" role="doc-biblioref">256</a></sup></span> for ONT. Some however, like NGMLR<span class="citation"><sup><a href="#ref-sedlazeckAccurateDetectionComplex2018" role="doc-biblioref">257</a></sup></span>, MashMap<span class="citation"><sup><a href="#ref-jainFastApproximateAlgorithm2018" role="doc-biblioref">258</a></sup></span> or DuploMap<span class="citation"><sup><a href="#ref-prodanovSensitiveAlignmentUsing2020" role="doc-biblioref">259</a></sup></span>, are technology agnostic and can work with any type of long-read. This might not be needed forever though as sequencing accuracy is growing with every new generation of sequencers. Since homopolymer-linked indels are still common in long-read sequencing (cf. Section <a href="what-is-sequence-data.html#homopolymers-and-long-reads">1.4.2</a>) many modern read-mappers, designed to work with long reads, include some option to use homopolymer compression (c.f. Section <a href="what-is-sequence-data.html#hpc-trick">1.4.3.2</a>).</p>
<p>While the technology producing reads can complicate the read-mapping tasks, some regions of the genome are intrinsically harder to map to. This is particularly true of repetitive regions like telomeres or centromeres<span class="citation"><sup><a href="#ref-alserTechnologyDictatesAlgorithms2021" role="doc-biblioref">247</a></sup></span>. Repetitive regions mean a lot of potential homologous regions between a read and the reference, producing a lot of seed hits, increasing the runtime of the aligners and lowering the overall confidence in read-placement. Some tools have been developed specifically to deal with such regions. Winnowmap<span class="citation"><sup><a href="#ref-jainWeightedMinimizerSampling2020" role="doc-biblioref">119</a></sup></span> and winnowmap2<span class="citation"><sup><a href="#ref-jainLongreadMappingRepetitive2022" role="doc-biblioref">260</a></sup></span>, assign a weight to <span class="math inline">\(k\)</span>-mers that might be sampled as minimizers. By under-weighting frequently appearing <span class="math inline">\(k\)</span>-mers they can improve performance in repetitive regions. TandemMapper<span class="citation"><sup><a href="#ref-mikheenkoTandemToolsMappingLong2020" role="doc-biblioref">261</a></sup></span> was designed to map long reads to the extra-long tandem repeats (ETRs) present in centromeric regions. It does not use minimzers, however like winnowmap it selects less frequent <span class="math inline">\(k\)</span>-mers as potential seeds to deal with the repetitiveness and improve the mapping accuracy. Long reads are also much easier to map to repetitive regions since they can span over them, or overlap with more complex regions<span class="citation"><sup><a href="#ref-pollardLongReadsTheir2018" role="doc-biblioref">47</a>,<a href="#ref-logsdonLongreadHumanGenome2020" role="doc-biblioref">55</a></sup></span>.</p>
<p>Some challenges however are linked to implementation rather than sequencing data. Some efforts have been done to provide quality scores to mappings in order to easily assess its quality and therefore usefulness. This score, called <em>mapping quality</em>, corresponds to <span class="math inline">\(-10\log_{10}(p)\)</span>, usually rounded to the nearest integer, where <span class="math inline">\(p\)</span> corresponds to the probability of the read being mismapped. It was introduced in the MAQ software<span class="citation"><sup><a href="#ref-liMappingShortDNA2008" role="doc-biblioref">262</a></sup></span> but has been implemented in many read-mappers like BWA , bowtie2<span class="citation"><sup><a href="#ref-langmeadFastGappedreadAlignment2012" role="doc-biblioref">237</a></sup></span> or minimap2<span class="citation"><sup><a href="#ref-liMinimap2PairwiseAlignment2018" role="doc-biblioref">118</a></sup></span> since it was added as part of the widely-used SAM file format specification<span class="citation"><sup><a href="#ref-liSequenceAlignmentMap2009a" role="doc-biblioref">263</a></sup></span>.</p>
<p>While the mapping quality score is standardized each read-mapper has a different way of estimating <span class="math inline">\(p\)</span> the mismap probability. This creates differences in the reported qualities: <em>e.g.</em> the maximum quality that bowtie2 can assign is 42, BWA’s is 37 and minimap’s is 60<span class="citation"><sup><a href="#ref-UnderstandingMAPQScores" role="doc-biblioref">264</a></sup></span>. This of course means that comparing mapping quality values between read-mappers is not necessarily meaningful. Furthermore in some cases this mapping quality is not very reflective of the alignment accuracy<span class="citation"><sup><a href="#ref-ruffaloComparativeAnalysisAlgorithms2011" role="doc-biblioref">243</a></sup></span>, as such alternative approaches have been explored: through a new genome mappability score<span class="citation"><sup><a href="#ref-leeGenomicDarkMatter2012" role="doc-biblioref">265</a></sup></span>, simulations<span class="citation"><sup><a href="#ref-langmeadTandemSimulationFramework2017" role="doc-biblioref">266</a></sup></span> or even machine learning<span class="citation"><sup><a href="#ref-ruffaloAccurateEstimationShort2012" role="doc-biblioref">267</a></sup></span>.</p>
<p>In conclusion, as a crucial step in many bioinformatics pipelines, read-mapping is a markedly active field with a lot of work in increasing mapping accuracy and speeding up alignment. However, despite all this work, some challenges remain. Further improving mapping is possible and doing so could result in more accurate downstream analyses and avoid drawing some erroneous conclusions.</p>
</div>
</div>
<div id="multiple-sequence-alignment" class="section level2 hasAnchor" number="2.4">
<h2><span class="header-section-number">2.4</span> Multiple sequence alignment<a href="aligning-sequence-data.html#multiple-sequence-alignment" class="anchor-section" aria-label="Anchor link to header"></a></h2>
<p>Up until now we have only considered pairwise alignment where we want to find homologies between a pair of sequences. In many cases though it is helpful to compare more than two sequences together, this is where multiple sequence alignment (MSA) steps-in. It is an essential task in many bioinformatics and comparative biology analyses<span class="citation"><sup><a href="#ref-russellMultipleSequenceAlignment2014" role="doc-biblioref">268</a></sup></span>.</p>
<p>We saw earlier that with dynamic programming and algorithms like NW or SW it is possible to compute an optimal pairwise alignment, for MSA however the task of computing the optimal alignment if unfortunately NP-hard<span class="citation"><sup><a href="#ref-wangComplexityMultipleSequence1994" role="doc-biblioref">269</a>,<a href="#ref-justComputationalComplexityMultiple2001" role="doc-biblioref">270</a></sup></span>, with an exponentially growing time and space complexity in the number of sequences to align. Therefore, heuristics and approximations are needed from the get go in order to get anything meaningful.</p>
<p>An early method, and easy to conceptualize, is the so-called star alignment method<span class="citation"><sup><a href="#ref-chaoDevelopmentsAlgorithmsSequence2022" role="doc-biblioref">194</a></sup></span>. In this approach, a single sequence is chosen to be the center sequence. After this each other sequence is aligned to the center sequence and the pairwise alignments are merged, conserving gaps that were inserted. The center sequence is often chosen to be as similar to the other sequences as possible so in, however all pairwise distances between sequences are needed implying a quadratic distance computation step. The pairwise alignments are independent so this approach is easy to parallelize. Some software, like HAlign<span class="citation"><sup><a href="#ref-tangHAlignFastMultiple2022" role="doc-biblioref">271</a></sup></span> use center star alignment to produce MSAs. This method however is quite sensitive to the choice of the center sequence. And bad pairwise alignments can lower the accuracy of the overall MSA by conserving gaps.</p>
<div id="progressive-alignment" class="section level3 hasAnchor" number="2.4.1">
<h3><span class="header-section-number">2.4.1</span> Progressive alignment<a href="aligning-sequence-data.html#progressive-alignment" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<p>One of the most widely used multiple sequence alignment approach is progressive alignment<span class="citation"><sup><a href="#ref-fengProgressiveSequenceAlignment1987" role="doc-biblioref">272</a></sup></span>. Similarly to the center star algorithm, the progressive algorithm reduces the MSA problem to independent pairwise alignments. The first step is to build a phylogenetic tree from the sequences to align, representing the evolutionary relationship between sequences, called the <em>guide tree</em>. Starting from the leaves, that correspond to single sequences, pairwise align the sequences and store the alignment (or <em>profile</em>) in the parent node. Going up from the leaves to the roots align sequences together, then sequences to profiles if needed and finally profiles together, merging alignments as we progress up the tree. The final multiple sequence alignment is obtained when this process reaches the root. Profiles at inner nodes of the tree are aligned to each other to conserve gaps. A representation of this process is shown in Figure <a href="aligning-sequence-data.html#fig:progAlign">2.6</a>.</p>
<div class="figure" style="text-align: center"><span style="display:block;" id="fig:progAlign"></span>
<img src="figures/Align-Intro/progressive.png" alt="**Overview of the progressive alignment process.**  
**A)** sequences to align, **B)** guide tree constructed from distances between sequences in panel A, **C)** Alignment steps along the guide tree and resulting MSA at the root of the tree. Adapted from [@sungAlgorithmsBioinformaticsPractical2011]" width="80%" />
<p class="caption">
Figure 2.6: <strong>Overview of the progressive alignment process.</strong><br />
<strong>A)</strong> sequences to align, <strong>B)</strong> guide tree constructed from distances between sequences in panel A, <strong>C)</strong> Alignment steps along the guide tree and resulting MSA at the root of the tree. Adapted from<span class="citation"><sup><a href="#ref-sungAlgorithmsBioinformaticsPractical2011" role="doc-biblioref">143</a></sup></span>
</p>
</div>
<p>In many cases a matrix of pairwise distances is needed to construct the guide tree, if we choose the edit distance, <span class="math inline">\(n(n-1)/2\)</span> pairwise alignments are needed to get this matrix. With a large number of sequences, or long sequences this is not possible in a reasonable amount of time. Therefore, computing of distance matrices through alignment-free methods, usually based on <span class="math inline">\(k\)</span>-mers, is often used as input to the tree building method<span class="citation"><sup><a href="#ref-jonesRapidGenerationMutation1992" role="doc-biblioref">273</a>,<a href="#ref-blaisdellMeasureSimilaritySets1986" role="doc-biblioref">274</a></sup></span>.</p>
<p>Tree reconstruction methods from the distance matrix like UPGMA<span class="citation"><sup><a href="#ref-gronauOptimalImplementationsUPGMA2007" role="doc-biblioref">275</a></sup></span> or neighbor-joining<span class="citation"><sup><a href="#ref-saitouNeighborjoiningMethodNew1987" role="doc-biblioref">276</a></sup></span> can be quite time consuming when dealing with a large set of sequences. To counteract this, some multiple sequence aligners also use heuristic methods to approximate a guide tree. MAFFT<span class="citation"><sup><a href="#ref-katohMAFFTNovelMethod2002" role="doc-biblioref">195</a></sup></span> for example uses PartTree<span class="citation"><sup><a href="#ref-katohPartTreeAlgorithmBuild2007" role="doc-biblioref">277</a></sup></span> method to approximate the tree, and clustal Omega<span class="citation"><sup><a href="#ref-sieversFastScalableGeneration2011" role="doc-biblioref">278</a></sup></span> uses an embedding method<span class="citation"><sup><a href="#ref-blackshieldsSequenceEmbeddingFast2010" role="doc-biblioref">279</a></sup></span> to do so.</p>
<p>Although this method is a good heuristic as the guide tree can capture complex relationships between sequences, progressive alignment can still suffer from problems similar to center star alignment: mainly gap propagation. If an early alignment is erroneous and introduces spurious gaps, then these are propagated throughout the MSA. As it is said in the seminal progressive alignment paper: “once a gap, always a gap”<span class="citation"><sup><a href="#ref-fengProgressiveSequenceAlignment1987" role="doc-biblioref">272</a></sup></span>. Iterative refinement of the MSA<span class="citation"><sup><a href="#ref-russellMultipleSequenceAlignment2014" role="doc-biblioref">268</a></sup></span> was proposed as a solution to this problem. A possible approach is to recompute a guide tree from the alignment and run the whole progressive alignment procedure on the new guide tree, however this is very time consuming and not practical with the large sequence sets available today. Therefore the iterative procedure consists of taking an MSA obtained through progressive alignment and splitting it horizontally in two alignments of <span class="math inline">\(n/2\)</span> sequences each. In each half, the sites composed exclusively of gaps are removed and the two alignments merged through profile alignment. After the realignment of both halves, a scoring metric is computed and while this metric improves, repeat the previous steps. There are several of these metrics, the most commonly used is the probably the sum of pairs score<span class="citation"><sup><a href="#ref-altschulGapCostsMultiple1989" role="doc-biblioref">280</a></sup></span> or its weighted variant<span class="citation"><sup><a href="#ref-altschulWeightsDataRelated1989" role="doc-biblioref">281</a></sup></span>, however there exist other scores like log-odds and correlation<span class="citation"><sup><a href="#ref-edgarComparisonScoringFunctions2004" role="doc-biblioref">282</a></sup></span> or a consistency based score<span class="citation"><sup><a href="#ref-notredameCOFFEEObjectiveFunction1998" role="doc-biblioref">283</a></sup></span>.</p>
<p>Most of the widely used multiple sequence aligners some form of progressive alignment with iterative refinement: T-Coffee<span class="citation"><sup><a href="#ref-notredameTcoffeeNovelMethod2000" role="doc-biblioref">284</a></sup></span> which uses a consistency score for refinement, MUSCLE<span class="citation"><sup><a href="#ref-edgarMUSCLEMultipleSequence2004a" role="doc-biblioref">285</a>,<a href="#ref-edgarMUSCLEMultipleSequence2004" role="doc-biblioref">286</a></sup></span>, MAFFT<span class="citation"><sup><a href="#ref-katohMAFFTNovelMethod2002" role="doc-biblioref">195</a></sup></span>, ProbCons<span class="citation"><sup><a href="#ref-doProbConsProbabilisticConsistencybased2005" role="doc-biblioref">287</a></sup></span> which uses a formal HMM to compute consistency and the various CLUSTAL incarnations<span class="citation"><sup><a href="#ref-sieversFastScalableGeneration2011" role="doc-biblioref">278</a>,<a href="#ref-thompsonCLUSTALImprovingSensitivity1994" role="doc-biblioref">288</a>,<a href="#ref-thompsonCLUSTALWindowsInterface1997" role="doc-biblioref">289</a></sup></span> which are some of the most cited papers of all times.</p>
</div>
<div id="other-methods" class="section level3 hasAnchor" number="2.4.2">
<h3><span class="header-section-number">2.4.2</span> Other methods<a href="aligning-sequence-data.html#other-methods" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<p>While the progressive alignment algorithm has been at the root of some of the most widely used alignment software, other methods to produce MSAs have been explored over the years.</p>
<p>One common other method for creating multiple alignment, wither through profile-profile alignment or sequence-profile alignments are HMMs. Several tools HMMs to generate an alignment such as HMMer<span class="citation"><sup><a href="#ref-finnHMMERWebServer2011" role="doc-biblioref">241</a></sup></span>, MSAProbs<span class="citation"><sup><a href="#ref-liuMSAProbsMultipleSequence2010" role="doc-biblioref">290</a></sup></span> or COVID-align<span class="citation"><sup><a href="#ref-lemoineCOVIDAlignAccurateOnline2020" role="doc-biblioref">291</a></sup></span>. In some cases, the HMM based approach has similar performance to clustalW<span class="citation"><sup><a href="#ref-eddyMultipleAlignmentUsing" role="doc-biblioref">292</a></sup></span>.</p>
<p>Other methods have focused on speeding up the dynamic programming part of aligning multiple sequences. This can be done using simulated annealing<span class="citation"><sup><a href="#ref-kimMultipleSequenceAlignment1994" role="doc-biblioref">293</a>–<a href="#ref-huoSimulatedAnnealingAlgorithm2007" role="doc-biblioref">295</a></sup></span>, which can also be used to speed up HMM training<span class="citation"><sup><a href="#ref-eddyMultipleAlignmentUsing" role="doc-biblioref">292</a></sup></span>. Genetic algorithms have also been used to construct MSAs<span class="citation"><sup><a href="#ref-chowdhuryReviewMultipleSequence2017" role="doc-biblioref">296</a></sup></span>, increasing the speed at which this is possible<span class="citation"><sup><a href="#ref-zhangGeneticAlgorithmMultiple1997" role="doc-biblioref">297</a></sup></span>. Several tools use genetic algorithms like VGDA<span class="citation"><sup><a href="#ref-nazninVerticalDecompositionGenetic2011" role="doc-biblioref">298</a></sup></span>, GAPAM<span class="citation"><sup><a href="#ref-nazninProgressiveAlignmentMethod2012" role="doc-biblioref">299</a></sup></span> and SAGA<span class="citation"><sup><a href="#ref-notredameSAGASequenceAlignment1996" role="doc-biblioref">300</a></sup></span>.</p>
<p>WIth the recent focus on SARS-CoV 2, some specific multiple sequence aligners have been developed to create very large multiple sequence alignments. They often take advantage of the fact that this virus mutates quite slowly meaning that most of the available sequences have a high homology. Furthermore as the epidemic was tracked in near real time since it’s beginning, we know the original sequence at the root of the pandemic. Leveraging this knowledge it is possible to build a profile from aligning new sequences to the ancestral sequence and aligning new sequences to this profile using HMMs like what is done in COVID-align<span class="citation"><sup><a href="#ref-lemoineCOVIDAlignAccurateOnline2020" role="doc-biblioref">291</a></sup></span>. The NextAlign<span class="citation"><sup><a href="#ref-aksamentovNextcladeCladeAssignment2021" role="doc-biblioref">301</a></sup></span> software even forgoes aligning to a profile and creates massive MSAs (millions of sequences) by aligning new sequences to the ancestral sequence using banded SW alignment, the gap penalties are enriched with biological knowledge and dependent on the position within the sequence.</p>
<p>Recently, Garriga <em>et al.</em> introduced the regressive alignment method<span class="citation"><sup><a href="#ref-garrigaLargeMultipleSequence2019" role="doc-biblioref">302</a></sup></span>, where instead of traversing a guide tree from leaf to root, it goes the other way, aligning the more distant sequences first before merging MSAs. Using this approach they managed to create an MSA of 1.4 million sequences with improved accuracy over progressive methods.</p>
<p>Since multiple sequence alignments are so useful in comparative biology, and that there is such a vast array of methods to construct them it stands to reason that are many resources to help practitioners make their choice. There are many reviews and benchmarking datasets and procedures to do so<span class="citation"><sup><a href="#ref-notredameRecentEvolutionsMultiple2007" role="doc-biblioref">303</a>–<a href="#ref-thompsonBAliBASEBenchmarkAlignment1999" role="doc-biblioref">307</a></sup></span>.</p>
</div>
</div>
<div id="conclusion-1" class="section level2 hasAnchor" number="2.5">
<h2><span class="header-section-number">2.5</span> Conclusion<a href="aligning-sequence-data.html#conclusion-1" class="anchor-section" aria-label="Anchor link to header"></a></h2>
<p>Sequence alignment, multiple or pairwise, is a fundamental tool in the bioinformatician’s toolkit. Comparing sequences and finding homologies being at the root of many fields, because of the wealth of evolutionary information contained in alignments. As such it is paramount to have the best possible sequence alignments in any situation.</p>
<p>As we have seen now, although we have methods guaranteed to give us optimal pairwise and multiple sequence alignments, they are not practically useful for dealing with sequences at today’s scale. Therefore, most sequence aligners rely on, sometimes many, heuristics and approximations. From substitution models to seeding techniques, all these are not necessarily reflective of the biological reality contained within the sequences to align. Each of these heuristics or models is a step where biases and approximations can happen, building up along and over sequences. Therefore there must be room for improvement.</p>
<p>Having methods that are both fast and accurate are now more necessary than ever with the ever growing scale and number of publicly available sequences. Furthermore, in the “age of pandemics”, accurate alignment methods are indispensable to track and keep an eye on disease spread across the globe, in real-time.</p>

</div>
</div>
<h3>References</h3>
<div id="refs" class="references csl-bib-body" line-spacing="2">
<div id="ref-pollardLongReadsTheir2018" class="csl-entry">
<div class="csl-left-margin">47. </div><div class="csl-right-inline">Pollard, M. O., Gurdasani, D., Mentzer, A. J., Porter, T. &amp; Sandhu, M. S. <a href="https://doi.org/10.1093/hmg/ddy177">Long reads: Their purpose and place</a>. <em>Human Molecular Genetics</em> <strong>27</strong>, R234–R241 (2018).</div>
</div>
<div id="ref-logsdonLongreadHumanGenome2020" class="csl-entry">
<div class="csl-left-margin">55. </div><div class="csl-right-inline">Logsdon, G. A., Vollger, M. R. &amp; Eichler, E. E. <a href="https://doi.org/10.1038/s41576-020-0236-x">Long-read human genome sequencing and its applications</a>. <em>Nat Rev Genet</em> <strong>21</strong>, 597–614 (2020).</div>
</div>
<div id="ref-hacklProovreadLargescaleHighaccuracy2014" class="csl-entry">
<div class="csl-left-margin">80. </div><div class="csl-right-inline">Hackl, T., Hedrich, R., Schultz, J. &amp; Förster, F. <a href="https://doi.org/10.1093/bioinformatics/btu392">Proovread : Large-scale high-accuracy PacBio correction through iterative short read consensus</a>. <em>Bioinformatics</em> <strong>30</strong>, 3004–3011 (2014).</div>
</div>
<div id="ref-korenHybridErrorCorrection2012" class="csl-entry">
<div class="csl-left-margin">82. </div><div class="csl-right-inline">Koren, S. <em>et al.</em> <a href="https://doi.org/10.1038/nbt.2280">Hybrid error correction and de novo assembly of single-molecule sequencing reads</a>. <em>Nature Biotechnology</em> <strong>30</strong>, 693–700 (2012).</div>
</div>
<div id="ref-liMinimap2PairwiseAlignment2018" class="csl-entry">
<div class="csl-left-margin">118. </div><div class="csl-right-inline">Li, H. <a href="https://doi.org/10.1093/bioinformatics/bty191">Minimap2: Pairwise alignment for nucleotide sequences</a>. <em>Bioinformatics</em> <strong>34</strong>, 3094–3100 (2018).</div>
</div>
<div id="ref-jainWeightedMinimizerSampling2020" class="csl-entry">
<div class="csl-left-margin">119. </div><div class="csl-right-inline">Jain, C. <em>et al.</em> <a href="https://doi.org/10.1093/bioinformatics/btaa435">Weighted minimizer sampling improves long read mapping</a>. <em>Bioinformatics</em> <strong>36</strong>, i111–i118 (2020).</div>
</div>
<div id="ref-hammingCodingInformationTheory1980" class="csl-entry">
<div class="csl-left-margin">127. </div><div class="csl-right-inline">Hamming, R. W. <em>Coding and Information Theory</em>. (Prentice-Hall, 1980).</div>
</div>
<div id="ref-gusfieldAlgorithmsStringsTrees1997" class="csl-entry">
<div class="csl-left-margin">128. </div><div class="csl-right-inline">Gusfield, D. <em>Algorithms on strings, trees, and sequences: Computer science and computational biology</em>. (Cambridge University Press, 1997). doi:<a href="https://doi.org/10.1017/CBO9780511574931">10.1017/CBO9780511574931</a>.</div>
</div>
<div id="ref-levenshteinBinaryCodesCapable1966" class="csl-entry">
<div class="csl-left-margin">129. </div><div class="csl-right-inline">Levenshtein, V. I. Binary codes capable of correcting deletions, insertions and reversals. <em>Soviet Physics Doklady</em> <strong>10</strong>, 707 (1966).</div>
</div>
<div id="ref-hardisonComparativeGenomics2003" class="csl-entry">
<div class="csl-left-margin">130. </div><div class="csl-right-inline">Hardison, R. C. <a href="https://doi.org/10.1371/journal.pbio.0000058">Comparative Genomics</a>. <em>PLOS Biology</em> <strong>1</strong>, e58 (2003).</div>
</div>
<div id="ref-felsensteinEvolutionaryTreesDNA1981" class="csl-entry">
<div class="csl-left-margin">131. </div><div class="csl-right-inline">Felsenstein, J. <a href="https://doi.org/10.1007/BF01734359">Evolutionary trees from DNA sequences: A maximum likelihood approach</a>. <em>Journal of Molecular Evolution</em> <strong>17</strong>, 368–376 (1981).</div>
</div>
<div id="ref-priceFastTreeApproximatelyMaximumLikelihood2010" class="csl-entry">
<div class="csl-left-margin">135. </div><div class="csl-right-inline">Price, M. N., Dehal, P. S. &amp; Arkin, A. P. <a href="https://doi.org/10.1371/journal.pone.0009490">FastTree 2 <span></span> Approximately Maximum-Likelihood Trees for Large Alignments</a>. <em>PLOS ONE</em> <strong>5</strong>, e9490 (2010).</div>
</div>
<div id="ref-jumperHighlyAccurateProtein2021" class="csl-entry">
<div class="csl-left-margin">136. </div><div class="csl-right-inline">Jumper, J. <em>et al.</em> <a href="https://doi.org/10.1038/s41586-021-03819-2">Highly accurate protein structure prediction with AlphaFold</a>. <em>Nature</em> <strong>596</strong>, 583–589 (2021).</div>
</div>
<div id="ref-karplusPredictingProteinStructure1999" class="csl-entry">
<div class="csl-left-margin">137. </div><div class="csl-right-inline">Karplus, K. <em>et al.</em> <a href="https://doi.org/10.1002/(SICI)1097-0134(1999)37:3+&lt;121::AID-PROT16&gt;3.0.CO;2-Q">Predicting protein structure using only sequence information</a>. <em>Proteins: Structure, Function, and Bioinformatics</em> <strong>37</strong>, 121–125 (1999).</div>
</div>
<div id="ref-watsonPredictingProteinFunction2005" class="csl-entry">
<div class="csl-left-margin">138. </div><div class="csl-right-inline">Watson, J. D., Laskowski, R. A. &amp; Thornton, J. M. <a href="https://doi.org/10.1016/j.sbi.2005.04.003">Predicting protein function from sequence and structural data</a>. <em>Current Opinion in Structural Biology</em> <strong>15</strong>, 275–284 (2005).</div>
</div>
<div id="ref-leePredictingProteinFunction2007" class="csl-entry">
<div class="csl-left-margin">139. </div><div class="csl-right-inline">Lee, D., Redfern, O. &amp; Orengo, C. <a href="https://doi.org/10.1038/nrm2281">Predicting protein function from sequence and structure</a>. <em>Nature Reviews Molecular Cell Biology</em> <strong>8</strong>, 995–1005 (2007).</div>
</div>
<div id="ref-salmelaCorrectingErrorsShort2011" class="csl-entry">
<div class="csl-left-margin">140. </div><div class="csl-right-inline">Salmela, L. &amp; Schröder, J. <a href="https://doi.org/10.1093/bioinformatics/btr170">Correcting errors in short reads by multiple alignments</a>. <em>Bioinformatics</em> <strong>27</strong>, 1455–1461 (2011).</div>
</div>
<div id="ref-medvedevComputationalMethodsDiscovering2009" class="csl-entry">
<div class="csl-left-margin">141. </div><div class="csl-right-inline">Medvedev, P., Stanciu, M. &amp; Brudno, M. <a href="https://doi.org/10.1038/nmeth.1374">Computational methods for discovering structural variation with next-generation sequencing</a>. <em>Nature Methods</em> <strong>6</strong>, S13–S20 (2009).</div>
</div>
<div id="ref-mahmoudStructuralVariantCalling2019" class="csl-entry">
<div class="csl-left-margin">142. </div><div class="csl-right-inline">Mahmoud, M. <em>et al.</em> <a href="https://doi.org/10.1186/s13059-019-1828-7">Structural variant calling: the long and the short of it</a>. <em>Genome Biology</em> <strong>20</strong>, 246 (2019).</div>
</div>
<div id="ref-sungAlgorithmsBioinformaticsPractical2011" class="csl-entry">
<div class="csl-left-margin">143. </div><div class="csl-right-inline">Sung, W.-K. <em>Algorithms in bioinformatics: A practical introduction</em>. (Chapman; Hall/CRC, 2011). doi:<a href="https://doi.org/10.1201/9781420070347">10.1201/9781420070347</a>.</div>
</div>
<div id="ref-needlemanGeneralMethodApplicable1970" class="csl-entry">
<div class="csl-left-margin">144. </div><div class="csl-right-inline">Needleman, S. B. &amp; Wunsch, C. D. <a href="https://doi.org/10.1016/0022-2836(70)90057-4">A general method applicable to the search for similarities in the amino acid sequence of two proteins</a>. <em>Journal of Molecular Biology</em> <strong>48</strong>, 443–453 (1970).</div>
</div>
<div id="ref-smithIdentificationCommonMolecular1981" class="csl-entry">
<div class="csl-left-margin">145. </div><div class="csl-right-inline">Smith, T. F. &amp; Waterman, M. S. <a href="https://doi.org/10.1016/0022-2836(81)90087-5">Identification of common molecular subsequences</a>. <em>Journal of Molecular Biology</em> <strong>147</strong>, 195–197 (1981).</div>
</div>
<div id="ref-bradleyAppliedMathematicalProgramming1977" class="csl-entry">
<div class="csl-left-margin">146. </div><div class="csl-right-inline">Bradley, S. P., Hax, A. C. &amp; Magnanti, T. L. <em>Applied Mathematical Programming</em>. (Addison-Wesley Publishing Company, 1977).</div>
</div>
<div id="ref-bellmanTheoryDynamicProgramming1954" class="csl-entry">
<div class="csl-left-margin">147. </div><div class="csl-right-inline">Bellman, R. <a href="https://doi.org/10.1090/S0002-9904-1954-09848-8">The theory of dynamic programming</a>. <em>Bulletin of the American Mathematical Society</em> <strong>60</strong>, 503–515 (1954).</div>
</div>
<div id="ref-masekFasterAlgorithmComputing1980" class="csl-entry">
<div class="csl-left-margin">148. </div><div class="csl-right-inline">Masek, W. J. &amp; Paterson, M. S. <a href="https://doi.org/10.1016/0022-0000(80)90002-1">A faster algorithm computing string edit distances</a>. <em>Journal of Computer and System Sciences</em> <strong>20</strong>, 18–31 (1980).</div>
</div>
<div id="ref-vinhInformationTheoreticMeasures2010" class="csl-entry">
<div class="csl-left-margin">149. </div><div class="csl-right-inline">Vinh, N. X., Epps, J. &amp; Bailey, J. Information <span>Theoretic Measures</span> for <span>Clusterings Comparison</span>: <span>Variants</span>, <span>Properties</span>, <span>Normalization</span> and <span>Correction</span> for <span>Chance</span>. <em>Journal of Machine Learning Research</em> <strong>11</strong>, 18 (2010).</div>
</div>
<div id="ref-ullmanBoundsComplexityLongest1976" class="csl-entry">
<div class="csl-left-margin">150. </div><div class="csl-right-inline">Ullman, J. D., Aho, A. V. &amp; Hirschberg, D. S. <a href="https://doi.org/10.1145/321921.321922">Bounds on the complexity of the longest common subsequence problem</a>. <em>Journal of the ACM</em> <strong>23</strong>, 112 (1976).</div>
</div>
<div id="ref-hirschbergLinearSpaceAlgorithm1975" class="csl-entry">
<div class="csl-left-margin">151. </div><div class="csl-right-inline">Hirschberg, D. S. <a href="https://doi.org/10.1145/360825.360861">A linear space algorithm for computing maximal common subsequences</a>. <em>Communications of the ACM</em> <strong>18</strong>, 341343 (1975).</div>
</div>
<div id="ref-myersOptimalAlignmentsLinear1988" class="csl-entry">
<div class="csl-left-margin">152. </div><div class="csl-right-inline">Myers, E. W. &amp; Miller, W. <a href="https://doi.org/10.1093/bioinformatics/4.1.11">Optimal alignments in linear space</a>. <em>Bioinformatics</em> <strong>4</strong>, 11–17 (1988).</div>
</div>
<div id="ref-riceEMBOSSEuropeanMolecular2000" class="csl-entry">
<div class="csl-left-margin">153. </div><div class="csl-right-inline">Rice, P., Longden, I. &amp; Bleasby, A. EMBOSS: The european molecular biology open software suite. <em>Trends in genetics</em> <strong>16</strong>, 276277 (2000).</div>
</div>
<div id="ref-huangTimeefficientLinearspaceLocal1991" class="csl-entry">
<div class="csl-left-margin">154. </div><div class="csl-right-inline">Huang, X. &amp; Miller, W. <a href="https://doi.org/10.1016/0196-8858(91)90017-D">A time-efficient, linear-space local similarity algorithm</a>. <em>Advances in Applied Mathematics</em> <strong>12</strong>, 337–357 (1991).</div>
</div>
<div id="ref-watermanNewAlgorithmBest1987" class="csl-entry">
<div class="csl-left-margin">155. </div><div class="csl-right-inline">Waterman, M. S. &amp; Eggert, M. <a href="https://doi.org/10.1016/0022-2836(87)90478-5">A new algorithm for best subsequence alignments with application to tRNA-rRNA comparisons</a>. <em>Journal of Molecular Biology</em> <strong>197</strong>, 723–728 (1987).</div>
</div>
<div id="ref-stajichBioperlToolkitPerl2002" class="csl-entry">
<div class="csl-left-margin">156. </div><div class="csl-right-inline">Stajich, J. E. <em>et al.</em> <a href="https://doi.org/10.1101/gr.361602">The Bioperl Toolkit: Perl Modules for the Life Sciences</a>. <em>Genome Research</em> <strong>12</strong>, 1611–1618 (2002).</div>
</div>
<div id="ref-gentlemanBioconductorOpenSoftware2004" class="csl-entry">
<div class="csl-left-margin">157. </div><div class="csl-right-inline">Gentleman, R. C. <em>et al.</em> <a href="https://doi.org/10.1186/gb-2004-5-10-r80">Bioconductor: open software development for computational biology and bioinformatics</a>. <em>Genome Biology</em> <strong>5</strong>, R80 (2004).</div>
</div>
<div id="ref-dailyParasailSIMDLibrary2016" class="csl-entry">
<div class="csl-left-margin">158. </div><div class="csl-right-inline">Daily, J. <a href="https://doi.org/10.1186/s12859-016-0930-z">Parasail: SIMD c library for global, semi-global, and local pairwise sequence alignments</a>. <em>BMC Bioinformatics</em> <strong>17</strong>, 81 (2016).</div>
</div>
<div id="ref-frohmbergGPASImprovedVersion2012" class="csl-entry">
<div class="csl-left-margin">159. </div><div class="csl-right-inline">Frohmberg, W., Kierzynka, M., Blazewicz, J. &amp; Wojciechowski, P. <a href="https://doi.org/10.2478/v10175-012-0062-1">G-PAS 2.0 <span></span> an improved version of protein alignment tool with an efficient backtracking routine on multiple GPUs</a>. <em>Bulletin of the Polish Academy of Sciences: Technical Sciences</em> <strong>60</strong>, 491–494 (2012).</div>
</div>
<div id="ref-altschulSubstitutionMatrices2013" class="csl-entry">
<div class="csl-left-margin">160. </div><div class="csl-right-inline">Altschul, S. F. Substitution Matrices. in (John Wiley &amp; Sons, Ltd, 2013). doi:<a href="https://doi.org/10.1002/9780470015902.a0005265.pub3">10.1002/9780470015902.a0005265.pub3</a>.</div>
</div>
<div id="ref-dayhoffModelEvolutionaryChange1978" class="csl-entry">
<div class="csl-left-margin">161. </div><div class="csl-right-inline">Dayhoff, M. O., Schwartz, R. M. &amp; Orcutt, B. C. A model of evolutionary change in proteins. <em>A Model of Evolutionary Change in Proteins</em> 345–352 (1978).</div>
</div>
<div id="ref-mullerModelingAminoAcid2000" class="csl-entry">
<div class="csl-left-margin">162. </div><div class="csl-right-inline">Müller, T. &amp; Vingron, M. <a href="https://doi.org/10.1089/10665270050514918">Modeling amino acid replacement</a>. <em>Journal of Computational Biology: A Journal of Computational Molecular Cell Biology</em> <strong>7</strong>, 761–776 (2000).</div>
</div>
<div id="ref-henikoffAminoAcidSubstitution1992" class="csl-entry">
<div class="csl-left-margin">163. </div><div class="csl-right-inline">Henikoff, S. &amp; Henikoff, J. G. <a href="https://doi.org/10.1073/pnas.89.22.10915">Amino acid substitution matrices from protein blocks</a>. <em>Proceedings of the National Academy of Sciences</em> <strong>89</strong>, 10915–10919 (1992).</div>
</div>
<div id="ref-whelanGeneralEmpiricalModel2001" class="csl-entry">
<div class="csl-left-margin">164. </div><div class="csl-right-inline">Whelan, S. &amp; Goldman, N. <a href="https://doi.org/10.1093/oxfordjournals.molbev.a003851">A general empirical model of protein evolution derived from multiple protein families using a maximum-likelihood approach</a>. <em>Molecular Biology and Evolution</em> <strong>18</strong>, 691–699 (2001).</div>
</div>
<div id="ref-leImprovedGeneralAmino2008" class="csl-entry">
<div class="csl-left-margin">165. </div><div class="csl-right-inline">Le, S. Q. &amp; Gascuel, O. <a href="https://doi.org/10.1093/molbev/msn067">An improved general amino acid replacement matrix</a>. <em>Molecular Biology and Evolution</em> <strong>25</strong>, 1307–1320 (2008).</div>
</div>
<div id="ref-mullerNonsymmetricScoreMatrices2001" class="csl-entry">
<div class="csl-left-margin">166. </div><div class="csl-right-inline">Müller, T., Rahmann, S. &amp; Rehmsmeier, M. <a href="https://doi.org/10.1093/bioinformatics/17.suppl_1.S182">Non-symmetric score matrices and the detection of homologous transmembrane proteins</a>. <em>Bioinformatics</em> <strong>17</strong>, S182–S189 (2001).</div>
</div>
<div id="ref-ngPHATTransmembranespecificSubstitution2000" class="csl-entry">
<div class="csl-left-margin">167. </div><div class="csl-right-inline">Ng, P. C., Henikoff, J. G. &amp; Henikoff, S. <a href="https://doi.org/10.1093/bioinformatics/16.9.760">PHAT: a transmembrane-specific substitution matrix. Predicted hydrophobic and transmembrane</a>. <em>Bioinformatics (Oxford, England)</em> <strong>16</strong>, 760–766 (2000).</div>
</div>
<div id="ref-trivediAminoAcidSubstitution2019" class="csl-entry">
<div class="csl-left-margin">168. </div><div class="csl-right-inline">Trivedi, R. &amp; Nagarajaram, H. A. <a href="https://doi.org/10.1038/s41598-019-52532-8">Amino acid substitution scoring matrices specific to intrinsically disordered regions in proteins</a>. <em>Scientific Reports</em> <strong>9</strong>, 16380 (2019).</div>
</div>
<div id="ref-goonesekereContextspecificAminoAcid2008" class="csl-entry">
<div class="csl-left-margin">169. </div><div class="csl-right-inline">Goonesekere, N. C. W. &amp; Lee, B. <a href="https://doi.org/10.1002/prot.21775">Context-specific amino acid substitution matrices and their use in the detection of protein homologs</a>. <em>Proteins: Structure, Function, and Bioinformatics</em> <strong>71</strong>, 910–919 (2008).</div>
</div>
<div id="ref-pailaGenomeBiasInfluences2008" class="csl-entry">
<div class="csl-left-margin">170. </div><div class="csl-right-inline">Paila, U., Kondam, R. &amp; Ranjan, A. <a href="https://doi.org/10.1093/nar/gkn635">Genome bias influences amino acid choices: analysis of amino acid substitution and re-compilation of substitution matrices exclusive to an AT-biased genome</a>. <em>Nucleic Acids Research</em> <strong>36</strong>, 6664–6675 (2008).</div>
</div>
<div id="ref-nickleHIVSpecificProbabilisticModels2007" class="csl-entry">
<div class="csl-left-margin">171. </div><div class="csl-right-inline">Nickle, D. C. <em>et al.</em> <a href="https://doi.org/10.1371/journal.pone.0000503">HIV-specific probabilistic models of protein evolution</a>. <em>PLoS ONE</em> <strong>2</strong>, e503 (2007).</div>
</div>
<div id="ref-sardiuScoreStatisticsGlobal2005" class="csl-entry">
<div class="csl-left-margin">172. </div><div class="csl-right-inline">Sardiu, M. E., Alves, G. &amp; Yu, Y.-K. <a href="https://doi.org/10.1103/PhysRevE.72.061917">Score statistics of global sequence alignment from the energy distribution of a modified directed polymer and directed percolation problem</a>. <em>Physical Review. E, Statistical, Nonlinear, and Soft Matter Physics</em> <strong>72</strong>, 061917 (2005).</div>
</div>
<div id="ref-chiaromonteScoringPairwiseGenomic2001" class="csl-entry">
<div class="csl-left-margin">173. </div><div class="csl-right-inline">Chiaromonte, F., Yap, V. B. &amp; Miller, W. Scoring pairwise genomic sequence alignments. in 115–126 (WORLD SCIENTIFIC, 2001). doi:<a href="https://doi.org/10.1142/9789812799623_0012">10.1142/9789812799623_0012</a>.</div>
</div>
<div id="ref-schneiderEmpiricalCodonSubstitution2005" class="csl-entry">
<div class="csl-left-margin">174. </div><div class="csl-right-inline">Schneider, A., Cannarozzi, G. M. &amp; Gonnet, G. H. <a href="https://doi.org/10.1186/1471-2105-6-134">Empirical codon substitution matrix</a>. <em>BMC bioinformatics</em> <strong>6</strong>, 134 (2005).</div>
</div>
<div id="ref-doron-faigenboimCombinedEmpiricalMechanistic2007" class="csl-entry">
<div class="csl-left-margin">175. </div><div class="csl-right-inline">Doron-Faigenboim, A. &amp; Pupko, T. <a href="https://doi.org/10.1093/molbev/msl175">A combined empirical and mechanistic codon model</a>. <em>Molecular Biology and Evolution</em> <strong>24</strong>, 388–397 (2007).</div>
</div>
<div id="ref-cartwrightProblemsSolutionsEstimating2009" class="csl-entry">
<div class="csl-left-margin">176. </div><div class="csl-right-inline">Cartwright, R. A. <a href="https://doi.org/10.1093/molbev/msn275">Problems and solutions for estimating indel rates and length distributions</a>. <em>Molecular Biology and Evolution</em> <strong>26</strong>, 473–480 (2009).</div>
</div>
<div id="ref-fitchOptimalSequenceAlignments1983" class="csl-entry">
<div class="csl-left-margin">177. </div><div class="csl-right-inline">Fitch, W. M. &amp; Smith, T. F. <a href="https://doi.org/10.1073/pnas.80.5.1382">Optimal sequence alignments</a>. <em>Proceedings of the National Academy of Sciences</em> <strong>80</strong>, 1382–1386 (1983).</div>
</div>
<div id="ref-watermanBiologicalSequenceMetrics1976" class="csl-entry">
<div class="csl-left-margin">178. </div><div class="csl-right-inline">Waterman, M. S., Smith, T. F. &amp; Beyer, W. A. <a href="https://doi.org/10.1016/0001-8708(76)90202-4">Some biological sequence metrics</a>. <em>Advances in Mathematics</em> <strong>20</strong>, 367–387 (1976).</div>
</div>
<div id="ref-gotohImprovedAlgorithmMatching1982" class="csl-entry">
<div class="csl-left-margin">179. </div><div class="csl-right-inline">Gotoh, O. <a href="https://doi.org/10.1016/0022-2836(82)90398-9">An improved algorithm for matching biological sequences</a>. <em>Journal of Molecular Biology</em> <strong>162</strong>, 705–708 (1982).</div>
</div>
<div id="ref-altschulOptimalSequenceAlignment1986" class="csl-entry">
<div class="csl-left-margin">180. </div><div class="csl-right-inline">Altschul, S. F. &amp; Erickson, B. W. <a href="https://doi.org/10.1016/S0092-8240(86)90010-8">Optimal sequence alignment using affine gap costs</a>. <em>Bulletin of Mathematical Biology</em> <strong>48</strong>, 603–616 (1986).</div>
</div>
<div id="ref-watermanEfficientSequenceAlignment1984" class="csl-entry">
<div class="csl-left-margin">181. </div><div class="csl-right-inline">Waterman, M. S. <a href="https://doi.org/10.1016/S0022-5193(84)80037-5">Efficient sequence alignment algorithms</a>. <em>Journal of Theoretical Biology</em> <strong>108</strong>, 333–337 (1984).</div>
</div>
<div id="ref-millerSequenceComparisonConcave1988" class="csl-entry">
<div class="csl-left-margin">182. </div><div class="csl-right-inline">Miller, W. &amp; Myers, E. W. <a href="https://doi.org/10.1007/BF02459948">Sequence comparison with concave weighting functions</a>. <em>Bulletin of Mathematical Biology</em> <strong>50</strong>, 97–120 (1988).</div>
</div>
<div id="ref-cartwrightLogarithmicGapCosts2006" class="csl-entry">
<div class="csl-left-margin">183. </div><div class="csl-right-inline">Cartwright, R. A. <a href="https://doi.org/10.1186/1471-2105-7-527">Logarithmic gap costs decrease alignment accuracy</a>. <em>BMC Bioinformatics</em> <strong>7</strong>, 527 (2006).</div>
</div>
<div id="ref-goonesekereFrequencyGapsObserved2004" class="csl-entry">
<div class="csl-left-margin">184. </div><div class="csl-right-inline">Goonesekere, N. C. W. &amp; Lee, B. <a href="https://doi.org/10.1093/nar/gkh610">Frequency of gaps observed in a structurally aligned protein pair database suggests a simple gap penalty function</a>. <em>Nucleic Acids Research</em> <strong>32</strong>, 2838–2843 (2004).</div>
</div>
<div id="ref-bennerEmpiricalStructuralModels1993" class="csl-entry">
<div class="csl-left-margin">185. </div><div class="csl-right-inline">Benner, S. A., Cohen, M. A. &amp; Gonnet, G. H. <a href="https://doi.org/10.1006/jmbi.1993.1105">Empirical and Structural Models for Insertions and Deletions in the Divergent Evolution of Proteins</a>. <em>Journal of Molecular Biology</em> <strong>229</strong>, 1065–1082 (1993).</div>
</div>
<div id="ref-wrablGapsStructurallySimilar2004" class="csl-entry">
<div class="csl-left-margin">186. </div><div class="csl-right-inline">Wrabl, J. O. &amp; Grishin, N. V. <a href="https://doi.org/10.1002/prot.10508">Gaps in structurally similar proteins: Towards improvement of multiple sequence alignment</a>. <em>Proteins: Structure, Function, and Bioinformatics</em> <strong>54</strong>, 71–87 (2004).</div>
</div>
<div id="ref-zhangSP5ImprovingProtein2008" class="csl-entry">
<div class="csl-left-margin">187. </div><div class="csl-right-inline">Zhang, W., Liu, S. &amp; Zhou, Y. <a href="https://doi.org/10.1371/journal.pone.0002325">SP5: Improving Protein Fold Recognition by Using Torsion Angle Profiles and Profile-Based Gap Penalty Model</a>. <em>PLOS ONE</em> <strong>3</strong>, e2325 (2008).</div>
</div>
<div id="ref-jeanmouginMultipleSequenceAlignment1998" class="csl-entry">
<div class="csl-left-margin">188. </div><div class="csl-right-inline">Jeanmougin, F., Thompson, J. D., Gouy, M., Higgins, D. G. &amp; Gibson, T. J. <a href="https://doi.org/10.1016/S0968-0004(98)01285-7">Multiple sequence alignment with clustal x</a>. <em>Trends in Biochemical Sciences</em> <strong>23</strong>, 403–405 (1998).</div>
</div>
<div id="ref-wangComparisonLinearGap2011" class="csl-entry">
<div class="csl-left-margin">189. </div><div class="csl-right-inline">Wang, C., Yan, R.-X., Wang, X.-F., Si, J.-N. &amp; Zhang, Z. <a href="https://doi.org/10.1016/j.compbiolchem.2011.07.006">Comparison of linear gap penalties and profile-based variable gap penalties in profile<span></span>profile alignments</a>. <em>Computational Biology and Chemistry</em> <strong>35</strong>, 308–318 (2011).</div>
</div>
<div id="ref-marco-solaFastGapaffinePairwise2020" class="csl-entry">
<div class="csl-left-margin">190. </div><div class="csl-right-inline">Marco-Sola, S., Moure, J. C., Moreto, M. &amp; Espinosa, A. Fast gap-affine pairwise alignment using the wavefront algorithm. <em>Bioinformatics</em> (2020) doi:<a href="https://doi.org/10.1093/bioinformatics/btaa777">10.1093/bioinformatics/btaa777</a>.</div>
</div>
<div id="ref-pearson27DynamicProgramming1992" class="csl-entry">
<div class="csl-left-margin">191. </div><div class="csl-right-inline">Pearson, W. R. &amp; Miller, W. <a href="https://doi.org/10.1016/0076-6879(92)10029-D">[27] Dynamic programming algorithms for biological sequence comparison</a>. in vol. 210 575–601 (Academic Press, 1992).</div>
</div>
<div id="ref-spougeSpeedingDynamicProgramming1989a" class="csl-entry">
<div class="csl-left-margin">192. </div><div class="csl-right-inline">Spouge, J. L. <a href="https://doi.org/10.1137/0149094">Speeding up dynamic programming algorithms for finding optimal lattice paths</a>. <em>SIAM Journal on Applied Mathematics</em> <strong>49</strong>, 1552–1566 (1989).</div>
</div>
<div id="ref-fickettFastOptimalAlignment1984" class="csl-entry">
<div class="csl-left-margin">193. </div><div class="csl-right-inline">Fickett, J. W. <a href="https://doi.org/10.1093/nar/12.1Part1.175">Fast optimal alignment</a>. <em>Nucleic Acids Research</em> <strong>12</strong>, 175–179 (1984).</div>
</div>
<div id="ref-chaoDevelopmentsAlgorithmsSequence2022" class="csl-entry">
<div class="csl-left-margin">194. </div><div class="csl-right-inline">Chao, J., Tang, F. &amp; Xu, L. <a href="https://doi.org/10.3390/biom12040546">Developments in Algorithms for Sequence Alignment: A Review</a>. <em>Biomolecules</em> <strong>12</strong>, 546 (2022).</div>
</div>
<div id="ref-katohMAFFTNovelMethod2002" class="csl-entry">
<div class="csl-left-margin">195. </div><div class="csl-right-inline">Katoh, K., Misawa, K., Kuma, K. &amp; Miyata, T. <a href="https://doi.org/10.1093/nar/gkf436">MAFFT: A novel method for rapid multiple sequence alignment based on fast fourier transform</a>. <em>Nucleic Acids Research</em> <strong>30</strong>, 3059–3066 (2002).</div>
</div>
<div id="ref-sunChoosingBestHeuristic2006" class="csl-entry">
<div class="csl-left-margin">196. </div><div class="csl-right-inline">Sun, Y. &amp; Buhler, J. <a href="https://doi.org/10.1186/1471-2105-7-133">Choosing the best heuristic for seeded alignment of DNA sequences</a>. <em>BMC Bioinformatics</em> <strong>7</strong>, 133 (2006).</div>
</div>
<div id="ref-liSurveySequenceAlignment2010" class="csl-entry">
<div class="csl-left-margin">197. </div><div class="csl-right-inline">Li, H. &amp; Homer, N. <a href="https://doi.org/10.1093/bib/bbq015">A survey of sequence alignment algorithms for next-generation sequencing</a>. <em>Briefings in Bioinformatics</em> <strong>11</strong>, 473–483 (2010).</div>
</div>
<div id="ref-altschulBasicLocalAlignment1990" class="csl-entry">
<div class="csl-left-margin">198. </div><div class="csl-right-inline">Altschul, S. F., Gish, W., Miller, W., Myers, E. W. &amp; Lipman, D. J. <a href="https://doi.org/10.1016/S0022-2836(05)80360-2">Basic local alignment search tool</a>. <em>Journal of Molecular Biology</em> <strong>215</strong>, 403–410 (1990).</div>
</div>
<div id="ref-altschulGappedBLASTPSIBLAST1997" class="csl-entry">
<div class="csl-left-margin">199. </div><div class="csl-right-inline">Altschul, S. F. <em>et al.</em> <a href="https://doi.org/10.1093/nar/25.17.3389">Gapped BLAST and PSI-BLAST: A new generation of protein database search programs</a>. <em>Nucleic Acids Research</em> <strong>25</strong>, 3389–3402 (1997).</div>
</div>
<div id="ref-schwartzHumanMouseAlignments2003" class="csl-entry">
<div class="csl-left-margin">200. </div><div class="csl-right-inline">Schwartz, S. <em>et al.</em> <a href="https://doi.org/10.1101/gr.809403">Human<span></span>Mouse Alignments with BLASTZ</a>. <em>Genome Research</em> <strong>13</strong>, 103–107 (2003).</div>
</div>
<div id="ref-maPatternHunterFasterMore2002" class="csl-entry">
<div class="csl-left-margin">201. </div><div class="csl-right-inline">Ma, B., Tromp, J. &amp; Li, M. <a href="https://doi.org/10.1093/bioinformatics/18.3.440">PatternHunter: Faster and more sensitive homology search</a>. <em>Bioinformatics</em> <strong>18</strong>, 440–445 (2002).</div>
</div>
<div id="ref-edgarSearchClusteringOrders2010" class="csl-entry">
<div class="csl-left-margin">202. </div><div class="csl-right-inline">Edgar, R. C. <a href="https://doi.org/10.1093/bioinformatics/btq461">Search and clustering orders of magnitude faster than BLAST</a>. <em>Bioinformatics</em> <strong>26</strong>, 2460–2461 (2010).</div>
</div>
<div id="ref-buchfinkFastSensitiveProtein2015" class="csl-entry">
<div class="csl-left-margin">203. </div><div class="csl-right-inline">Buchfink, B., Xie, C. &amp; Huson, D. H. <a href="https://doi.org/10.1038/nmeth.3176">Fast and sensitive protein alignment using DIAMOND</a>. <em>Nature Methods</em> <strong>12</strong>, 59–60 (2015).</div>
</div>
<div id="ref-buchfinkSensitiveProteinAlignments2021" class="csl-entry">
<div class="csl-left-margin">204. </div><div class="csl-right-inline">Buchfink, B., Reuter, K. &amp; Drost, H.-G. <a href="https://doi.org/10.1038/s41592-021-01101-x">Sensitive protein alignments at tree-of-life scale using DIAMOND</a>. <em>Nature Methods</em> <strong>18</strong>, 366–368 (2021).</div>
</div>
<div id="ref-pearsonImprovedToolsBiological1988" class="csl-entry">
<div class="csl-left-margin">205. </div><div class="csl-right-inline">Pearson, W. R. &amp; Lipman, D. J. <a href="https://doi.org/10.1073/pnas.85.8.2444">Improved tools for biological sequence comparison</a>. <em>Proceedings of the National Academy of Sciences of the United States of America</em> <strong>85</strong>, 2444–2448 (1988).</div>
</div>
<div id="ref-lipmanRapidSensitiveProtein1985" class="csl-entry">
<div class="csl-left-margin">206. </div><div class="csl-right-inline">Lipman, D. J. &amp; Pearson, W. R. <a href="https://doi.org/10.1126/science.2983426">Rapid and sensitive protein similarity searches</a>. <em>Science (New York, N.Y.)</em> <strong>227</strong>, 1435–1441 (1985).</div>
</div>
<div id="ref-saripellaBenchmarkingNextGeneration2016" class="csl-entry">
<div class="csl-left-margin">207. </div><div class="csl-right-inline">Saripella, G. V., Sonnhammer, E. L. L. &amp; Forslund, K. <a href="https://doi.org/10.1093/bioinformatics/btw305">Benchmarking the next generation of homology inference tools</a>. <em>Bioinformatics</em> <strong>32</strong>, 2636 (2016).</div>
</div>
<div id="ref-finnPfamProteinFamilies2016" class="csl-entry">
<div class="csl-left-margin">208. </div><div class="csl-right-inline">Finn, R. D. <em>et al.</em> <a href="https://doi.org/10.1093/nar/gkv1344">The Pfam protein families database: towards a more sustainable future</a>. <em>Nucleic Acids Research</em> <strong>44</strong>, D279 (2016).</div>
</div>
<div id="ref-essoussiComparisonFourPairwise2007" class="csl-entry">
<div class="csl-left-margin">209. </div><div class="csl-right-inline">Essoussi, N. &amp; Fayech, S. A comparison of four pair-wise sequence alignment methods. <em>Bioinformation</em> <strong>2</strong>, 166–168 (2007).</div>
</div>
<div id="ref-shpaerSensitivitySelectivityProtein1996" class="csl-entry">
<div class="csl-left-margin">210. </div><div class="csl-right-inline">Shpaer, E. G. <em>et al.</em> <a href="https://doi.org/10.1006/geno.1996.0614">Sensitivity and Selectivity in Protein Similarity Searches: A Comparison of Smith<span></span>Waterman in Hardware to BLAST and FASTA</a>. <em>Genomics</em> <strong>38</strong>, 179–191 (1996).</div>
</div>
<div id="ref-schleimerWinnowingLocalAlgorithms2003" class="csl-entry">
<div class="csl-left-margin">211. </div><div class="csl-right-inline">Schleimer, S., Wilkerson, D. S. &amp; Aiken, A. Winnowing: Local algorithms for document fingerprinting. in 7685 (Association for Computing Machinery, 2003). doi:<a href="https://doi.org/10.1145/872757.872770">10.1145/872757.872770</a>.</div>
</div>
<div id="ref-robertsReducingStorageRequirements2004" class="csl-entry">
<div class="csl-left-margin">212. </div><div class="csl-right-inline">Roberts, M., Hayes, W., Hunt, B. R., Mount, S. M. &amp; Yorke, J. A. <a href="https://doi.org/10.1093/bioinformatics/bth408">Reducing storage requirements for biological sequence comparison</a>. <em>Bioinformatics</em> <strong>20</strong>, 3363–3369 (2004).</div>
</div>
<div id="ref-liMinimapMiniasmFast2016" class="csl-entry">
<div class="csl-left-margin">213. </div><div class="csl-right-inline">Li, H. <a href="https://doi.org/10.1093/bioinformatics/btw152">Minimap and miniasm: Fast mapping and de novo assembly for noisy long sequences</a>. <em>Bioinformatics</em> <strong>32</strong>, 2103–2110 (2016).</div>
</div>
<div id="ref-jainFastAdaptiveAlgorithm2018" class="csl-entry">
<div class="csl-left-margin">214. </div><div class="csl-right-inline">Jain, C., Koren, S., Dilthey, A., Phillippy, A. M. &amp; Aluru, S. <a href="https://doi.org/10.1093/bioinformatics/bty597">A fast adaptive algorithm for computing whole-genome homology maps</a>. <em>Bioinformatics</em> <strong>34</strong>, i748–i756 (2018).</div>
</div>
<div id="ref-orensteinCompactUniversalKmer2016" class="csl-entry">
<div class="csl-left-margin">215. </div><div class="csl-right-inline">Orenstein, Y., Pellow, D., Marçais, G., Shamir, R. &amp; Kingsford, C. Compact Universal k-mer Hitting Sets. in (eds. Frith, M. &amp; Storm Pedersen, C. N.) 257–268 (Springer International Publishing, 2016). doi:<a href="https://doi.org/10.1007/978-3-319-43681-4_21">10.1007/978-3-319-43681-4_21</a>.</div>
</div>
<div id="ref-marcaisImprovingPerformanceMinimizers2017" class="csl-entry">
<div class="csl-left-margin">216. </div><div class="csl-right-inline">Marçais, G. <em>et al.</em> <a href="https://doi.org/10.1093/bioinformatics/btx235">Improving the performance of minimizers and winnowing schemes</a>. <em>Bioinformatics</em> <strong>33</strong>, i110–i117 (2017).</div>
</div>
<div id="ref-chikhiRepresentationBruijnGraphs2014" class="csl-entry">
<div class="csl-left-margin">217. </div><div class="csl-right-inline">Chikhi, R., Limasset, A., Jackman, S., Simpson, J. T. &amp; Medvedev, P. On the Representation of de Bruijn Graphs. in 35–55 (Springer International Publishing, 2014). doi:<a href="https://doi.org/10.1007/978-3-319-05269-4_4">10.1007/978-3-319-05269-4_4</a>.</div>
</div>
<div id="ref-edgarSyncmersAreMore2021" class="csl-entry">
<div class="csl-left-margin">218. </div><div class="csl-right-inline">Edgar, R. <a href="https://doi.org/10.7717/peerj.10805">Syncmers are more sensitive than minimizers for selecting conserved k<span>-</span>mers in biological sequences</a>. <em>PeerJ</em> <strong>9</strong>, e10805 (2021).</div>
</div>
<div id="ref-sahlinEffectiveSequenceSimilarity2021" class="csl-entry">
<div class="csl-left-margin">219. </div><div class="csl-right-inline">Sahlin, K. <a href="https://doi.org/10.1101/gr.275648.121">Effective sequence similarity detection with strobemers</a>. <em>Genome Research</em> <strong>31</strong>, 2080–2094 (2021).</div>
</div>
<div id="ref-sahlinFlexibleSeedSize2022" class="csl-entry">
<div class="csl-left-margin">220. </div><div class="csl-right-inline">Sahlin, K. Flexible seed size enables ultra-fast and accurate read alignment. doi:<a href="https://doi.org/10.1101/2021.06.18.449070">10.1101/2021.06.18.449070</a>.</div>
</div>
<div id="ref-weinerLinearPatternMatching1973" class="csl-entry">
<div class="csl-left-margin">221. </div><div class="csl-right-inline">Weiner, P. 14th annual symposium on switching and automata theory (swat 1973). in 1–11 (1973). doi:<a href="https://doi.org/10.1109/SWAT.1973.13">10.1109/SWAT.1973.13</a>.</div>
</div>
<div id="ref-manberSuffixArraysNew1993" class="csl-entry">
<div class="csl-left-margin">222. </div><div class="csl-right-inline">Manber, U. &amp; Myers, G. <a href="https://doi.org/10.1137/0222058">Suffix arrays: A new method for on-line string searches</a>. <em>SIAM Journal on Computing</em> <strong>22</strong>, 935–948 (1993).</div>
</div>
<div id="ref-abouelhodaEnhancedSuffixArray2002" class="csl-entry">
<div class="csl-left-margin">223. </div><div class="csl-right-inline">Abouelhoda, M. I., Kurtz, S. &amp; Ohlebusch, E. The Enhanced Suffix Array and Its Applications to Genome Analysis. in (eds. Guigó, R. &amp; Gusfield, D.) 449–463 (Springer, 2002). doi:<a href="https://doi.org/10.1007/3-540-45784-4_35">10.1007/3-540-45784-4_35</a>.</div>
</div>
<div id="ref-ferraginaOpportunisticDataStructures2000" class="csl-entry">
<div class="csl-left-margin">224. </div><div class="csl-right-inline">Ferragina, P. &amp; Manzini, G. Proceedings 41st annual symposium on foundations of computer science. in 390–398 (2000). doi:<a href="https://doi.org/10.1109/SFCS.2000.892127">10.1109/SFCS.2000.892127</a>.</div>
</div>
<div id="ref-brayAVIDGlobalAlignment2003" class="csl-entry">
<div class="csl-left-margin">225. </div><div class="csl-right-inline">Bray, N., Dubchak, I. &amp; Pachter, L. <a href="https://doi.org/10.1101/gr.789803">AVID: A global alignment program</a>. <em>Genome Research</em> <strong>13</strong>, 97–102 (2003).</div>
</div>
<div id="ref-delcherFastAlgorithmsLargescale2002" class="csl-entry">
<div class="csl-left-margin">226. </div><div class="csl-right-inline">Delcher, A. L., Phillippy, A., Carlton, J. &amp; Salzberg, S. L. Fast algorithms for large-scale genome alignment and comparison. <em>Nucleic Acids Research</em> <strong>30</strong>, 2478–2483 (2002).</div>
</div>
<div id="ref-abouelhodaReplacingSuffixTrees2004" class="csl-entry">
<div class="csl-left-margin">227. </div><div class="csl-right-inline">Abouelhoda, M. I., Kurtz, S. &amp; Ohlebusch, E. <a href="https://doi.org/10.1016/S1570-8667(03)00065-0">Replacing suffix trees with enhanced suffix arrays</a>. <em>Journal of Discrete Algorithms</em> <strong>2</strong>, 53–86 (2004).</div>
</div>
<div id="ref-marcaisMUMmer4FastVersatile2018" class="csl-entry">
<div class="csl-left-margin">228. </div><div class="csl-right-inline">Marçais, G. <em>et al.</em> <a href="https://doi.org/10.1371/journal.pcbi.1005944">MUMmer4: A fast and versatile genome alignment system</a>. <em>PLOS Computational Biology</em> <strong>14</strong>, e1005944 (2018).</div>
</div>
<div id="ref-burrowsBlockSortingLosslessData1994" class="csl-entry">
<div class="csl-left-margin">229. </div><div class="csl-right-inline">Burrows, M. &amp; Wheeler, D. <em>A block-sorting lossless data compression algorithm</em>. (1994).</div>
</div>
<div id="ref-vyvermanProspectsLimitationsFulltext2012" class="csl-entry">
<div class="csl-left-margin">230. </div><div class="csl-right-inline">Vyverman, M., De Baets, B., Fack, V. &amp; Dawyndt, P. <a href="https://doi.org/10.1093/nar/gks408">Prospects and limitations of full-text index structures in genome analysis</a>. <em>Nucleic Acids Research</em> <strong>40</strong>, 6993–7015 (2012).</div>
</div>
<div id="ref-chengFMtreeFastLocating2018" class="csl-entry">
<div class="csl-left-margin">231. </div><div class="csl-right-inline">Cheng, H., Wu, M. &amp; Xu, Y. <a href="https://doi.org/10.1093/bioinformatics/btx596">FMtree: A fast locating algorithm of FM-indexes for genomic data</a>. <em>Bioinformatics</em> <strong>34</strong>, 416–424 (2018).</div>
</div>
<div id="ref-lamCompressedIndexingLocal2008" class="csl-entry">
<div class="csl-left-margin">232. </div><div class="csl-right-inline">Lam, T. W., Sung, W. K., Tam, S. L., Wong, C. K. &amp; Yiu, S. M. <a href="https://doi.org/10.1093/bioinformatics/btn032">Compressed indexing and local alignment of DNA</a>. <em>Bioinformatics</em> <strong>24</strong>, 791–797 (2008).</div>
</div>
<div id="ref-liFastAccurateShort2009" class="csl-entry">
<div class="csl-left-margin">233. </div><div class="csl-right-inline">Li, H. &amp; Durbin, R. <a href="https://doi.org/10.1093/bioinformatics/btp324">Fast and accurate short read alignment with burrows<span></span>wheeler transform</a>. <em>Bioinformatics</em> <strong>25</strong>, 1754–1760 (2009).</div>
</div>
<div id="ref-liFastAccurateLongread2010" class="csl-entry">
<div class="csl-left-margin">234. </div><div class="csl-right-inline">Li, H. &amp; Durbin, R. <a href="https://doi.org/10.1093/bioinformatics/btp698">Fast and accurate long-read alignment with burrows<span></span>wheeler transform</a>. <em>Bioinformatics</em> <strong>26</strong>, 589–595 (2010).</div>
</div>
<div id="ref-liAligningSequenceReads2013" class="csl-entry">
<div class="csl-left-margin">235. </div><div class="csl-right-inline">Li, H. Aligning sequence reads, clone sequences and assembly contigs with <span>BWA</span>-<span>MEM</span>. <a href="https://arxiv.org/abs/1303.3997">https://arxiv.org/abs/1303.3997</a> (2013).</div>
</div>
<div id="ref-liuLongReadAlignment2012" class="csl-entry">
<div class="csl-left-margin">236. </div><div class="csl-right-inline">Liu, Y. &amp; Schmidt, B. <a href="https://doi.org/10.1093/bioinformatics/bts414">Long read alignment based on maximal exact match seeds</a>. <em>Bioinformatics</em> <strong>28</strong>, i318–i324 (2012).</div>
</div>
<div id="ref-langmeadFastGappedreadAlignment2012" class="csl-entry">
<div class="csl-left-margin">237. </div><div class="csl-right-inline">Langmead, B. &amp; Salzberg, S. L. <a href="https://doi.org/10.1038/nmeth.1923">Fast gapped-read alignment with <span>Bowtie</span> 2</a>. <em>Nat Methods</em> <strong>9</strong>, 357–359 (2012).</div>
</div>
<div id="ref-songAnchorWaveSensitiveAlignment2022" class="csl-entry">
<div class="csl-left-margin">238. </div><div class="csl-right-inline">Song, B. <em>et al.</em> <a href="https://doi.org/10.1073/pnas.2113075119">AnchorWave: Sensitive alignment of genomes with high sequence diversity, extensive structural polymorphism, and whole-genome duplication</a>. <em>Proceedings of the National Academy of Sciences</em> <strong>119</strong>, e2113075119 (2022).</div>
</div>
<div id="ref-durbinBiologicalSequenceAnalysis1998" class="csl-entry">
<div class="csl-left-margin">239. </div><div class="csl-right-inline">Durbin, R., Eddy, S. R., Krogh, A. &amp; Mitchison, G. <em>Biological sequence analysis: Probabilistic models of proteins and nucleic acids</em>. (Cambridge University Press, 1998). doi:<a href="https://doi.org/10.1017/CBO9780511790492">10.1017/CBO9780511790492</a>.</div>
</div>
<div id="ref-sodingProteinHomologyDetection2005" class="csl-entry">
<div class="csl-left-margin">240. </div><div class="csl-right-inline">Söding, J. <a href="https://doi.org/10.1093/bioinformatics/bti125">Protein homology detection by HMM-HMM comparison</a>. <em>Bioinformatics (Oxford, England)</em> <strong>21</strong>, 951–960 (2005).</div>
</div>
<div id="ref-finnHMMERWebServer2011" class="csl-entry">
<div class="csl-left-margin">241. </div><div class="csl-right-inline">Finn, R. D., Clements, J. &amp; Eddy, S. R. <a href="https://doi.org/10.1093/nar/gkr367">HMMER web server: Interactive sequence similarity searching</a>. <em>Nucleic Acids Research</em> <strong>39</strong>, W29–W37 (2011).</div>
</div>
<div id="ref-wangMCALIGN2FasterAccurate2006" class="csl-entry">
<div class="csl-left-margin">242. </div><div class="csl-right-inline">Wang, J., Keightley, P. D. &amp; Johnson, T. <a href="https://doi.org/10.1186/1471-2105-7-292">MCALIGN2: Faster, accurate global pairwise alignment of non-coding DNA sequences based on explicit models of indel evolution</a>. <em>BMC Bioinformatics</em> <strong>7</strong>, 292 (2006).</div>
</div>
<div id="ref-ruffaloComparativeAnalysisAlgorithms2011" class="csl-entry">
<div class="csl-left-margin">243. </div><div class="csl-right-inline">Ruffalo, M., LaFramboise, T. &amp; Koyutürk, M. <a href="https://doi.org/10.1093/bioinformatics/btr477">Comparative analysis of algorithms for next-generation sequencing read alignment</a>. <em>Bioinformatics (Oxford, England)</em> <strong>27</strong>, 2790–2796 (2011).</div>
</div>
<div id="ref-alserTechnologyDictatesAlgorithms2021" class="csl-entry">
<div class="csl-left-margin">247. </div><div class="csl-right-inline">Alser, M. <em>et al.</em> <a href="https://doi.org/10.1186/s13059-021-02443-7">Technology dictates algorithms: Recent developments in read alignment</a>. <em>Genome Biology</em> <strong>22</strong>, 249 (2021).</div>
</div>
<div id="ref-brindaRNFGeneralFramework2016" class="csl-entry">
<div class="csl-left-margin">248. </div><div class="csl-right-inline">Břinda, K., Boeva, V. &amp; Kucherov, G. <a href="https://doi.org/10.1093/bioinformatics/btv524">RNF: A general framework to evaluate NGS read mappers</a>. <em>Bioinformatics</em> <strong>32</strong>, 136–139 (2016).</div>
</div>
<div id="ref-linKartDivideandconquerAlgorithm2017" class="csl-entry">
<div class="csl-left-margin">249. </div><div class="csl-right-inline">Lin, H.-N. &amp; Hsu, W.-L. <a href="https://doi.org/10.1093/bioinformatics/btx189">Kart: a divide-and-conquer algorithm for NGS read alignment</a>. <em>Bioinformatics (Oxford, England)</em> <strong>33</strong>, 2281–2287 (2017).</div>
</div>
<div id="ref-olsonHardwareAccelerationShort2012" class="csl-entry">
<div class="csl-left-margin">250. </div><div class="csl-right-inline">Olson, C. B. <em>et al.</em> 2012 IEEE 20th international symposium on field-programmable custom computing machines. in 161–168 (2012). doi:<a href="https://doi.org/10.1109/FCCM.2012.36">10.1109/FCCM.2012.36</a>.</div>
</div>
<div id="ref-zeniLOGANHighPerformanceGPUBased2020" class="csl-entry">
<div class="csl-left-margin">253. </div><div class="csl-right-inline">Zeni, A. <em>et al.</em> 2020 IEEE international parallel and distributed processing symposium (IPDPS). in 462–471 (2020). doi:<a href="https://doi.org/10.1109/IPDPS47924.2020.00055">10.1109/IPDPS47924.2020.00055</a>.</div>
</div>
<div id="ref-chaissonMappingSingleMolecule2012" class="csl-entry">
<div class="csl-left-margin">254. </div><div class="csl-right-inline">Chaisson, M. J. &amp; Tesler, G. <a href="https://doi.org/10.1186/1471-2105-13-238">Mapping single molecule sequencing reads using basic local alignment with successive refinement (BLASR): Application and theory</a>. <em>BMC Bioinformatics</em> <strong>13</strong>, 238 (2012).</div>
</div>
<div id="ref-haghshenasLordFASTSensitiveFast2019" class="csl-entry">
<div class="csl-left-margin">255. </div><div class="csl-right-inline">Haghshenas, E., Sahinalp, S. C. &amp; Hach, F. <a href="https://doi.org/10.1093/bioinformatics/bty544">lordFAST: sensitive and Fast Alignment Search Tool for LOng noisy Read sequencing Data</a>. <em>Bioinformatics (Oxford, England)</em> <strong>35</strong>, 20–27 (2019).</div>
</div>
<div id="ref-sovicFastSensitiveMapping2016" class="csl-entry">
<div class="csl-left-margin">256. </div><div class="csl-right-inline">Sović, I. <em>et al.</em> <a href="https://doi.org/10.1038/ncomms11307">Fast and sensitive mapping of nanopore sequencing reads with GraphMap</a>. <em>Nature Communications</em> <strong>7</strong>, 11307 (2016).</div>
</div>
<div id="ref-sedlazeckAccurateDetectionComplex2018" class="csl-entry">
<div class="csl-left-margin">257. </div><div class="csl-right-inline">Sedlazeck, F. J. <em>et al.</em> <a href="https://doi.org/10.1038/s41592-018-0001-7">Accurate detection of complex structural variations using single-molecule sequencing</a>. <em>Nature Methods</em> <strong>15</strong>, 461–468 (2018).</div>
</div>
<div id="ref-jainFastApproximateAlgorithm2018" class="csl-entry">
<div class="csl-left-margin">258. </div><div class="csl-right-inline">Jain, C., Dilthey, A., Koren, S., Aluru, S. &amp; Phillippy, A. M. <a href="https://doi.org/10.1089/cmb.2018.0036">A fast approximate algorithm for mapping long reads to large reference databases</a>. <em>Journal of Computational Biology</em> <strong>25</strong>, 766–779 (2018).</div>
</div>
<div id="ref-prodanovSensitiveAlignmentUsing2020" class="csl-entry">
<div class="csl-left-margin">259. </div><div class="csl-right-inline">Prodanov, T. &amp; Bansal, V. <a href="https://doi.org/10.1093/nar/gkaa829">Sensitive alignment using paralogous sequence variants improves long-read mapping and variant calling in segmental duplications</a>. <em>Nucleic Acids Research</em> <strong>48</strong>, e114 (2020).</div>
</div>
<div id="ref-jainLongreadMappingRepetitive2022" class="csl-entry">
<div class="csl-left-margin">260. </div><div class="csl-right-inline">Jain, C., Rhie, A., Hansen, N. F., Koren, S. &amp; Phillippy, A. M. <a href="https://doi.org/10.1038/s41592-022-01457-8">Long-read mapping to repetitive reference sequences using Winnowmap2</a>. <em>Nature Methods</em> <strong>19</strong>, 705–710 (2022).</div>
</div>
<div id="ref-mikheenkoTandemToolsMappingLong2020" class="csl-entry">
<div class="csl-left-margin">261. </div><div class="csl-right-inline">Mikheenko, A., Bzikadze, A. V., Gurevich, A., Miga, K. H. &amp; Pevzner, P. A. <a href="https://doi.org/10.1093/bioinformatics/btaa440"><span>TandemTools</span>: Mapping long reads and assessing/improving assembly quality in extra-long tandem repeats</a>. <em>Bioinformatics</em> <strong>36</strong>, i75–i83 (2020).</div>
</div>
<div id="ref-liMappingShortDNA2008" class="csl-entry">
<div class="csl-left-margin">262. </div><div class="csl-right-inline">Li, H., Ruan, J. &amp; Durbin, R. <a href="https://doi.org/10.1101/gr.078212.108">Mapping short DNA sequencing reads and calling variants using mapping quality scores</a>. <em>Genome Research</em> <strong>18</strong>, 1851–1858 (2008).</div>
</div>
<div id="ref-liSequenceAlignmentMap2009a" class="csl-entry">
<div class="csl-left-margin">263. </div><div class="csl-right-inline">Li, H. <em>et al.</em> <a href="https://doi.org/10.1093/bioinformatics/btp352">The sequence alignment/map format and SAMtools</a>. <em>Bioinformatics</em> <strong>25</strong>, 2078–2079 (2009).</div>
</div>
<div id="ref-UnderstandingMAPQScores" class="csl-entry">
<div class="csl-left-margin">264. </div><div class="csl-right-inline">Understanding MAPQ scores in SAM files: Does 37 = 42?</div>
</div>
<div id="ref-leeGenomicDarkMatter2012" class="csl-entry">
<div class="csl-left-margin">265. </div><div class="csl-right-inline">Lee, H. &amp; Schatz, M. C. <a href="https://doi.org/10.1093/bioinformatics/bts330">Genomic dark matter: The reliability of short read mapping illustrated by the genome mappability score</a>. <em>Bioinformatics</em> <strong>28</strong>, 2097–2105 (2012).</div>
</div>
<div id="ref-langmeadTandemSimulationFramework2017" class="csl-entry">
<div class="csl-left-margin">266. </div><div class="csl-right-inline">Langmead, B. <a href="https://doi.org/10.1186/s13059-017-1290-3">A tandem simulation framework for predicting mapping quality</a>. <em>Genome Biology</em> <strong>18</strong>, 152 (2017).</div>
</div>
<div id="ref-ruffaloAccurateEstimationShort2012" class="csl-entry">
<div class="csl-left-margin">267. </div><div class="csl-right-inline">Ruffalo, M., Koyutürk, M., Ray, S. &amp; LaFramboise, T. <a href="https://doi.org/10.1093/bioinformatics/bts408">Accurate estimation of short read mapping quality for next-generation genome sequencing</a>. <em>Bioinformatics</em> <strong>28</strong>, i349–i355 (2012).</div>
</div>
<div id="ref-russellMultipleSequenceAlignment2014" class="csl-entry">
<div class="csl-left-margin">268. </div><div class="csl-right-inline"><em><a href="https://doi.org/10.1007/978-1-62703-646-7">Multiple Sequence Alignment Methods</a></em>. vol. 1079 (Humana Press, 2014).</div>
</div>
<div id="ref-wangComplexityMultipleSequence1994" class="csl-entry">
<div class="csl-left-margin">269. </div><div class="csl-right-inline">Wang, L. &amp; Jiang, T. <a href="https://doi.org/10.1089/cmb.1994.1.337">On the complexity of multiple sequence alignment</a>. <em>Journal of Computational Biology</em> <strong>1</strong>, 337–348 (1994).</div>
</div>
<div id="ref-justComputationalComplexityMultiple2001" class="csl-entry">
<div class="csl-left-margin">270. </div><div class="csl-right-inline">Just, W. <a href="https://doi.org/10.1089/106652701753307511">Computational complexity of multiple sequence alignment with SP-score</a>. <em>Journal of Computational Biology</em> <strong>8</strong>, 615–623 (2001).</div>
</div>
<div id="ref-tangHAlignFastMultiple2022" class="csl-entry">
<div class="csl-left-margin">271. </div><div class="csl-right-inline">Tang, F. <em>et al.</em> <a href="https://doi.org/10.1093/molbev/msac166">HAlign 3: Fast multiple alignment of ultra-large numbers of similar DNA/RNA sequences</a>. <em>Molecular Biology and Evolution</em> <strong>39</strong>, msac166 (2022).</div>
</div>
<div id="ref-fengProgressiveSequenceAlignment1987" class="csl-entry">
<div class="csl-left-margin">272. </div><div class="csl-right-inline">Feng, D.-F. &amp; Doolittle, R. F. <a href="https://doi.org/10.1007/BF02603120">Progressive sequence alignment as a prerequisitetto correct phylogenetic trees</a>. <em>Journal of Molecular Evolution</em> <strong>25</strong>, 351–360 (1987).</div>
</div>
<div id="ref-jonesRapidGenerationMutation1992" class="csl-entry">
<div class="csl-left-margin">273. </div><div class="csl-right-inline">Jones, D. T., Taylor, W. R. &amp; Thornton, J. M. <a href="https://doi.org/10.1093/bioinformatics/8.3.275">The rapid generation of mutation data matrices from protein sequences</a>. <em>Bioinformatics</em> <strong>8</strong>, 275–282 (1992).</div>
</div>
<div id="ref-blaisdellMeasureSimilaritySets1986" class="csl-entry">
<div class="csl-left-margin">274. </div><div class="csl-right-inline">Blaisdell, B. E. <a href="https://doi.org/10.1073/pnas.83.14.5155">A measure of the similarity of sets of sequences not requiring sequence alignment.</a> <em>Proceedings of the National Academy of Sciences</em> <strong>83</strong>, 5155–5159 (1986).</div>
</div>
<div id="ref-gronauOptimalImplementationsUPGMA2007" class="csl-entry">
<div class="csl-left-margin">275. </div><div class="csl-right-inline">Gronau, I. &amp; Moran, S. <a href="https://doi.org/10.1016/j.ipl.2007.07.002">Optimal implementations of UPGMA and other common clustering algorithms</a>. <em>Information Processing Letters</em> <strong>104</strong>, 205–210 (2007).</div>
</div>
<div id="ref-saitouNeighborjoiningMethodNew1987" class="csl-entry">
<div class="csl-left-margin">276. </div><div class="csl-right-inline">Saitou, N. &amp; Nei, M. <a href="https://doi.org/10.1093/oxfordjournals.molbev.a040454">The neighbor-joining method: A new method for reconstructing phylogenetic trees.</a> <em>Molecular Biology and Evolution</em> <strong>4</strong>, 406–425 (1987).</div>
</div>
<div id="ref-katohPartTreeAlgorithmBuild2007" class="csl-entry">
<div class="csl-left-margin">277. </div><div class="csl-right-inline">Katoh, K. &amp; Toh, H. <a href="https://doi.org/10.1093/bioinformatics/btl592">PartTree: An algorithm to build an approximate tree from a large number of unaligned sequences</a>. <em>Bioinformatics</em> <strong>23</strong>, 372–374 (2007).</div>
</div>
<div id="ref-sieversFastScalableGeneration2011" class="csl-entry">
<div class="csl-left-margin">278. </div><div class="csl-right-inline">Sievers, F. <em>et al.</em> <a href="https://doi.org/10.1038/msb.2011.75">Fast, scalable generation of high<span>-</span>quality protein multiple sequence alignments using Clustal Omega</a>. <em>Molecular Systems Biology</em> <strong>7</strong>, 539 (2011).</div>
</div>
<div id="ref-blackshieldsSequenceEmbeddingFast2010" class="csl-entry">
<div class="csl-left-margin">279. </div><div class="csl-right-inline">Blackshields, G., Sievers, F., Shi, W., Wilm, A. &amp; Higgins, D. G. <a href="https://doi.org/10.1186/1748-7188-5-21">Sequence embedding for fast construction of guide trees for multiple sequence alignment</a>. <em>Algorithms for Molecular Biology</em> <strong>5</strong>, 21 (2010).</div>
</div>
<div id="ref-altschulGapCostsMultiple1989" class="csl-entry">
<div class="csl-left-margin">280. </div><div class="csl-right-inline">Altschul, S. F. <a href="https://doi.org/10.1016/S0022-5193(89)80196-1">Gap costs for multiple sequence alignment</a>. <em>Journal of Theoretical Biology</em> <strong>138</strong>, 297–309 (1989).</div>
</div>
<div id="ref-altschulWeightsDataRelated1989" class="csl-entry">
<div class="csl-left-margin">281. </div><div class="csl-right-inline">Altschul, S. F., Carroll, R. J. &amp; Lipman, D. J. <a href="https://doi.org/10.1016/0022-2836(89)90234-9">Weights for data related by a tree</a>. <em>Journal of Molecular Biology</em> <strong>207</strong>, 647–653 (1989).</div>
</div>
<div id="ref-edgarComparisonScoringFunctions2004" class="csl-entry">
<div class="csl-left-margin">282. </div><div class="csl-right-inline">Edgar, R. C. &amp; Sjölander, K. <a href="https://doi.org/10.1093/bioinformatics/bth090">A comparison of scoring functions for protein sequence profile alignment</a>. <em>Bioinformatics</em> <strong>20</strong>, 1301–1308 (2004).</div>
</div>
<div id="ref-notredameCOFFEEObjectiveFunction1998" class="csl-entry">
<div class="csl-left-margin">283. </div><div class="csl-right-inline">Notredame, C., Holm, L. &amp; Higgins, D. G. <a href="https://doi.org/10.1093/bioinformatics/14.5.407">COFFEE: An objective function for multiple sequence alignments.</a> <em>Bioinformatics</em> <strong>14</strong>, 407–422 (1998).</div>
</div>
<div id="ref-notredameTcoffeeNovelMethod2000" class="csl-entry">
<div class="csl-left-margin">284. </div><div class="csl-right-inline">Notredame, C., Higgins, D. G. &amp; Heringa, J. <a href="https://doi.org/10.1006/jmbi.2000.4042">T-coffee: a novel method for fast and accurate multiple sequence alignment11Edited by J. Thornton</a>. <em>Journal of Molecular Biology</em> <strong>302</strong>, 205–217 (2000).</div>
</div>
<div id="ref-edgarMUSCLEMultipleSequence2004a" class="csl-entry">
<div class="csl-left-margin">285. </div><div class="csl-right-inline">Edgar, R. C. <a href="https://doi.org/10.1186/1471-2105-5-113">MUSCLE: A multiple sequence alignment method with reduced time and space complexity</a>. <em>BMC Bioinformatics</em> <strong>5</strong>, 113 (2004).</div>
</div>
<div id="ref-edgarMUSCLEMultipleSequence2004" class="csl-entry">
<div class="csl-left-margin">286. </div><div class="csl-right-inline">Edgar, R. C. <a href="https://doi.org/10.1093/nar/gkh340">MUSCLE: Multiple sequence alignment with high accuracy and high throughput</a>. <em>Nucleic Acids Research</em> <strong>32</strong>, 1792–1797 (2004).</div>
</div>
<div id="ref-doProbConsProbabilisticConsistencybased2005" class="csl-entry">
<div class="csl-left-margin">287. </div><div class="csl-right-inline">Do, C. B., Mahabhashyam, M. S. P., Brudno, M. &amp; Batzoglou, S. <a href="https://doi.org/10.1101/gr.2821705">ProbCons: Probabilistic consistency-based multiple sequence alignment</a>. <em>Genome Research</em> <strong>15</strong>, 330–340 (2005).</div>
</div>
<div id="ref-thompsonCLUSTALImprovingSensitivity1994" class="csl-entry">
<div class="csl-left-margin">288. </div><div class="csl-right-inline">Thompson, J. D., Higgins, D. G. &amp; Gibson, T. J. <a href="https://doi.org/10.1093/nar/22.22.4673">CLUSTAL W: improving the sensitivity of progressive multiple sequence alignment through sequence weighting, position-specific gap penalties and weight matrix choice</a>. <em>Nucleic Acids Research</em> <strong>22</strong>, 4673–4680 (1994).</div>
</div>
<div id="ref-thompsonCLUSTALWindowsInterface1997" class="csl-entry">
<div class="csl-left-margin">289. </div><div class="csl-right-inline">Thompson, J. D., Gibson, T. J., Plewniak, F., Jeanmougin, F. &amp; Higgins, D. G. <a href="https://doi.org/10.1093/nar/25.24.4876">The CLUSTAL<span>_</span>x windows interface: Flexible strategies for multiple sequence alignment aided by quality analysis tools</a>. <em>Nucleic Acids Research</em> <strong>25</strong>, 4876–4882 (1997).</div>
</div>
<div id="ref-liuMSAProbsMultipleSequence2010" class="csl-entry">
<div class="csl-left-margin">290. </div><div class="csl-right-inline">Liu, Y., Schmidt, B. &amp; Maskell, D. L. <a href="https://doi.org/10.1093/bioinformatics/btq338">MSAProbs: Multiple sequence alignment based on pair hidden markov models and partition function posterior probabilities</a>. <em>Bioinformatics</em> <strong>26</strong>, 1958–1964 (2010).</div>
</div>
<div id="ref-lemoineCOVIDAlignAccurateOnline2020" class="csl-entry">
<div class="csl-left-margin">291. </div><div class="csl-right-inline">Lemoine, F., Blassel, L., Voznica, J. &amp; Gascuel, O. COVID-align: Accurate online alignment of hCoV-19 genomes using a profile HMM. <em>Bioinformatics</em> (2020) doi:<a href="https://doi.org/10.1093/bioinformatics/btaa871">10.1093/bioinformatics/btaa871</a>.</div>
</div>
<div id="ref-eddyMultipleAlignmentUsing" class="csl-entry">
<div class="csl-left-margin">292. </div><div class="csl-right-inline">Eddy, S. R. Multiple Alignment Using Hidden Markov Models. 7.</div>
</div>
<div id="ref-kimMultipleSequenceAlignment1994" class="csl-entry">
<div class="csl-left-margin">293. </div><div class="csl-right-inline">Kim, J., Pramanik, S. &amp; Chung, M. J. <a href="https://doi.org/10.1093/bioinformatics/10.4.419">Multiple sequence alignment using simulated annealing</a>. <em>Bioinformatics</em> <strong>10</strong>, 419–426 (1994).</div>
</div>
<div id="ref-huoSimulatedAnnealingAlgorithm2007" class="csl-entry">
<div class="csl-left-margin">295. </div><div class="csl-right-inline">Huo, H. &amp; Stojkovic, V. <a href="https://doi.org/10.1109/ICNC.2007.139">Third international conference on natural computation (ICNC 2007)</a>. in vol. 2 270–274 (2007).</div>
</div>
<div id="ref-chowdhuryReviewMultipleSequence2017" class="csl-entry">
<div class="csl-left-margin">296. </div><div class="csl-right-inline">Chowdhury, B. &amp; Garai, G. <a href="https://doi.org/10.1016/j.ygeno.2017.06.007">A review on multiple sequence alignment from the perspective of genetic algorithm</a>. <em>Genomics</em> <strong>109</strong>, 419–431 (2017).</div>
</div>
<div id="ref-zhangGeneticAlgorithmMultiple1997" class="csl-entry">
<div class="csl-left-margin">297. </div><div class="csl-right-inline">Zhang, C. &amp; Wong, A. K. C. <a href="https://doi.org/10.1093/bioinformatics/13.6.565">A genetic algorithm for multiple molecular sequence alignment</a>. <em>Bioinformatics</em> <strong>13</strong>, 565–581 (1997).</div>
</div>
<div id="ref-nazninVerticalDecompositionGenetic2011" class="csl-entry">
<div class="csl-left-margin">298. </div><div class="csl-right-inline">Naznin, F., Sarker, R. &amp; Essam, D. <a href="https://doi.org/10.1186/1471-2105-12-353">Vertical decomposition with genetic algorithm for multiple sequence alignment</a>. <em>BMC Bioinformatics</em> <strong>12</strong>, 353 (2011).</div>
</div>
<div id="ref-nazninProgressiveAlignmentMethod2012" class="csl-entry">
<div class="csl-left-margin">299. </div><div class="csl-right-inline">Naznin, F., Sarker, R. &amp; Essam, D. <a href="https://doi.org/10.1109/TEVC.2011.2162849">Progressive alignment method using genetic algorithm for multiple sequence alignment</a>. <em>IEEE Transactions on Evolutionary Computation</em> <strong>16</strong>, 615–631 (2012).</div>
</div>
<div id="ref-notredameSAGASequenceAlignment1996" class="csl-entry">
<div class="csl-left-margin">300. </div><div class="csl-right-inline">Notredame, C. &amp; Higgins, D. G. SAGA: Sequence alignment by genetic algorithm. <em>Nucleic Acids Research</em> <strong>24</strong>, 1515–1524 (1996).</div>
</div>
<div id="ref-aksamentovNextcladeCladeAssignment2021" class="csl-entry">
<div class="csl-left-margin">301. </div><div class="csl-right-inline">Aksamentov, I., Roemer, C., Hodcroft, E. &amp; Neher, R. <a href="https://doi.org/10.21105/joss.03773">Nextclade: clade assignment, mutation calling and quality control for viral genomes</a>. <em>Journal of Open Source Software</em> <strong>6</strong>, 3773 (2021).</div>
</div>
<div id="ref-garrigaLargeMultipleSequence2019" class="csl-entry">
<div class="csl-left-margin">302. </div><div class="csl-right-inline">Garriga, E. <em>et al.</em> <a href="https://doi.org/10.1038/s41587-019-0333-6">Large multiple sequence alignments with a root-to-leaf regressive method</a>. <em>Nature Biotechnology</em> <strong>37</strong>, 1466–1470 (2019).</div>
</div>
<div id="ref-notredameRecentEvolutionsMultiple2007" class="csl-entry">
<div class="csl-left-margin">303. </div><div class="csl-right-inline">Notredame, C. <a href="https://doi.org/10.1371/journal.pcbi.0030123">Recent Evolutions of Multiple Sequence Alignment Algorithms</a>. <em>PLOS Computational Biology</em> <strong>3</strong>, e123 (2007).</div>
</div>
<div id="ref-thompsonBAliBASEBenchmarkAlignment1999" class="csl-entry">
<div class="csl-left-margin">307. </div><div class="csl-right-inline">Thompson, J. D., Plewniak, F. &amp; Poch, O. <a href="https://doi.org/10.1093/bioinformatics/15.1.87">BAliBASE: a benchmark alignment database for the evaluation of multiple alignment programs.</a> <em>Bioinformatics</em> <strong>15</strong>, 87–88 (1999).</div>
</div>
</div>
<div class="footnotes">
<hr />
<ol start="4">
<li id="fn4"><p>Here I am using an index starting at 1 and inclusive, so <span class="math inline">\(S_1[1,n-1]\)</span> represents the first <span class="math inline">\(n-1\)</span> characters. If <span class="math inline">\(S_1 = ABCD\)</span> then <span class="math inline">\(S_1[1;3]=ABC\)</span><a href="aligning-sequence-data.html#fnref4" class="footnote-back">↩︎</a></p></li>
</ol>
</div>
            </section>

          </div>
        </div>
      </div>
<a href="what-is-sequence-data.html" class="navigation navigation-prev " aria-label="Previous page"><i class="fa fa-angle-left"></i></a>
<a href="HPC-paper.html" class="navigation navigation-next " aria-label="Next page"><i class="fa fa-angle-right"></i></a>
    </div>
  </div>
<script src="libs/gitbook-2.6.7/js/app.min.js"></script>
<script src="libs/gitbook-2.6.7/js/clipboard.min.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-search.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-sharing.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-fontsettings.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-bookdown.js"></script>
<script src="libs/gitbook-2.6.7/js/jquery.highlight.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-clipboard.js"></script>
<script>
gitbook.require(["gitbook"], function(gitbook) {
gitbook.start({
"sharing": {
"github": false,
"facebook": true,
"twitter": true,
"linkedin": false,
"weibo": false,
"instapaper": false,
"vk": false,
"whatsapp": false,
"all": ["facebook", "twitter", "linkedin", "weibo", "instapaper"]
},
"fontsettings": {
"theme": "white",
"family": "sans",
"size": 2
},
"edit": {
"link": "https://github.com/lucblassel/phd-manuscript/edit/main/02-aligning-sequences.Rmd",
"text": "Edit"
},
"history": {
"link": null,
"text": null
},
"view": {
"link": null,
"text": null
},
"download": ["_main.pdf"],
"search": {
"engine": "fuse",
"options": null
},
"toc": {
"collapse": "none"
}
});
});
</script>

<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    var src = "true";
    if (src === "" || src === "true") src = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML";
    if (location.protocol !== "file:")
      if (/^https?:/.test(src))
        src = src.replace(/^https?:/, '');
    script.src = src;
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>
</body>

</html>
